#!/usr/bin/perl
#
# get_iplayer - Lists and downloads BBC iPlayer TV and Radio programmes, BBC Podcasts, and ITV player Programmes
#
#    Copyright (C) 2009 Phil Lewis
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Phil Lewis
# Email: iplayer (at sign) linuxcentre.net
# Web: http://linuxcentre.net/iplayer
# License: GPLv3 (see LICENSE.txt)
#
#
package main;
my $version = 1.36;
#
# Help:
#	./get_iplayer --help | --longhelp
#
# Changelog:
# 	http://linuxcentre.net/get_iplayer/CHANGELOG.txt
#
# Example Usage and Documentation:
# 	http://linuxcentre.net/getiplayer/documentation
#
# Todo:
# * Fix non-uk detection - iphone auth?
# * Index/Download live radio streams w/schedule feeds to assist timing
# * Remove all rtsp/mplayer/lame/tee dross when realaudio streams become obselete (not quite yet)
# * Stdout mode with rtmp
# * Do subtitle downloading after programme download so that rtmp auth doesn't timeout
# * Playlist creation for multipart itv downloads
# ** BBC Learning zone progs?
# ** all global vars into a class???
# ** all global URLs into a hash/class???
# ** Cut down 'use' clauses in each class 
# ** Globalise %prog, %got_cache so that they aren't repopulated for every PVR run
# * Get --info to show whether subtitles are available
# * rtmpdump now reports correct exitcode - fix code to recognise this
# * Get more than just the recent series' episodes off hulu
#
# Known Issues:
# * In ActivePerl/windows downloaded iPhone video files do not get renamed and remain with .partial.mov (broken 'move' sub?)
# * vlc does not quit after downloading an rtsp N95 video stream (ctrl-c is required) - need a --play-and-quit option if such a thing exists
# * rtmpdump (v1.2) of flashaudio fails at end of stream => non-zero exit code
# * Some rtmpdump downloads always give a non-zero exit code regardless of success (using a min-filesize workaround for now)
# * resuming a flashaudio download fails
# * rtmpdump-v1.3 doesn't work correctly for flashhigh mode - keeps hanging on download
# * Hulu indexing takes way too long
#
# Bugs to fix:
# * fork returns non-pid value for itv under ActivePerl - will need to implement serial download instead
# * Realaudio mode does not create symlink until finished downloading

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use Getopt::Long;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
#use LWP::Debug qw(+);
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
#use warnings;
use Time::Local;
use URI;
$|=1;


# Hash of all prog types => Programme class
# Add an entry here if another Programme class is added
my %prog_types = (
	tv	=> 'Programme::tv',
	radio	=> 'Programme::radio',
	podcast	=> 'Programme::podcast',
	itv	=> 'Programme::itv',
	hulu	=> 'Programme::hulu',
);

# Programme instance data
# $prog{$pid} = Programme->new (
#	'index'		=> <index number>,
#	'name'		=> <programme short name>,
#	'episode'	=> <Episode info>,
#	'desc'		=> <Long Description>,
#	'available'	=> <Date/Time made available or remaining>,
#	'duration'	=> <duration in HH:MM:SS>
#	'versions'	=> <comma separated list of versions, e.g default, signed>
#	'thumbnail'	=> <programme thumbnail url>
#	'channel	=> <channel>
#	'categories'	=> <Comma separated list of categories>
# 	'type'		=> <Type: tv, radio, itv or podcast>
#	'timeadded'	=> <timestamp when programme was added to cache>
#	'longname'	=> <Long name (only parsed in stage 1 download)>,
#	'version'	=> <selected version e.g default, signed, etc - only set before d/load>
#	'filename'	=> <Path and Filename of saved file - set only while downloading>
#	'dir'		=> <Filename Directory of saved file - set only while downloading>
#	'fileprefix'	=> <Filename Prefix of saved file - set only while downloading>
#	'ext'		=> <Filename Extension of saved file - set only while downloading>
#);


# Final options instance
my $opt = Options->new();
# Command line options instance
my $opt_cmdline = Options->new();
# Options file instance
my $opt_file = Options->new();

# Set Programme/Pvr/Streamer class global var refs to the Options instance
Programme->add_opt_object($opt);
Pvr->add_opt_object($opt);
Pvr->add_opt_file_object($opt_file);
Pvr->add_opt_cmdline_object($opt_cmdline);
Streamer->add_opt_object($opt);

# Print to STDERR/STDOUT if not quiet unless verbose or debug
sub logger(@) {
	# Make sure quiet can be overridden by verbose and debug options
	if ( $opt->{verbose} || $opt->{debug} || ! $opt->{quiet} ) {
		# Only send messages to STDERR if pvr or stdout options are being used.
		if ( $opt->{stdout} || $opt->{pvr} || $opt->{stderr} ) {
			print STDERR $_[0];
		} else {
			print STDOUT $_[0];
		}
	}
}

# Define general 'option names' => ( <advanced>, <option cmdline format>, <option help section>, <option help> )
# If you want the option to be hidden then don't specify <option cmdline format>, use ''
my %opt_format = (
	amode 		=> [ 1, "amode=s", 'Download', '--amode <mode>,<mode>,...', "Audio Download mode(s): Radio: iphone,flashaac,flashaudio,realaudio (default: iphone,flashaac,flashaudio,realaudio)"],
	category 	=> [ 0, "category=s", 'Search', '--category <regex>', "Narrow search to matched categories"],
	channel		=> [ 0, "channel=s", 'Search', '--channel <regex>', "Narrow search to matched channel(s)"],
	command		=> [ 1, "c|command=s", 'Output', '--command, -c <command>', "Run user command after successful download using args such as <pid>, <name> etc"],
	conditions	=> [ 0, "conditions", '', '', 'Shows GPL conditions'],
	fields		=> [ 1, "fields=s", 'Search', '--fields <field1>,<field2>,..', "Searches only in the specified comma separated fields"],
	debug		=> [ 1, "debug", 'Config', '--debug', "Debug output"],
	exclude		=> [ 1, "exclude=s", 'Search', '--exclude <regex>', "Narrow search to exclude matched programme names"],
	excludecategory	=> [ 1, "xcat|exclude-category=s", 'Search', '--exclude-category <regex>', "Narrow search to exclude matched catogories"],
	excludechannel	=> [ 1, "xchan|exclude-channel=s", 'Search', '--exclude-channel <regex>', "Narrow search to exclude matched channel(s)"],
	expiry		=> [ 1, "expiry|e=n", 'Config', '--expiry, -e <secs>', "Cache expiry in seconds (default 4hrs)"],
	fileprefix	=> [ 1, "file-prefix|fileprefix=s", 'Output', '--file-prefix <format>', "The filename prefix (excluding dir and extension) using formatting fields. e.g. '<name>-<episode>-<pid>'"],
	flush		=> [ 0, "flush|refresh|f", 'Config', '--flush, --refresh, -f', "Refresh cache"],
	forcedownload	=> [ 1, "force-download", 'Download', '--force-download', "Ignore download history (unsets --hide option also)"],
	fxd		=> [ 1, "fxd=s", 'Output', '--fxd <file>', "Create Freevo FXD XML of matching programmes in specified file"],
	get		=> [ 0, "get|g", 'Download', '--get, -g', "Download matching programmes"],
	help		=> [ 0, "help|h", 'Config', '--help, -h', "This help text"],
	helplong	=> [ 0, "help-long|advanced|long-help|helplong", 'Config', '--helplong', "Advanced options help text"],
	hide		=> [ 1, "hide", 'Display', '--hide', "Hide previously downloaded programmes"],
	html		=> [ 1, "html=s", 'Output', '--html <file>', "Create basic HTML index of matching programmes in specified file"],
	id3v2		=> [ 0, "id3v2=s", 'External Program', '--id3v2 <path>', "Location of id3v2 binary"],
	info		=> [ 0, "i|info", 'Display', '--info, -i', "Show full programme metadata (only if number of matches < 50)"],
	list		=> [ 1, "list=s", 'Display', '--list <categories|channel>', "Show a list of available categories/channels for the selected type and exit"],
	listformat	=> [ 1, "listformat=s", 'Display', '--listformat <format>', "Display programme data based on a user-defined format string (such as <pid>, <name> etc)"],
	long		=> [ 0, "long|l", 'Search', '--long, -l', "Additionally search & display long programme descriptions / episode names"],
	mp3audio	=> [ 0, "mp3audio", '', '', ""],
	mplayer		=> [ 0, "mplayer=s", 'External Program', '--mplayer <path>', "Location of mplayer binary"],
	mythtv		=> [ 1, "mythtv=s", 'Output', '--mythtv <file>', "Create Mythtv streams XML of matching programmes in specified file"],
	nowrite		=> [ 1, "no-write|nowrite|n", 'Output', '--nowrite, -n', "No writing of file to disk (use with -x to prevent a copy being stored on disk)"],
	output		=> [ 0, "output|o=s", 'Output', '--output, -o <dir>', "Default Download output directory for all downloads"],
	partialproxy	=> [ 1, "partial-proxy", 'Download', '--partial-proxy', "Works around for some broken web proxies (try this extra option if your proxy fails)"],
	pid		=> [ 0, "pid=s", 'Download', '--pid <pid>|<type>:<pid>|<pidurl>', "Download an arbitrary pid that does not necessarily appear in the index"],
	proxy		=> [ 0, "proxy|p=s", 'Download', '--proxy, -p <url>', "Web proxy URL spec"],
	quiet		=> [ 1, "q|quiet|silent", 'Output', '--quiet, -q', "No logging output"],
	raw		=> [ 0, "raw", 'Download', '--raw', "Don't transcode or change the downloaded stream in any way (i.e. radio/realaudio, rtmp/flv, iphone/mov)"],
	save 		=> [ 0, "save", 'Config', '--save', "Save specified options as default"],
	showoptions	=> [ 1, "showoptions|showopts|show-options", 'Display', '--show-options', 'Shows options which are set and where they are defined'],
	since		=> [ 1, "since=n", 'Search', '--since', "Limit search to programmes added to the cache in the last N hours"],
	stdout		=> [ 1, "stdout|x", 'Download', '--stdout, -x', "Additionally stream to STDOUT (so you can pipe output to a player)"],
	streaminfo	=> [ 1, "streaminfo", 'Display', '--streaminfo', "Returns all of the media stream urls of the programme(s)"],
	subdir		=> [ 1, "subdirs|subdir|s", 'Output', '--subdir, -s', "Downloaded files into Programme name subdirectory"],
	suboffset	=> [ 1, "suboffset=n", 'Download', '--suboffset <offset>', "Offset the subtitle timestamps by the specified number of milliseconds"],
	subtitles	=> [ 0, "subtitles", 'Download', '--subtitles', "In TV mode, download subtitles into srt/SubRip format if available"],
	symlink		=> [ 1, "symlink|freevo=s", 'Output', '--symlink <file>', "Create symlink to <file> once we have the header of the download"],
	test		=> [ 1, "test|t", 'Download', '--test, -t', "Test only - no download (will show programme type)"],
	terse		=> [ 0, "terse", 'Display', '--terse', "Only show terse programme info (does not affect searching)"],
	tree		=> [ 0, "tree", 'Display', '--tree', "Display Programme listings in a tree view"],
	type		=> [ 0, "type=s", 'Search', '--type <type>', "Only search in these types of programmes: radio,tv,podcast,itv,hulu,all (tv is default)"],
	update		=> [ 0, "update|u", 'Config', '--update, -u', "Update get_iplayer if a newer one exists"],
	versionlist	=> [ 1, "versionlist|version-list=s", 'Download', '--version-list <versions>', "Override the version of programme to download (e.g. '--version-list signed,default')"],
	versions	=> [ 1, "versions=s", 'Search', '--versions <regex>', "Narrow search to matched programme version(s)"],
	verbose		=> [ 1, "verbose|v", 'Config', '--verbose, -v', "Verbose"],
	vmode		=> [ 1, "vmode=s", 'Download', '--vmode <mode>,<mode>,...', "Video Download mode(s): iphone,rtmp,flashhigh,flashnormal,flashlow,n95_wifi (default: iphone,flashhigh,flashnormal)"],
	warranty	=> [ 0, "warranty", '', '', 'Displays warranty section of GPL'],
	whitespace	=> [ 1, "whitespace|ws|w", 'Output', '--whitespace, -w', "Keep whitespace (and escape chars) in filenames"],
	xmlchannels	=> [ 1, "xml-channels|fxd-channels", 'Output', '--xml-channels', "Create freevo/Mythtv menu of channels -> programme names -> episodes"],
	xmlnames	=> [ 1, "xml-names|fxd-names", 'Output', '--xml-names', "Create freevo/Mythtv menu of programme names -> episodes"],
	xmlalpha	=> [ 1, "xml-alpha|fxd-alpha", 'Output', '--xml-alpha', "Create freevo/Mythtv menu sorted alphabetically by programme name"],
);

my $save;
# This is where all profile data/caches/cookies etc goes
my $profile_dir;
# This is where system-wide default options are specified
my $optfile_system;

# Options on unix-like systems
if ( defined $ENV{HOME} ) {
	$profile_dir = $ENV{HOME}.'/.get_iplayer';
	$optfile_system = '/etc/get_iplayer/options';

# Otherwise look for windows style file locations
} elsif ( defined $ENV{USERPROFILE} ) {
	$profile_dir = $ENV{USERPROFILE}.'/.get_iplayer';
	$optfile_system = $ENV{ALLUSERSPROFILE}.'/get_iplayer/options';
}
# Make profile dir if it doesnt exist
mkpath $profile_dir if ! -d $profile_dir;
# Personal options go here
my $optfile = "${profile_dir}/options";
# Parse options if we're not saving options (system-wide options are overridden by personal options)
if ( ! grep /\-\-save/, @ARGV ) {
	$opt->{debug} = 1 if grep /\-\-debug/, @ARGV;
	# Load options from files into $opt_file
	# system options
	$opt_file->load( $opt, $optfile_system );
	# User options
	$opt_file->load( $opt, $optfile );
	# Use .get_iplayer/options if it exists in current working dir
	$opt_file->load( $opt, './.get_iplayer/options' ) if -f './.get_iplayer/options';
	# Copy these loaded options into $opt
	$opt->copy_set_options_from( $opt_file );
}

# Parse cmdline opts from each Programme class/subclass
Options->get_class_options( $_, \%opt_format ) for qw( Streamer Programme Pvr );
Options->get_class_options( progclass($_), \%opt_format ) for progclass();
Options->get_class_options( "Streamer::$_", \%opt_format ) for qw( mms rtmp rtsp iphone mms 3gp podcast );

# Parse the cmdline using the opt_format hash
if ( not $opt_cmdline->parse( \%opt_format ) ) {
	logger Options->usage( \%opt_format, 0 );
	exit 1;
}


# deal with --save as $save and not as $opt_cmdline->{save}
if ( $opt_cmdline->{save} == 1 ) {
	$save = 1;
	delete $opt_cmdline->{save};
	delete $opt_cmdline->{help};
	delete $opt_cmdline->{helplong};
	delete $opt_cmdline->{warranty};
	delete $opt_cmdline->{conditions};
}

# Copy to $opt from opt_cmdline those options which are actually set 
$opt->copy_set_options_from( $opt_cmdline );

# Save opts to file if specified
$opt->save( $opt_cmdline, $optfile ) if $save;

# Show copyright notice
logger Options->copyright_notice;

# User Agents
my %user_agent = (
  	coremedia	=> 'Apple iPhone v1.1.1 CoreMedia v1.0.0.3A110a',
  	safari		=> 'Mozilla/5.0 (iPhone; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A110a Safari/419.3',
  	update		=> "get_iplayer updater (v${version} - $^O)",
  	desktop		=> 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9) Gecko/2008052906 Firefox/3.0',
  	get_iplayer	=> "get_iplayer/$version $^O",
);

# Display Usage
if ( $opt_cmdline->{help} || $opt_cmdline->{helplong} ) {
	logger Options->usage( \%opt_format, $opt_cmdline->{helplong} );
	exit 1;
}

# Display GPL stuff
if ( $opt_cmdline->{warranty} || $opt_cmdline->{conditions}) {
	# Get license from GNU
	logger request_url_retry( create_ua('get_iplayer'), 'http://www.gnu.org/licenses/gpl-3.0.txt'."\n", 1);
	exit 1;
}

########## Global vars ###########

# Define cache file format (maybe this is better determined from the header line of the cache file)
my @cache_format = qw/index type name pid available episode versions duration desc channel categories thumbnail timeadded guidance web/;

# Ranges of numbers used in the indicies for each programme type
my $max_index;
for ( progclass() ) {
	# Set maximum index number
	$max_index = progclass($_)->index_max if progclass($_)->index_max > $max_index;
}
my $min_download_size = 1024000;

# Static URLs
my $channel_feed_url		= 'http://feeds.bbc.co.uk/iplayer'; # /$channel/list/limit/400
my $prog_feed_url		= 'http://feeds.bbc.co.uk/iplayer/episode/'; # $pid
my $prog_iplayer_metadata	= 'http://www.bbc.co.uk/iplayer/playlist/'; # $pid
my $media_stream_data_prefix	= 'http://www.bbc.co.uk/mediaselector/4/mtis/stream/'; # $verpid
my $iphone_download_prefix	= 'http://www.bbc.co.uk/mediaselector/3/auth/iplayer_streaming_http_mp4';
my $bbc_prog_page_prefix	= 'http://www.bbc.co.uk/programmes'; # /$pid
my $itv_catchup_page_prefix	= 'http://www.itv.com/CatchUp/Video/default.html?ViewType=5&amp;Filter='; # $pid
my $thumbnail_prefix		= 'http://www.bbc.co.uk/iplayer/images/episode';
my $metadata_xml_prefix		= 'http://www.bbc.co.uk/iplayer/metafiles/episode'; # /${pid}.xml
my $metadata_mobile_prefix	= 'http://www.bbc.co.uk/iplayer/widget/episodedetail/episode'; # /${pid}/template/mobile/service_type/tv/
my $podcast_index_feed_url	= 'http://downloads.bbc.co.uk/podcasts/ppg.xml';
my $version_url			= 'http://linuxcentre.net/get_iplayer/VERSION-get_iplayer';
my $update_url			= 'http://linuxcentre.net/get_iplayer/get_iplayer'; # disabled since this is a modified version

# Setup signal handlers
$SIG{INT} = $SIG{PIPE} =\&cleanup;

# Other Non option-dependant vars
my $historyfile		= "${profile_dir}/download_history";
my $cookiejar		= "${profile_dir}/cookies";
my $namedpipe 		= "${profile_dir}/namedpipe.$$";
my $lwp_request_timeout	= 20;
my $info_limit		= 40;
my $iphone_block_size	= 0x2000000; # 32MB

# Option dependant var definitions
my $cache_secs;
my $mplayer;
my $ffmpeg;
my $ffmpeg_opts;
my $rtmpdump;
my $mplayer_opts;
my $lame;
my $lame_opts;
my $vlc;
my $vlc_opts;
my $id3v2;
my $tee;
my $bandwidth;
my @search_args = @ARGV;




########### Main processing ###########
# Assume search term is '.*' if nothing is specified - i.e. lists all programmes
push @search_args, '.*' if ! $search_args[0];

# PVR Lockfile location (keep global so that cleanup sub can unlink it)
my $lockfile;
$lockfile = $profile_dir.'/pvr_lock' if $opt->{pvr};

# Create new PVR instance
# $pvr->{searchname}->{<option>} = <value>;
my $pvr = Pvr->new();
# Set some class-wide values
$pvr->setvar('pvr_dir', "${profile_dir}/pvr/" );

# PVR functions
if ( $opt->{pvradd} ) {
	$pvr->add( $opt->{pvradd}, @search_args );

} elsif ( $opt->{pvrdel} ) {
	$pvr->del( $opt->{pvrdel} );

} elsif ( $opt->{pvrdisable} ) {
	$pvr->disable( $opt->{pvrdisable} );

} elsif ( $opt->{pvrenable} ) {
	$pvr->enable( $opt->{pvrenable} );

} elsif ( $opt->{pvrlist} ) {
	$pvr->display_list();

} elsif ( $opt->{pvrqueue} ) {
	$pvr->queue( @search_args );

} elsif ( $opt->{pvr} ) {
	# PVR Lockfile detection (with 12 hrs stale lockfile check)
	lockfile( 43200 ) if ! $opt->{test};
	$pvr->run( $opt_file );

# Download prog specified by --pid option
} elsif ( $opt->{pid} ) {
	my %pids_history = main::load_download_history() if $opt->{hide};
	find_matches( \%pids_history );

# Else just process command line args
} else {
	my %pids_history = main::load_download_history() if $opt->{hide};
	download_matches( find_matches( \%pids_history, @search_args ) );

}
exit 0;



# Use the specified options to process the matches in specified array
# Usage: find_matches( \%pids_history, @search_args )
# Returns: array of objects to be downloaded
#      or: number of failed/remaining programmes to download using the match (excluding previously downloaded progs) if --pid is specified
sub find_matches {
	my $pids_history_ref = shift;
	my @search_args = @_;
	# Show options
	$opt->display('Current options') if $opt->{verbose};
	# $prog{pid}->object hash
	my %prog;
	# obtain prog object given index. e.g. $index_prog{$index_no}->{element};
	my %index_prog;
	# hash of prog types specified
	my %type;
	logger "INFO: Search args: '".(join "','", @search_args)."'\n" if $opt->{verbose};

	# Ensure lowercase types
	$opt->{type}		= lc( $opt->{type} );
	# Expand 'all' type to comma separated list all prog types
	$opt->{type} 		= join( ',', progclass() ) if $opt->{type} =~ /(all|any)/i;
	$type{$_} = 1 for split /,/, $opt->{type};
	# Default to type=tv if no type option is set
	$type{tv}		= 1 if keys %type == 0;
	$cache_secs 		= $opt->{expiry} || 14400;
	$mplayer		= $opt->{mplayer} || 'mplayer';
	$mplayer_opts		= '-nolirc';
	$mplayer_opts		.= ' -v' if $opt->{debug};
	$mplayer_opts		.= ' -really-quiet' if $opt->{quiet};
	$ffmpeg			= $opt->{ffmpeg} || 'ffmpeg';
	$ffmpeg_opts		= '';
	$lame			= $opt->{lame} || 'lame';
	$lame_opts		= '-f';
	$lame_opts		.= ' --quiet ' if $opt->{quiet};
	$vlc			= $opt->{vlc} || 'cvlc';
	$vlc_opts		= '-vv' if $opt->{verbose} || $opt->{debug};
	$id3v2			= $opt->{id3v2} || 'id3v2';
	$tee			= 'tee';
	$rtmpdump		= $opt->{rtmpdump} || 'rtmpdump';
	$bandwidth		= $opt->{bandwidth} || 512000; # Download bandwidth bps used for rtsp streams
	# Set quiet, test and get options if we're asked for streaminfo
	if ( $opt->{streaminfo} ) {
		$opt->{test} 	= 1;
		$opt->{get} 	= 1;
		$opt->{quiet} 	= 1;
	}

	# List all options and where they are set from then exit
	if ( $opt_cmdline->{showoptions} ) {
		# Show all options andf where set from
		$opt_file->display('Options from Files');
		$opt_cmdline->display('Options from Command Line');
		$opt->display('Options Used');
		logger "Search Args: ".join(' ', @search_args)."\n\n";
	}

	# Sanity check some conflicting options
	if ($opt->{nowrite} && (!$opt->{stdout})) {
		logger "ERROR: Cannot download to nowhere\n";
		exit 1;
	}
	# Sanity check valid --type specified
	for (keys %type) {
		if ( not progclass($_) ) {
			logger "ERROR: Invalid type '$_' specified. Valid types are: ".( join ',', progclass() )."\n";
			exit 3;
		}
	}
	
	# Backward compatability options - to be removed eventually
	$opt->{vmode} = 'rtmp' if $opt->{rtmp};
	$opt->{vmode} = 'n95_wifi' if $opt->{n95};
	$opt->{amode} = 'realaudio' if $opt->{realaudio};
	$opt->{amode} = 'iphone' if $opt->{mp3audio};

	# Web proxy
	$opt->{proxy} = $ENV{HTTP_PROXY} || $ENV{http_proxy} if not $opt->{proxy};
	logger "INFO: Using Proxy $opt->{proxy}\n" if $opt->{proxy};

	# Update this script if required
	if ($opt->{update}) {
		update_script();
	}

	# Get prog by arbitrary '<type>:<pid>' or just '<pid>' (using the specified types)(then exit)
	if ( $opt->{pid} ) {
		my @try_types;
		my $pid;

		# If $opt->{pid} is in the form of '<type>:<pid>' and <type> is a valid type
		if ( $opt->{pid} =~ m{^(.+?)\:(.+?)$} && progclass(lc($1)) ) {
			my $prog_type;
			( $prog_type, $pid )= ( lc($1), $2 );
			# Only try to download using this prog type
			@try_types = ($prog_type);
			
		# $opt->{pid} is in the form of '<pid>'
		} else {
			$pid = $opt->{pid};
			@try_types = (keys %type);
		}
		logger "INFO: Will try prog types: ".(join ',', @try_types)."\n" if $opt->{verbose};
		return 0 if check_download_history( $pid );
		
		# Maybe we don't want to populate caches - this slows down --pid downloads ...
		# Populate cache with all specified prog types (strange perl bug?? - @try_types is empty after these calls if done in a $_ 'for' loop!!)
		# only get links if > 1 type is specified
		if ( $#try_types >= 1 ) {
			for my $t ( @try_types ) {
				get_links( \%prog, \%index_prog, $t );
			}
		}
		
		# Try to get pid using each speficied prog type
		my $retcode;
		for my $prog_type ( @try_types ) {
			logger "INFO Trying to download pid using type $prog_type\n";
			# Force prog type and create new prog instance if it doesn't exist
			my $this;
			if ( not $prog{$pid}->{pid} ) {
				logger "INFO: pid not found in $prog_type cache\n";
				$this = progclass($prog_type)->new( 'pid' => $pid, 'type' => $prog_type );
				# if only one type is specified then we can clean up the pid which might actually be a url
				if ( $#try_types == 0 ) {
					logger "INFO: Cleaning pid Old: '$this->{pid}', " if $opt->{verbose};
					$this->clean_pid;
					logger " New: '$this->{pid}'\n" if $opt->{verbose};
				}
				$retcode = $this->download_retry_loop( 3 );
				last if ! $retcode;
			} else {
				logger "INFO: pid found in cache\n";
				$this = $prog{$pid};
				$retcode = $this->download_retry_loop( 3 );
				last if ! $retcode;
				# If it is in the cache then we'll not need to try the other types regardless of success
				last;
			}
		}
		# return zero on success
		return $retcode;
	}

	# We don't actually need to get the links first for the specifiied type(s) if we have only index number specified (and not --list)
	my %got_cache;
	my $need_get_links = 0;
	if ( (! $opt->{list} ) ) {
		for ( @search_args ) {
			if ( (! /^[\d]+$/) || $_ > $max_index || $_ < 1 ) {
				logger "DEBUG: arg '$_' is not a programme index number - load specified caches\n" if $opt->{debug};
				$need_get_links = 1;
				last;
			}
		}
	}

	# Pre-populate caches if --list option used or there was a non-index specified
	if ( $need_get_links || $opt->{list} ) {
			### perl bug here too ???
			# Get stream links from web site or from cache (also populates all hashes) specified in --type option
			get_links( \%prog, \%index_prog, $_ ) for keys %type;
			$got_cache{$_} = 1 for keys %type;
	}
	
	# List elements (i.e. 'channel' 'categories') if required and exit
	if ( $opt->{list} ) {
		list_unique_element_counts( \%prog, \%type, $opt->{list} );
		exit 0;
	}

	# Parse remaining args
	my @match_list;
	my @index_search_args;
	for ( @search_args ) {
		chomp();

		# If Numerical value < $max_index and the object exists from loaded prog types
		if ( /^[\d]+$/ && $_ <= $max_index ) {
			if ( defined $index_prog{$_} ) {
				logger "INFO: Search term '$_' is an Index value\n" if $opt->{verbose};
				push @match_list, $index_prog{$_};
			} else {
				# Add to another list to search in other prog types
				push @index_search_args, $_;
			}

		# If PID then find matching programmes with 'pid:<pid>'
		} elsif ( m{^\s*pid:(.+?)\s*$}i ) {
			if ( defined $prog{$1} ) {
				logger "INFO: Search term '$1' is a pid\n" if $opt->{verbose};
				push @match_list, $prog{$1};
			} else {
				logger "INFO: Search term '$1' is a non-existent pid, use --pid instead and/or specify the correct programme type\n";
			}

		# Else assume this is a programme name regex
		} else {
			logger "INFO: Search term '$_' is a substring\n" if $opt->{verbose};
			push @match_list, get_regex_matches( \%prog, $_ );
		}
	}
	
	# Go get the cached data for other programme types if the index numbers require it
	for my $index ( @index_search_args ) {
		# see if this index number falls into a valid range for a prog type
		for my $prog_type ( progclass() ) {
			if ( $index >= progclass($prog_type)->index_min && $index <= progclass($prog_type)->index_max && ( ! $got_cache{$prog_type} ) ) {
				logger "DEBUG: Looking for index $index in $prog_type type\n" if $opt->{debug};
				# Get extra required programme caches
				logger "INFO: Additionally getting cached programme data for $prog_type\n" if $opt->{verbose};
				# Add new prog types to the type list
				$type{$prog_type} = 1;
				# Get $prog_type stream links
				get_links( \%prog, \%index_prog, $prog_type );
				$got_cache{$prog_type} =1;
			}
		}
		# Now check again if the index number exists in the cache before adding this prog to the match list
		if ( defined $index_prog{$index}->{pid} ) {
			push @match_list, $index_prog{$index} if defined $index_prog{$index}->{pid};
		} else {
			logger "WARNING: Unmatched programme index '$index' specified - ignoring\n";
		}
	}

	# De-dup matches and retain order (don't ask!)
	my %seen = ();
	my @unique = grep { ! $seen{ $_ }++ } @match_list;
	@match_list = @unique;

	# Prune out pids already downloaded if opt{hide} is specified
	if ( $opt->{hide} ) {
		my @pruned;
		for my $this (@match_list) {
			# If the prog object exists with pid in history delete it from the prog list
			if ( $pids_history_ref->{ $this->{pid} } ) {
				logger "DEBUG: Ignoring Prog: '$this->{index}: $this->{name} - $this->{episode}'\n" if $opt->{debug};
			} else {
				push @pruned, $this;
			}
		}
		@match_list = @pruned;
	}
		
	# Display list for download
	list_progs( \%type, @match_list );

	# Write HTML and XML files if required (with search options applied)
	create_html( @match_list ) if $opt->{html};
	create_xml( $opt->{fxd}, @match_list ) if $opt->{fxd};
	create_xml( $opt->{mythtv}, @match_list ) if $opt->{mythtv};

	return @match_list;
}



sub download_matches {
	my @match_list = @_;

	# Do the downloads based on list of index numbers if required
	my $failcount;
	if ( $opt->{get} || $opt->{stdout} ) {
		for my $this (@match_list) {
			$failcount =+ $this->download_retry_loop( 3 );
		}
	}

	return $failcount;
}



# Usage: list_progs( \%type, @prog_refs )
# Lists progs given an array of index numbers
sub list_progs {
	my $typeref = shift;
	my $number_of_types = keys %{$typeref};
	my $ua = create_ua('desktop');
	my %names;

	# Setup user agent for a persistent connection to get programme metadata
	if ( $opt->{info} ) {
		# Truncate array if were lisiting info and > $info_limit entries are requested - be nice to the beeb!
		if ( $#_ >= $info_limit ) {
			$#_ = $info_limit - 1;
			logger "WARNING: Only processing the first $info_limit matches\n";
		}
	}

	logger "Matches:\n" if $#_ >= 0;
	for my $this (@_) {
		if (! defined $names{ $this->{name} }) {
			$this->list_entry( '', 0, $number_of_types );
		} else {
			$this->list_entry( '', 1, $number_of_types );
		}
		$names{ $this->{name} } = 1;
		if ( $opt->{info} ) {
			my %metadata = $this->get_metadata( $ua );
			display_metadata( \%metadata, qw/ pid index type duration channel available expiry versions guidance categories desc player / );
		}
	}
	logger "\n";

	logger "INFO: ".($#_ + 1)." Matching Programmes\n";
}



# Returns matching programme objects using supplied regex
# Usage: get_regex_matches ( \%prog, $regex )
sub get_regex_matches {
	my $progref = shift;
	my $download_regex = shift;

	my %download_hash;
	my $channel_regex = $opt->{channel} || '.*';
	my $category_regex = $opt->{category} || '.*';
	my $versions_regex = $opt->{versions} || '.*';
	my $exclude_regex = $opt->{exclude} || '^ROGUE$';
	my $channel_exclude_regex = $opt->{excludechannel} || '^ROGUE$';
	my $category_exclude_regex = $opt->{excludecategory} || '^ROGUE$';
	my $since = $opt->{since} || 99999;
	my $now = time();
	
	# Determine search for fields
	my @searchfields;
	@searchfields = split /\s*,\s*/, lc( $opt->{fields} ) if $opt->{fields};

	# Loop through each prog object
	for my $this ( values %{$progref} ) {
		# Only include programmes matching channels and category regexes
		if ( $this->{channel} =~ /$channel_regex/i
		  && $this->{categories} =~ /$category_regex/i
		  && $this->{versions} =~ /$versions_regex/i
		  && $this->{channel} !~ /$channel_exclude_regex/i
		  && $this->{name} !~ /$exclude_regex/i
		  && $this->{categories} !~ /$category_exclude_regex/i
		  && $this->{timeadded} >= $now - ($since * 3600)
		) {
			# Custom search fields
			if ( @searchfields ) {
				for my $field ( @searchfields ) {
					$download_hash{ $this->{index} } = $this if $this->{$field} =~ /$download_regex/i;
				}
			# Normal name / long search
			} else {
				# Search prognames/pids while excluding channel_regex and category_regex
				$download_hash{ $this->{index} } = $this if $this->{name} =~ /$download_regex/i;
				# Also search long descriptions and episode data if -l is specified
				$download_hash{ $this->{index} } = $this if $opt->{long} && ( $this->{desc} =~ /$download_regex/i || $this->{episode} =~ /$download_regex/i );
			}
		}
	}

	my @match_list;
	# Add all matching prog objects to array
	for my $this ( sort {$a <=> $b} keys %download_hash ) {
		push @match_list, $download_hash{ $this };
	}

	return @match_list;
}



# Usage: sort_index( \%prog, \%index_prog, $prog_type )
# Populates the index field of the prog hash as well as creating the %index_prog hash
# Should be run after any number of get_links methods
sub sort_index {
	my $progref = shift;
	my $index_progref = shift;
	my $prog_type = shift;

	# Add index field based on alphabetical sorting by prog name
	# Start index counter at 'min' for this prog type
	my $counter = progclass($prog_type)->index_min;

	my @prog_pid;

	# Create unique array of '<progname|pid>' for this prog type
	for ( keys %{$progref} ) {
		# skip prog not of correct type
		next if $progref->{$_}->{type} ne $prog_type;
		push @prog_pid, "$progref->{$_}->{name}|$_";
	}
	# Sort by progname and index 
	for (sort @prog_pid) {

		# Extract pid
		my $pid = (split /\|/)[1];

		# Insert prog instance var of the index number
		$progref->{$pid}->{index} = $counter;

		# Add the object reference into %index_prog hash
		$index_progref->{ $counter } = $progref->{$pid};

		# Increment the index counter for this prog type
		$counter++;
	}
	return 0;
}



# Returns classname for prog type or if not specified, an array of all prog types
sub progclass {
	my $prog_type = shift;
	if ( $prog_type ) {
		return $prog_types{$prog_type};
	} else {
		return keys %prog_types;
	}
}



# Feed info:
#	# Also see http://derivadow.com/2008/07/18/interesting-bbc-data-to-hack-with/
#	# All podcasts menu (iphone)
#	http://www.bbc.co.uk/radio/podcasts/ip/
#	# All radio1 podcasts
#	http://www.bbc.co.uk/radio/podcasts/ip/lists/radio1.sssi
#	# All radio1 -> moyles podcasts
#	http://www.bbc.co.uk/radio/podcasts/moyles/assets/iphone_keepnet.sssi
#	# RSS Feed (indexed from?)
#	http://downloads.bbc.co.uk/podcasts/radio1/moyles/rss.xml
#	# aod by channel see http://docs.google.com/View?docid=d9sxx7p_38cfsmxfcq
#	# http://www.bbc.co.uk/radio/aod/availability/<channel>.xml
#	# aod index
#	http://www.bbc.co.uk/radio/aod/index_noframes.shtml
# 	# schedule feeds
#	http://www.bbc.co.uk/bbcthree/programmes/schedules.xml
#	# These need drill-down to get episodes:
#	# TV schedules by date
#	http://www.bbc.co.uk/iplayer/widget/schedule/service/cbeebies/date/20080704
#	# TV schedules in JSON, Yaml or XML
#	http://www.bbc.co.uk/cbbc/programmes/schedules.(json|yaml|xml)
#	# TV index on programmes tv
#	http://www.bbc.co.uk/tv/programmes/a-z/by/*/player
#	# TV + Radio
#	http://www.bbc.co.uk/programmes/a-z/by/*/player
#	# All TV (limit has effect of limiting to 2.? times number entries kB??)
#	# seems that only around 50% of progs are available here compared to programmes site:
#	http://feeds.bbc.co.uk/iplayer/categories/tv/list/limit/200
#	# All Radio
#	http://feeds.bbc.co.uk/iplayer/categories/radio/list/limit/999
#	# New:
#	# iCal feeds see: http://www.bbc.co.uk/blogs/radiolabs/2008/07/some_ical_views_onto_programme.shtml
#	http://bbc.co.uk/programmes/b0079cmw/episodes/player.ics
#	# Other data
#	http://www.bbc.co.uk/cbbc/programmes/genres/childrens/player
#	http://www.bbc.co.uk/programmes/genres/childrens/schedules/upcoming.ics
#
# Usage: get_links( \%prog, \%index_prog, <prog_type> )
sub get_links {
	my $progref = shift;
	my $index_progref = shift;
	my $prog_type = shift;

	my $now = time();
	my $cachefile = "${profile_dir}/${prog_type}.cache";

	# Read cache into %pid_old and %index_prog_old if cache exists
	my %prog_old;
	my %index_prog_old;

	# Open cache file (need to verify we can even read this)
	if ( -f $cachefile && open(CACHE, "< $cachefile") ) {
		my @cache_format_old = @cache_format;
		# Get file format and contents less any comments
		while (<CACHE>) {
			chomp();
			# Get cache format if specified
			if ( /^[\#](.+?\|){3,}/ ) {
				@cache_format_old = split /[\#\|]/;
				shift @cache_format_old;
				logger "INFO: Cache format from existing $prog_type cache file: ".(join ',', @cache_format_old)."\n" if $opt->{debug};
				next;
			}
			# Ignore comments
			next if /^[\#\s]/;
			# Populate %prog_old from cache
			# Get cache line
			my @record = split /\|/;
			my %record_entries;
			# Update fields in %prog hash for $pid
			$record_entries{$_} = shift @record for @cache_format_old;
			$prog_old{ $record_entries{pid} } = \%record_entries;
			$index_prog_old{ $record_entries{index} }  = $record_entries{pid};
		}
		close (CACHE);
		logger "INFO: got ".(keys %prog_old)." cache entries for $prog_type\n" if $opt->{verbose};
	} else {
		logger "INFO: No cache file exists for $prog_type\n" if $opt->{verbose};
	}

	# if a cache file doesn't exist/corrupted/empty, flush option is specified or original file is older than $cache_sec then download new data
	if ( (! keys %prog_old) || (! -f $cachefile) || $opt->{flush} || ($now >= ( stat($cachefile)->mtime + $cache_secs )) ) {

		# Get links for specific type of programme class
		progclass( $prog_type )->get_links( $progref, $prog_type );

		# Sort index for this prog type
		sort_index( $progref, $index_progref, $prog_type );
		
		# Open cache file for writing
		unlink $cachefile;
		my $now = time();
		if ( open(CACHE, "> $cachefile") ) {
			print CACHE "#".(join '|', @cache_format)."\n";
			for (sort {$a <=> $b} keys %{$index_progref}) {
				# prog object
				my $this = $index_progref->{$_};
				# Only write entries for correct prog type
				if ($this->{type} eq $prog_type) {
					# Merge old and new data to retain timestamps
					# if the entry was in old cache then retain timestamp from old entry
					if ( $prog_old{ $this->{pid} }{timeadded} ) {
						$this->{timeadded} = $prog_old{ $this->{pid} }{timeadded};
					# Else this is a new entry
					} else {
						$this->{timeadded} = $now;
						$this->list_entry( 'Added: ' );
					}
					# Write each field into cache line
					print CACHE $this->{$_}.'|' for @cache_format;
					print CACHE "\n";
				}
			}
			close (CACHE);
		} else {
			logger "WARNING: Couldn't open cache file '$cachefile' for writing\n";
		}


	# Else copy data from existing cache file into new prog instances
	} else {
		for my $pid ( keys %prog_old ) {

			# Create new prog instance
			$progref->{$pid} = progclass( lc($prog_old{$pid}{type}) )->new( 'pid' => $pid );

			for (@cache_format) {
				$progref->{$pid}->{$_} = $prog_old{$pid}{$_};
			}
		}
		# Add prog objects to %index_prog hash
		$index_progref->{$_} = $progref->{ $index_prog_old{$_} } for keys %index_prog_old;
	}
	
	return 0;
}



# Generic
# Returns an offset timestamp given an srt begin or end timestamp and offset in ms
sub subtitle_offset {
	my ( $timestamp, $offset ) = @_;
	my ( $hr, $min, $sec, $ms ) = split /[:,\.]/, $timestamp;
	# split into hrs, mins, secs, ms
	my $ts = $ms + $sec*1000 + $min*60*1000 + $hr*60*60*1000 + $offset;
	$hr = int( $ts/(60*60*1000) );
	$ts -= $hr*60*60*1000;
	$min = int( $ts/(60*1000) );
	$ts -= $min*60*1000;
	$sec = int( $ts/1000 );
	$ts -= $sec*1000;
	$ms = $ts;
	return "$hr:$min:$sec,$ms";
}



# Generic
sub display_stream_info {
	my ($prog, $verpid, $media) = (@_);
	logger "INFO: Getting media stream metadata for $prog->{name} - $prog->{episode}, $verpid\n" if $prog->{pid};
	my %data = $prog->get_stream_data( $verpid, $media);
	# Print out stream data
	for my $prog_type (sort keys %data) {
		logger "stream:     $prog_type\n";
		for my $entry ( sort keys %{ $data{$prog_type} } ) {
			logger sprintf("%-11s %s\n", $entry.':', $data{$prog_type}{$entry} );
		}
		logger "\n";
	}
	return 0;
}



# Generic
# Displays specified metadata from supplied hash
# Usage: display_metadata( <hashref>, <array of elements to display> )
sub display_metadata {
	my %data = %{$_[0]};
	shift;
	my @keys = @_;
	@keys = keys %data if $#_ < 0;
	logger "\n";
	for (@keys) {
		logger sprintf "%-15s %s\n", ucfirst($_).':', $data{$_} if $data{$_};
	}
	logger "\n";
	return 0;
}



# Generic
# Usage download_block($file, $url_2, $ua, $start, $end, $file_len, $fh);
#  ensure filehandle $fh is open in append mode
# or, $content = download_block(undef, $url_2, $ua, $start, $end, $file_len);
# Called in 4 ways:
# 1) write to real file			=> download_block($file, $url_2, $ua, $start, $end, $file_len, $fh);
# 2) write to real file + STDOUT	=> download_block($file, $url_2, $ua, $start, $end, $file_len, $fh); + $opt->{stdout}==true
# 3) write to STDOUT only		=> download_block($file, $url_2, $ua, $start, $end, $file_len, $fh); + $opt->{stdout}==true + $opt->{nowrite}==false
# 4) write to memory (and return data)  => download_block(undef, $url_2, $ua, $start, $end, $file_len, undef);
# 4) write to memory (and return data)  => download_block(undef, $url_2, $ua, $start, $end);
sub download_block {

	my ($file, $url, $ua, $start, $end, $file_len, $fh) = @_;
	my $orig_length;
	my $buffer;
	my $lastpercent = 0;
	my $now = time();

	# If this is an 'append to file' mode call
	if ( defined $file && $fh && (!$opt->{nowrite}) ) {
		# Stage 3b: Download File
		$orig_length = tell $fh;
		logger "INFO: Appending to $file\n" if $opt->{verbose};
	}

	# Setup request headers
	my $h = new HTTP::Headers(
		'User-Agent'	=> $user_agent{coremedia},
		'Accept'	=> '*/*',
		'Range'        => "bytes=${start}-${end}",
	);

	my $req = HTTP::Request->new ('GET', $url, $h);

	# Set time to use for download rate calculation
	# Define callback sub that gets called during download request
	# This sub actually writes to the open output file and reports on progress
	my $callback = sub {
		my ($data, $res, undef) = @_;
		# Don't write the output to the file if there is no content-length header
		return 0 if ( ! $res->header("Content-Length") );
		# If we don't know file length in advanced then set to size reported reported from server upon download
		$file_len = $res->header("Content-Length") + $start if ! defined $file_len;
		# Write output
		print $fh $data if ! $opt->{nowrite};
		print STDOUT $data if $opt->{stdout};
		# return if streaming to stdout - no need for progress
		return if $opt->{stdout} && $opt->{nowrite};
		return if $opt->{quiet};
		# current file size
		my $size = tell $fh;
		# Download percent
		my $percent = 100.0 * $size / $file_len;
		# Don't update display if we haven't dowloaded at least another 0.1%
		return if ($percent - $lastpercent) < 0.1;
		$lastpercent = $percent;
		# download rates in bytes per second and time remaining
		my $rate_bps;
		my $rate;
		my $time;
		my $timecalled = time();
		if ($timecalled - $now < 1) {
			$rate = '-----kbps';
			$time = '--:--:--';
		} else {
			$rate_bps = ($size - $orig_length) / ($timecalled - $now);
			$rate = sprintf("%5.0fkbps", (8.0 / 1024.0) * $rate_bps);
			$time = sprintf("%02d:%02d:%02d", ( gmtime( ($file_len - $size) / $rate_bps ) )[2,1,0] );
		}
		logger sprintf "%8.2fMB / %.2fMB %s %5.1f%%, %s remaining         \r", 
			$size / 1024.0 / 1024.0, 
			$file_len / 1024.0 / 1024.0,
			$rate,
			$percent,
			$time,
		;
	};

	my $callback_memory = sub {
		my ($data, $res, undef) = @_;
		# append output to buffer
		$buffer .= $data;
		return if $opt->{quiet};
		# current buffer size
		my $size = length($buffer);
		# download rates in bytes per second
		my $timecalled = time();
		my $rate_bps;
		my $rate;
		my $time;
		my $percent;
		# If we can get Content_length then display full progress
		if ($res->header("Content-Length")) {
			$file_len = $res->header("Content-Length") if ! defined $file_len;
			# Download percent
			$percent = 100.0 * $size / $file_len;
			return if ($percent - $lastpercent) < 0.1;
			$lastpercent = $percent;
			# Block length
			$file_len = $res->header("Content-Length");
			if ($timecalled - $now < 0.1) {
				$rate = '-----kbps';
				$time = '--:--:--';
			} else {
				$rate_bps = $size / ($timecalled - $now);
				$rate = sprintf("%5.0fkbps", (8.0 / 1024.0) * $rate_bps );
				$time = sprintf("%02d:%02d:%02d", ( gmtime( ($file_len - $size) / $rate_bps ) )[2,1,0] );
			}
			# time remaining
			logger sprintf "%8.2fMB / %.2fMB %s %5.1f%%, %s remaining         \r", 
				$size / 1024.0 / 1024.0,
				$file_len / 1024.0 / 1024.0,
				$rate,
				$percent,
				$time,
			;
		# Just used simple for if we cannot determine content length
		} else {
			if ($timecalled - $now < 0.1) {
				$rate = '-----kbps';
			} else {
				$rate = sprintf("%5.0fkbps", (8.0 / 1024.0) * $size / ($timecalled - $now) );
			}
			logger sprintf "%8.2fMB %s         \r", $size / 1024.0 / 1024.0, $rate;
		}
	};

	# send request
	logger "\nINFO: Downloading range ${start}-${end}\n" if $opt->{verbose};
	logger "\r                              \r";
	my $res;

	# If $fh undefined then get block to memory (fh always defined for stdout or file d/load)
	if (defined $fh) {
		logger "DEBUG: writing stream to stdout, Range: $start - $end of $url\n" if $opt->{verbose} && $opt->{stdout};
		logger "DEBUG: writing stream to $file, Range: $start - $end of $url\n" if $opt->{verbose} && !$opt->{nowrite};
		$res = $ua->request($req, $callback);
		if (  (! $res->is_success) || (! $res->header("Content-Length")) ) {
			logger "ERROR: Failed to Download block\n\n";
			return 5;
		}
                logger "INFO: Content-Length = ".$res->header("Content-Length")."                               \n" if $opt->{verbose};
		return 0;
		   
	# Memory Block
	} else {
		logger "DEBUG: writing stream to memory, Range: $start - $end of $url\n" if $opt->{debug};
		$res = $ua->request($req, $callback_memory);
		if ( (! $res->is_success) ) {
			logger "ERROR: Failed to Download block\n\n";
			return '';
		} else {
			return $buffer;
		}
	}
}



# Generic
sub create_ua {
	my $agent = shift;
	my $ua = LWP::UserAgent->new;
	$ua->timeout([$lwp_request_timeout]);
	$ua->proxy( ['http'] => $opt->{proxy} );
	$ua->agent( $user_agent{$agent} );
	$ua->conn_cache(LWP::ConnCache->new());
	#$ua->conn_cache->total_capacity(50);
	$ua->cookie_jar( HTTP::Cookies->new( file => $cookiejar, autosave => 1, ignore_discard => 1 ) );
	return $ua;
};	



# Generic
# Converts a string of chars to it's HEX representation
sub get_hex {
        my $buf = shift || '';
        my $ret = '';
        for (my $i=0; $i<length($buf); $i++) {
                $ret .= " ".sprintf("%02lx", ord substr($buf, $i, 1) );
        }
	logger "DEBUG: HEX string value = $ret\n" if $opt->{verbose};
        return $ret;
}



# Generic
# version of unix tee
# Usage tee ($infile, $outfile)
# If $outfile is undef then just cat file to STDOUT
sub tee {
	my ( $infile, $outfile ) = @_;
	# Open $outfile for writing, $infile for reading
	if ( $outfile) {
		if ( ! open( OUT, "> $outfile" ) ) {
			logger "ERROR: Could not open $outfile for writing\n";
			return 1;
		} else {
			logger "INFO: Opened $outfile for writing\n" if $opt->{verbose};
		}
	}
	if ( ! open( IN, "< $infile" ) ) {
		logger "ERROR: Could not open $infile for reading\n";
		return 2;
	} else {
		logger "INFO: Opened $infile for reading\n" if $opt->{verbose};
	}
	# Read and redirect IN
	while ( <IN> ) {
		print $_;
		print OUT $_ if $outfile;
	}
	# Close output file
	close OUT if $outfile;
	close IN;
	return 0;
}



# Generic
# Usage: $fh = open_file_append($filename);
sub open_file_append {
	local *FH;
	my $file = shift;
	# Just in case we actually write to the file - make this /dev/null
	$file = '/dev/null' if $opt->{nowrite};
	if ($file) {
		if ( ! open(FH, ">> $file") ) {
			logger "ERROR: Cannot write or append to $file\n\n";
			exit 1;
		}
	}
	# Fix for binary - needed for Windows
	binmode FH;
	return *FH;
}



# Generic
# Updates and overwrites this script - makes backup as <this file>.old
sub update_script {
	# Get version URL
	my $script_file = $0;
	my $ua = create_ua('update');
	logger "INFO: Current version is $version\n";
	logger "INFO: Checking for latest version from linuxcentre.net\n";
	my $res = $ua->request( HTTP::Request->new( GET => $version_url ) );
	chomp( my $latest_ver = $res->content );
	if ( $res->is_success ) {
		# Compare version numbers
		if ( $latest_ver > $version ) {
			logger "INFO: New version $latest_ver available, downloading\n";
			# Check if we are writable
			if ( ! -w $script_file ) {
				logger "ERROR: $script_file is not writable by the current user - Update aborted\n";
				exit 1;
			}
			my $req = HTTP::Request->new ('GET', $update_url);
			# Save content into a $script_file
			my $res = $ua->request($req, $script_file.'.tmp');
			if ( ! -f $script_file.'.tmp' ) {
				logger "ERROR: Could not download update to ${script_file}.tmp - Update aborted\n";
				exit 1;
			}
			# If the download was successful then copy over this script and make executable after making a backup of this script
			if ( $res->is_success ) {
				if ( copy($script_file, $script_file.'.old') ) {
					move($script_file.'.tmp', $script_file);
					chmod 0755, $script_file;
					logger "INFO: Copied new version $latest_ver into place (previous version is now called '${script_file}.old')\n";
					logger "INFO: Please see: http://linuxcentre.net/get_iplayer/CHANGELOG.txt\n";
				} else {
					logger "ERROR: Could not create backup file ${script_file}.old - Update aborted\n";
					exit 1;
				}
			}
		} else {
			logger "INFO: No update is necessary (latest version = $latest_ver)\n";
		}
	} else {
		logger "ERROR: Failed to connect to update site - Update aborted\n";
		exit 2;
	}
	exit 0;
}



# Usage: create_xml( @prog_objects )
# Creates the Freevo FXD or MythTV Streams meta data (and pre-downloads graphics - todo)
sub create_xml {
	my $xmlfile = shift;

	if ( ! open(XML, "> $xmlfile") ) {
		logger "ERROR: Couldn't open xml file $xmlfile for writing\n";
		return 1;
	}
	print XML '<?xml version="1.0" ?>';
	print XML '<freevo>' if $opt->{fxd};
	print XML "\n<MediaStreams>\n" if $opt->{mythtv};

	if ( $opt->{xmlnames} ) {
		# containers sorted by prog names
		print XML "\t<container title=\"iplayer by Programme Name\">\n" if $opt->{fxd};
		my %program_index;
		my %program_count;
		# create hash of programme_name -> index
	        for my $this (@_) {
	        	$program_index{ $this->{name} } = $_;
			$program_count{ $this->{name} }++;
		}
		for my $name ( sort keys %program_index ) {
			my @count = grep /^$name$/, keys %program_index;
			print XML "\t<container title=\"".encode_entities( $name )." ($program_count{$name})\">\n" if $opt->{fxd};
			print XML "\t<Streams>\n" if $opt->{mythtv};
			for my $this (@_) {
				my $pid = $this->{pid};
				# loop through and find matches for each progname
				if ( $this->{name} =~ /^$name$/ ) {
					my $episode = encode_entities( $this->{episode} );
					my $desc = encode_entities( $this->{desc} );
					my $title = "${episode} ($this->{available})";
					print XML "<movie title=\"${title}\">
						<video><url id=\"p1\">${pid}.mov<playlist/></url></video>
						<info><description>${desc}</description></info>
					</movie>\n" if $opt->{fxd};
					print XML "<Stream>
						<Name>\"${title}\"</Name>
						<url>${pid}.mov</url>
						<Subtitle></Subtitle>
						<Synopsis>${desc}</Synopsis>
						<StreamImage>$this->{thumbnail}</StreamImage>
					</Stream>\n" if $opt->{mythtv};
				}
			}			
			print XML "\t</container>\n" if $opt->{fxd};
			print XML "\t</Streams>\n" if $opt->{mythtv};
		}
		print XML "\t</container>\n" if $opt->{fxd};
	}


	if ( $opt->{xmlchannels} ) {
		# containers for prog names sorted by channel
		print XML "\t<container title=\"iplayer by Channel\">\n" if $opt->{fxd};
		my %program_index;
		my %program_count;
		my %channels;
		# create hash of unique channel names and hash of programme_name -> index
	        for my $this (@_) {
	        	$program_index{ $this->{name} } = $_;
			$program_count{ $this->{name} }++;
			$channels{ $this->{channel} } .= '|'.$this->{name}.'|';
		}
		for my $channel ( sort keys %channels ) {
			print XML "\t<container title=\"".encode_entities( $channel )."\">\n" if $opt->{fxd};
			print XML "\t<Feed>
				\t<Name>".encode_entities( $channel )."</Name>
				\t<Provider>BBC</Provider>\n
				\t<Streams>\n" if $opt->{mythtv};
			for my $name ( sort keys %program_index ) {
				# Do we have any of this prog $name on this $channel?
				if ( $channels{$channel} =~ /\|$name\|/ ) {
					my @count = grep /^$name$/, keys %program_index;
					print XML "\t<container title=\"".encode_entities( $name )." ($program_count{$name})\">\n" if $opt->{fxd};
					#print XML "\t\t<Stream>\n" if $opt->{mythtv};
					for my $this (@_) {
						# loop through and find matches for each progname for this channel
						my $pid = $this->{pid};
						if ( $this->{channel} =~ /^$channel$/ && $this->{name} =~ /^$name$/ ) {
							my $episode = encode_entities( $this->{episode} );
							my $desc = encode_entities( $this->{desc} );
							my $title = "${episode} ($this->{available})";
							print XML "<movie title=\"${title}\">
								<video><url id=\"p1\">${pid}.mov<playlist/></url></video>
								<info><description>${desc}</description></info>
							</movie>\n" if $opt->{fxd};
							print XML "\t\t<Stream>\n" if $opt->{mythtv};
							print XML "\t\t<Name>".encode_entities( $name )."</Name>\n\t\t<Url>${pid}.mov</Url>\n\t\t<StreamImage>$this->{thumbnail}</StreamImage>\n\t\t<Subtitle>${episode}</Subtitle>\n\t\t<Synopsis>${desc}</Synopsis>\n" if $opt->{mythtv};
							print XML "\t</Stream>\n" if $opt->{mythtv};
						}
					}
					print XML "\t</container>\n" if $opt->{fxd};
					#print XML "\t</Stream>\n" if $opt->{mythtv};
				}
			}
			print XML "\t</container>\n" if $opt->{fxd};
			print XML "\t</Streams>\n\t</Feed>\n" if $opt->{mythtv};
		}
		print XML "\t</container>\n" if $opt->{fxd};
	}


	if ( $opt->{xmlalpha} ) {
		my %table = (
			'A-C' => '[abc]',
			'D-F' => '[def]',
			'G-I' => '[ghi]',
			'J-L' => '[jkl]',
			'M-N' => '[mn]',
			'O-P' => '[op]',
			'Q-R' => '[qt]',
			'S-T' => '[st]',
			'U-V' => '[uv]',
			'W-Z' => '[wxyz]',
			'0-9' => '[\d]',
		);
		print XML "\t<container title=\"iplayer A-Z\">\n";
		for my $folder (sort keys %table) {
			print XML "\t<container title=\"iplayer $folder\">\n";
			for my $this (@_) {
				my $pid = $this->{pid};
				my $name = encode_entities( $this->{name} );
				my $episode = encode_entities( $this->{episode} );
				my $desc = encode_entities( $this->{desc} );
				my $title = "${name} - ${episode} ($this->{available})";
				my $regex = $table{$folder};
				if ( $name =~ /^$regex/i ) {
					print XML "<movie title=\"${title}\">
						<video><url id=\"p1\">${pid}.mov<playlist/></url></video>
						<info><description>${desc}</description></info>
					</movie>\n" if $opt->{fxd};
					print XML "<Stream title=\"${title}\">
						<video><url id=\"p1\">${pid}.mov<playlist/></url></video>
						<info><description>${desc}</description></info>
						<StreamImage>$this->{thumbnail}</StreamImage>
					</Stream>\n" if $opt->{mythtv};
				}
			}
			print XML "\t</container>\n";
		}
		print XML "\t</container>\n";
	}

	print XML '</freevo>' if $opt->{fxd};
	print XML '</MediaStreams>' if $opt->{mythtv};
	close XML;
}



# Usage: create_html( @prog_objects )
sub create_html {
	my %name_channel;
	# Create local web page
	if ( open(HTML, "> $opt->{html}") ) {
		print HTML '<html><head></head><body><table border=1>';
		for my $this (@_) {
			# Skip if pid isn't in index
			my $pid = $this->{pid} || next;
			# Skip if already downloaded and --hide option is specified
			if (! defined $name_channel{ "$this->{name}|$this->{channel}" }) {
				print HTML $this->list_entry_html();
			} else {
				print HTML $this->list_entry_html( 1 );
			}
			$name_channel{ "$this->{name}|$this->{channel}" } = 1;
		}
		print HTML '</table></body>';
		close (HTML);
	} else {
		logger "Couldn't open html file $opt->{html} for writing\n";
	}
}



# Generic
# Gets the contents of a URL and retries if it fails, returns '' if no page could be retrieved
# Usage <content> = request_url_retry(<ua>, <url>, <retries>, <succeed message>, [<fail message>]);
sub request_url_retry {
	my ($ua, $url, $retries, $succeedmsg, $failmsg) = @_; 
	my $res;

	# Malformed URL check
	if ( $url !~ m{^\s*http\:\/\/}i ) {
		logger "ERROR: Malformed URL: '$url'\n";
		return '';
	}

	my $i;
	logger "INFO: Getting page $url\n" if $opt->{verbose};
	for ($i = 0; $i < $retries; $i++) {
		$res = $ua->request( HTTP::Request->new( GET => $url ) );
		if ( ! $res->is_success ) {
			logger $failmsg;
		} else {
			logger $succeedmsg;
			last;
		}
	}
	# Return empty string if we failed
	return '' if $i == $retries;
	# otherwise return content
	return $res->content;
}



# Generic
# Checks if a particular program exists (or program.exe) in the $ENV{PATH} or if it has a path already check for existence of file
sub exists_in_path {
	my $file = shift;
	# If this has a path specified, does file exist
	return 1 if $file =~ /[\/\\]/ && (-f $file || -f "${file}.exe");
	# Search PATH
	for (@PATH) {
		return 1 if -f "${_}/${file}" || -f "${_}/${file}.exe";
	}
	return 0;
}



# Generic
# Adds prog to history file (with a timestamp) so that it is not redownloaded after deletion
sub add_to_download_history {
	my $prog = shift;
	# Only add if a pid is specified
	return 0 if ! $prog->{pid};
	# Don't add to history if stdout streaming is used
	return 0 if ( $opt->{stdout} && $opt->{nowrite} ) || $opt->{streaminfo};

	# Add to history
	if ( ! open(HIST, ">> $historyfile") ) {
		logger "WARNING: Cannot write or append to $historyfile\n\n";
		return 1;
	}
	print HIST "$prog->{pid}|$prog->{name}|$prog->{episode}|$prog->{type}|".time()."|$prog->{mode}\n";
	close HIST;
	return 0;
}



# Generic
# returns a hash (<pid> => <data>) for all the pids in the history file
sub load_download_history {
	my %pids_downloaded;

	# Return if force-download option specified or stdout streaming only
	return %pids_downloaded if $opt->{forcedownload} || $opt->{stdout} || $opt->{nowrite};

	logger "INFO: Loading download history\n" if $opt->{verbose};
	if ( ! open(HIST, "< $historyfile") ) {
		logger "WARNING: Cannot read $historyfile\n\n";
		return 0;
	}
	while ( <HIST> ) {
		$pids_downloaded{$1} = $2 if m{^(.+?)\|(.*)$};
		logger "DEBUG: Loaded '$1' = '$2' from download history\n" if $opt->{debug};
	}
	return %pids_downloaded;
}



# Generic
# Checks history for previous download of this pid
sub check_download_history {
	my $pid = shift;
	my ($matchedpid, $name, $episode);
	return 0 if ! $pid;
		
	# Return if force-download option specified or stdout streaming only
	return 0 if $opt->{forcedownload} || $opt->{stdout} || $opt->{nowrite};
	
	if ( ! open(HIST, "< $historyfile") ) {
		logger "WARNING: Cannot read $historyfile\n\n";
		return 0;
	}

	# Find and parse first matching line
	($matchedpid, $name, $episode) = ( split /\|/, (grep /^$pid/, <HIST>)[0] )[0,1,2];
	if ( $matchedpid ) {
		chomp $name;
		chomp $episode;
		logger "INFO: $name - $episode ($pid) Already in download history ($historyfile) - use --force to override\n";
		close HIST;
		return 1;

	} else {
		logger "INFO: Programme not in download history\n" if $opt->{verbose};
		close HIST;
		return 0;
	}
}




# list_unique_element_counts( \%prog, \%type, $element_name );
# Show channels for currently specified types
sub list_unique_element_counts {
	my $progref = shift;
	my $typeref = shift;
	my $element_name = shift;
	my %elements;
	logger "INFO: ".(join ',', keys %{ $typeref })." $element_name List:\n" if $opt->{verbose};
	for my $pid ( keys %{ $progref } ) {
		my @element;
		# Need to separate the categories
		if ($element_name eq 'categories') {
			@element = split /,/, $progref->{$pid}->{$element_name};
		} else {
			@element[0] = $progref->{$pid}->{$element_name};
		}
		for my $element (@element) {
			$elements{ $element }++;
		}
	}
	# display element + prog count
	logger "$_ ($elements{$_})\n" for sort keys %elements;
	return 0;
}



# Generic
# Escape chars in string for shell use
sub StringUtils::esc_chars {
	# will change, for example, a!!a to a\!\!a
	s/([;<>\*\|&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
	return $_;
}



# Generic
# Signal handler to clean up after a ctrl-c or kill
sub cleanup {
	logger "INFO: Cleaning up\n" if $opt->{verbose};
	unlink $namedpipe;
	unlink $lockfile;
	exit 1;
}



# Generic
# Make a filename/path sane (optionally allow fwd slashes)
sub StringUtils::sanitize_path {
	my $string = shift;
	my $allow_fwd_slash = shift || 0;

	# Remove fwd slash if reqd
	$string =~ s/\//_/g if ! $allow_fwd_slash;

	# Replace backslashes with _ regardless
	$string =~ s/\\/_/g;
	# Sanitize by default
	$string =~ s/\s/_/g if (! $opt->{whitespace}) && (! $allow_fwd_slash);
	$string =~ s/[^\w_\-\.\/\s]//gi if ! $opt->{whitespace};
	return $string;
}


# Uses: global $lockfile
# Lock file detection (<stale_secs>)
# Global $lockfile
sub lockfile {
	my $stale_time = shift || 86400;
	my $now = time();
	# if lockfile exists then quit as we are already running
	if ( -T $lockfile ) {
		if ( ! open (LOCKFILE, $lockfile) ) {
			main::logger "ERROR: Cannot read lockfile '$lockfile'\n";
			exit 1;
		}
		my @lines = <LOCKFILE>;
		close LOCKFILE;

		# If the process is still running and the lockfile is newer than $stale_time seconds
		if ( kill(0,$lines[0]) > 0 && $now < ( stat($lockfile)->mtime + $stale_time ) ) {
				main::logger "ERROR: Quitting - process is already running ($lockfile)\n";
				# redefine cleanup sub so that it doesn't delete $lockfile
				$lockfile = '';
				exit 0;
		} else {
			main::logger "INFO: Removing stale lockfile\n" if $opt->{verbose};
			unlink ${lockfile};
		}
	}
	# write our PID into this lockfile
	if (! open (LOCKFILE, "> $lockfile") ) {
		main::logger "ERROR: Cannot write to lockfile '${lockfile}'\n";
		exit 1;
	}
	print LOCKFILE $$;
	close LOCKFILE;
	return 0;
}





############## OO ################

############## Options default class ################
package Options;

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use Getopt::Long;
use strict;

# Constructor
# Usage: $opt = Options->new( 'optname' => 'testing 123', 'myopt2' => 'myval2', <and so on> );
sub new {
	my $type = shift;
	my %params = @_;
	my $self = {};
	for (keys %params) {
		$self->{$_} = $params{$_};
	}
	bless $self, $type;
}



# Parse cmdline opts using supplied hash
# Usage: $opt_cmdline->parse( \%opt_format );
sub parse {
	my $this = shift;
	my $opt_format_ref = shift;
	# Build hash for passing to GetOptions module
	my %get_opts;

	for my $name (keys %{$opt_format_ref} ) {
		my $format = @{ $opt_format_ref->{$name} }[1];
		$get_opts{ $format } = \$this->{$name};
	}

	# Allow bundling of single char options
	Getopt::Long::Configure("bundling");

	# cmdline opts take precedence
	# get options
	return GetOptions(%get_opts);
}



sub copyright_notice {
	shift;
	my $text = sprintf "get_iplayer v%.2f, ", $version;
	$text .= <<'EOF';
Copyright (C) 2009 Phil Lewis
  This program comes with ABSOLUTELY NO WARRANTY; for details use --warranty.
  This is free software, and you are welcome to redistribute it under certain
  conditions; use --conditions for details.

EOF
	return $text;
}



# Usage: $opt_cmdline->usage( \%opt_format, <helplong> );
sub usage {
	my $this = shift;
	my $opt_format_ref = shift;
	my $helplong = shift;
	my %section_name;
	my %name_syntax;
	my %name_desc;
	my $usage;
	$usage .= "Usage ( Also see http://linuxcentre.net/iplayer ):\n";
	$usage .= " Search Programmes:             get_iplayer [<search options>] [<regex|index> ...]\n";
	$usage .= " Download Programmes:           get_iplayer --get [<search options>] <regex|index> ...\n";
	$usage .= "                                get_iplayer --pid <type>:<pid> [<options>]\n" if $helplong;
	$usage .= " Stream Downloads:              get_iplayer --stdout [<options>] <regex|index> | mplayer -cache 3072 -\n" if $helplong;
	$usage .= " Update get_iplayer:            get_iplayer --update\n";
	$usage .= " Advanced Options:              get_iplayer --long-help\n" if ! $helplong;

	for my $name (keys %{$opt_format_ref} ) {
		next if not $opt_format_ref->{$name};
		my ( $advanced, $format, $section, $syntax, $desc ) = @{ $opt_format_ref->{$name} };
		# Skip advanced options if not req'd
		next if $advanced && ! $helplong;
		push @{$section_name{$section}}, $name if $syntax;
		$name_syntax{$name} = $syntax;
		$name_desc{$name} = $desc;
	}

	# Build the help usage text
	# Each section
	for my $section ( keys %section_name ) {
		my @lines;
		$usage .= "\n$section Options:\n";
		# Each name in this section array
		for my $name ( sort @{ $section_name{$section} } ) {
			push @lines, sprintf(" %-30s %s\n", $name_syntax{$name}, $name_desc{$name} );
		}
		$usage .= $_ for sort @lines;
	}

	return $usage;
}


# Add all the options into suplied hash from specified class
# Usage: Options->get_class_options( 'Programme:tv', \%opt_format );
sub get_class_options {
	shift;
	my $classname = shift;
	my $opt_format_ref = shift;
	# If the method exists...
	eval { $classname->opt_format() };
	if ( ! $@ ) {
		my %tmpopt = %{ $classname->opt_format() };
		for my $thisopt ( keys %tmpopt ) {
			$opt_format_ref->{$thisopt} = $tmpopt{$thisopt}; 
		}	
	}
}


# Copies values in one instance to another only if they are set with a value/defined
# Usage: $opt->copy_set_options_from( $opt_cmdline );
sub copy_set_options_from {
	my $this_to = shift;
	my $this_from = shift;
	# Merge cmdline options into $opt instance (only those options defined)
	for ( keys %{$this_from} ) {
		$this_to->{$_} = $this_from->{$_} if defined $this_from->{$_};
	}
}


# $opt->save( $opt_cmdline, $optfilename )
# Save cmdline-only options to file
sub save {
	my $this = shift;
	my $this_cmdline = shift;
	my $optfile = shift;
	unlink $optfile;
	main::logger "DEBUG: Saving options to $optfile:\n" if $this->{debug};
	open (OPT, "> $optfile") || die ("ERROR: Cannot save options to $optfile\n");
	# Save all opts except for these
	for ( grep !/(help|test|debug|get)/, keys %{$this_cmdline} ) {
		print OPT "$_ $this_cmdline->{$_}\n"  if defined $this_cmdline->{$_};
		main::logger "DEBUG: Setting cmdline option $_ = $this_cmdline->{$_}\n" if $this->{debug} && defined $this_cmdline->{$_};
	}
	close OPT;
	main::logger "INFO: Command Line Options saved as default in $optfile\n";
	exit 0;
}


# $opt_file->load( $opt, $optfilename )
# Load default options from file into instance
sub load {
	my $this_file = shift;
	my $this = shift;
	my $optfile = shift;
	return 0 if ! -f $optfile;
	main::logger "DEBUG: Parsing options from $optfile:\n" if $this->{debug};
	open (OPT, "< $optfile") || die ("ERROR: Cannot read options file $optfile\n");
	while(<OPT>) {
		/^\s*([\w\-_]+)\s+(.*)\s*$/;
		#chomp( $this->{$1} = $2 );
		# keep track of which options came from files
		chomp( $this_file->{$1} = $2 );
		main::logger "DEBUG: Setting option $1 = $2\n" if $this->{debug};
	}
	close OPT;
}



# Usage: $opt_file->display( [<exclude regex>], [<title>] );
# Display options
sub display {
	my $this = shift;
	my $title = shift || 'Options';
	my $excluderegex = shift || 'ROGUEVALUE';
	main::logger "$title:\n";
	for ( grep !/(help|debug|get|^pvr)/i, sort keys %{$this} ) {
		main::logger "\t$_ = $this->{$_}\n" if defined $this->{$_} && $this->{$_};
	}
	main::logger "\n";
	return 0;
}



########################################################

#################### Programme class ###################

package Programme;

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
use Time::Local;
use URI;

# Class vars
# Global options
my $optref;
my $opt;
# index min/max
sub index_min { return 0 }
sub index_max { return 9999999 };
# Class cmdline Options
sub opt_format {
	return {
	};
}


sub channels {
	return {};
}


# Method to return optional list_entry format
sub optional_list_entry_format {
	my $prog = shift;
	return '';
}


# Returns the modes to try for this prog type
sub modelist {
	return '';
}


# Constructor
# Usage: $prog{$pid} = Programme->new( 'pid' => $pid, 'name' => $name, <and so on> );
sub new {
	my $type = shift;
	my %params = @_;
	my $self = {};
	for (keys %params) {
		$self->{$_} = $params{$_};
	}
	## Ensure that all instances reference the same class global $optref var
	# $self->{optref} = $Programme::optref;
	# Ensure the subclass $opt var is pointing to the Superclass global optref
	$opt = $Programme::optref;
	bless $self, $type;
}


# Use to bind a new options ref to the class global $optref var
sub add_opt_object {
	my $self = shift;
	$Programme::optref = shift;
}


# $opt->{<option>} access method
sub opt {
	my $self = shift;
	my $optname = shift;
	return $opt->{$optname};

	#return $Programme::optref->{$optname};	
	#my $opt = $self->{optref};
	#return $self->{optref}->{$optname};
}


# Cleans up a pid and removes url parts that might be specified
sub clean_pid {
}


# Return metadata of the prog
sub get_metadata {
	return {};
}



# Download Subtitles, convert to srt(SubRip) format and apply time offset
sub download_subtitles {
	# return failed...
	return 1;
}



# Retry the download of a programme
# Usage: download_retry_loop ( $progref, $retries )
sub download_retry_loop {
	my $prog = shift;
	my $retries = shift;

	# Retry loop
	my $count = 0;
	my $retcode;

	return 0 if ( ! $opt->{streaminfo} ) && main::check_download_history( $prog->{pid} );

	# Skip and warn if there is no pid
	if ( ! $prog->{pid} ) {
		main::logger "ERROR: No PID for index $_ (try using --type option ?)\n";
		return 1;
	}

	# Setup user-agent
	my $ua = main::create_ua('desktop');
	# Get all possible (or user overridden) modes for this prog download
	my $modelist = $prog->modelist;

	# download depending on the prog type
	main::logger "INFO: $modelist modes will be tried\n";

	# Expand the modes into a loop
	for my $mode ( split /,/, $modelist ) {
		chomp( $mode );
		main::logger "INFO: Trying $mode mode to download $prog->{type}: $prog->{name} - $prog->{episode}\n";

		# Retry loop
		for ($count = 1; $count <= $retries; $count++) {

			$retcode = $prog->download( $ua, $mode );
			main::logger "DEBUG: Download using $mode mode return code: '$retcode'\n" if $opt->{verbose};

			# Exit
			if ( $retcode eq 'abort' ) {
				main::logger "ERROR: aborting get_iplayer\n";
				exit 1;

			# Try Next prog
			} elsif ( $retcode eq 'skip' ) {
				main::logger "INFO: skipping this programme\n";
				return 1;

			# Try Next mode
			} elsif ( $retcode eq 'next' ) { 
				# break out of this retry loop
				main::logger "INFO: skipping $mode mode\n";
				last;
			
			# Success
			} elsif ( $retcode eq '0' ) {
				# Add to history, tag file, and run post download command
				main::add_to_download_history( $prog );
				$prog->tag_file;
				$prog->run_user_command( $opt->{command} ) if $opt->{command};
				$prog->report() if $opt->{pvr};
				return 0;

			# Retry this mode
			} elsif ( $retcode eq 'retry' && $count < $retries ) {
				main::logger "WARNING: Retrying download for '$prog->{name} - $prog->{episode} ($prog->{pid})'\n";
			}
		}
		
	
	} # Next mode

	if (! $opt->{test}) {
		main::logger "ERROR: Failed to download '$prog->{name} - $prog->{episode} ($prog->{pid})'\n";
	}
	return 1;
}



# Send a message to STDOUT so that cron can use this to email 
sub report {
	my $prog = shift;
	print STDOUT "New $prog->{type} programme: '$prog->{name} - $prog->{episode}', '$prog->{desc}'\n";
	return 0;
}



# Add id3 tag to MP3/AAC files if required
sub tag_file {
	my $prog = shift;

	if ( $prog->{ext} =~ /^(aac|mp3|mp4a)$/i ) {
		# Return if file does not exist
		return if ! -f $prog->{filename};
		# Create ID3 tagging options for external tagger program (escape " for shell)
		my ( $id3_name, $id3_episode, $id3_desc, $id3_channel ) = ( $prog->{name}, $prog->{episode}, $prog->{desc}, $prog->{channel} );
		$id3_name =~ s|"|\"|g for ($id3_name, $id3_episode, $id3_desc, $id3_channel);
		# Only tag if the required tool exists
		if ( main::exists_in_path($id3v2) ) {
			main::logger "INFO: id3 tagging MP3 file\n";
			my $cmd = "$id3v2 --artist \"$id3_channel\" --album \"$id3_name\" --song \"$id3_episode\" --comment \"Description\":\"$id3_desc\" --year ".( (localtime())[5] + 1900 )." \"$prog->{filename}\" 1>&2";
			main::logger "DEGUG: Running $cmd\n" if $opt->{debug};
			if ( system($cmd) ) {
				main::logger "WARNING: Failed to tag MP3 file\n";
				return 2;
			}
		} else {
			main::logger "WARNING: Cannot tag MP3 file\n" if $opt->{verbose};
		}
	}
}



# Usage: print $prog{$pid}->substitute('<name>-<pid>-<episode>');
# Return a string with formatting fields substituted for a given pid
# no_sanitize == 2 then just substitute only
# no_sanitize == 1 then also sanitize '/' in field values
# no_sanitize == 0 then dont sanitize '/' in field values
sub substitute {
	my $self = shift;
	my $string = shift;
	my $no_sanitize = shift || 0;
	my $replace;
			
	# Tokenize and substitute $format
	for my $key ( keys %{$self} ) {
		# Remove/replace all non-nice-filename chars if required
		if ($no_sanitize == 0) {
			$replace = StringUtils::sanitize_path( $self->{$key} );
		} else {
			$replace = $self->{$key};
		}
		$string =~ s|\<$key\>|$replace|gi;
	}
	$string =~ s|<pid>|$replace|gi;
	# Remove/replace all non-nice-filename chars if required except for fwd slashes
	if ($no_sanitize != 2) {
		return StringUtils::sanitize_path( $string, 1 );
	} else {
		return $string;
	}
}

	
	
# Determine the correct filenames for a download
# Sets the various filenames and creates appropriate directories
#
# Uses:
#	$opt->{fileprefix}
#	$opt->{subdir}
#	$opt->{whitespace}
#	$opt->{test}
# Requires: 
#	$prog->{dir}
# Sets: 
#	$prog->{fileprefix}
#	$prog->{filename}
#	$prog->{filepart}
#	$prog->{symlink}
# Returns 0 on success, 1 on failure (i.e. if the <filename> already exists)
#
sub generate_filenames {
	my ($prog, $format, $multipart) = (@_);
	
	$prog->{dir} = $opt->{ 'output'.$prog->{type} } || $opt->{output} || $ENV{IPLAYER_OUTDIR} || '.';

	$prog->{fileprefix} = $opt->{fileprefix} || $format;

	# If we dont have longname defined just set it to name
	$prog->{longname} = $prog->{name} if ! $prog->{longname};

	# substitute fields and sanitize $prog->{fileprefix}
	$prog->{fileprefix} = $prog->substitute( $prog->{fileprefix} );

	# Spaces
	$prog->{fileprefix} =~ s/\s+/_/g if ! $opt->{whitespace};

	# Don't create subdir if we are only testing downloads
	# Create a subdir for programme sorting option
	if ( $opt->{subdir} ) {
		my $subdir = $prog->substitute( '<longname>' );
		$prog->{dir} .= "/${subdir}";
		$prog->{dir} .= s|\/\/|\/|g;
		main::logger("INFO: Creating subdirectory $prog->{dir} for programme\n") if $opt->{verbose};
	}

	# Create a subdir if there are multiple parts
	if ( $multipart ) {
		$prog->{dir} .= "/$prog->{fileprefix}";
		$prog->{dir} .= s|\/\/|\/|g;
		main::logger("INFO: Creating multi-part subdirectory $prog->{dir} for programme\n") if $opt->{verbose};
	}

	# Create dir if it does not exist
	mkpath("$prog->{dir}") if (! -d "$prog->{dir}") && (! $opt->{test});

	main::logger("\rINFO: File name prefix = $prog->{fileprefix}                 \n");

	$prog->{filename} = "$prog->{dir}/$prog->{fileprefix}.$prog->{ext}";
	$prog->{filepart} = "$prog->{dir}/$prog->{fileprefix}.partial.$prog->{ext}";

	# Create symlink filename if required
	if ( $opt->{symlink} ) {
		# Substitute the fields for the pid
		$prog->{symlink} = $prog->substitute( $opt->{symlink} );
		main::logger("INFO: Symlink file name will be '$prog->{symlink}'\n") if $opt->{verbose};
		# remove old symlink
		unlink $prog->{symlink} if -l $prog->{symlink} && ! $opt->{test};
	}

	if ( -f $prog->{filename} && stat($prog->{filename})->size > $min_download_size ) {
		main::logger("WARNING: File $prog->{filename} already exists\n\n");
		return 1;
	}

	return 0;
}



# Run a user specified command
# e.g. --command 'echo "<pid> <longname> downloaded"'
# run_user_command($pid, 'echo "<pid> <longname> downloaded"');
sub run_user_command {
	my $prog = shift;
	my $command = shift;

	# Substitute the fields for the pid (don't sanitize)
	$command = $prog->substitute( $command, 1 );

	# Escape chars in command for shell use
	StringUtils::esc_chars(\$command);

	# run command
	main::logger "INFO: Running command '$command'\n" if $opt->{verbose};
	my $exit_value = system $command;
	
	# make exit code sane
	$exit_value = $exit_value >> 8;
	main::logger "ERROR: Command Exit Code: $exit_value\n" if $exit_value;
	main::logger "INFO: Command succeeded\n" if $opt->{verbose} && ! $exit_value;
        return 0;
}



# %type
# Display a line containing programme info (using long, terse, and type options)
sub list_entry {
	my ( $prog, $prefix, $tree, $number_of_types ) = ( @_ );

	my $prog_type = '';
	# Show the type field if >1 type has been specified
	$prog_type = "$prog->{type}, " if $number_of_types > 1;
	my $name;
	# If tree view
	if ( $opt->{tree} ) {
		$prefix = '  '.$prefix;
		$name = '';
	} else {
		$name = "$prog->{name} - ";
	}

	main::logger("\n${prog_type}$prog->{name}\n") if $opt->{tree} && ! $tree;
	# Display based on output options
	if ( $opt->{listformat} ) {
		main::logger( $prefix.$prog->substitute( $opt->{listformat}, 2 )."\n");
	} elsif ( $opt->{long} ) {
		my @time = gmtime( time() - $prog->{timeadded} );
		main::logger("${prefix}$prog->{index}:\t${prog_type}${name}$prog->{episode}".$prog->optional_list_entry_format.", $time[7] days $time[2] hours ago - $prog->{desc}\n");
	} elsif ( $opt->{terse} ) {
		main::logger("${prefix}$prog->{index}:\t${prog_type}${name}$prog->{episode}\n");
	} else {
		main::logger("${prefix}$prog->{index}:\t${prog_type}${name}$prog->{episode}".$prog->optional_list_entry_format."\n");
	}
	return 0;
}



sub list_entry_html {
	my ($prog, $tree) = (@_);
	my $html;
	# If tree view
	my $name = encode_entities( $prog->{name} );
	my $episode = encode_entities( $prog->{episode} );
	my $desc = encode_entities( $prog->{desc} );
	my $channel = encode_entities( $prog->{channel} );
	my $type = encode_entities( $prog->{type} );
	my $categories = encode_entities( $prog->{categories} );

	# Header
	if ( not $tree ) {
		# Assume all thumbnails for a prog name are the same
		$html = "<tr bgcolor='#cccccc'>
			<td rowspan=1 width=150><a href=\"$prog->{web}\"><img height=84 width=150 src=\"$prog->{thumbnail}\"></a></td>
				<td><a href=\"$prog->{web}\">${name}</a></td>
				<td>${channel}</td>
				<td>${type}</td>
				<td>${categories}</td>
			</tr>
		\n";
	# Follow-on episodes
	}
		$html .= "<tr>
				<td>$_</td>
				<td><a href=\"$prog->{web}\">${episode}</a></td>
				<td colspan=3>${desc}</td>
			</tr>
		\n";
	return $html;
}


# Creates symlink
# Usage: $prog->create_symlink( <symlink>, <target> );
sub create_symlink {
	my $prog = shift;
	my $symlink = shift;
	my $target = shift;

	# remove old symlink
	unlink $symlink if -l $symlink;
	# Create symlink
	symlink $target, $symlink;
	main::logger "INFO: Created symlink from '$symlink' -> '$target'\n" if $opt->{verbose};
}



# Get time ago made available (x days y hours ago) from '2008-06-22T05:01:49Z' and current time
sub get_available_time_string {
	my $datestring = shift;
	# extract $year $mon $mday $hour $min $sec
	$datestring =~ m{(\d\d\d\d)\-(\d\d)\-(\d\d)T(\d\d):(\d\d):(\d\d)Z};
	my ($year, $mon, $mday, $hour, $min, $sec) = ($1, $2, $3, $4, $5, $6);
	# Calculate the seconds difference between epoch_now and epoch_datestring and convert back into array_time
	my @time = gmtime( time() - timelocal($sec, $min, $hour, $mday, ($mon-1), ($year-1900), undef, undef, 0) );
	return "$time[7] days $time[2] hours ago";
}



################### TV class #################
package Programme::bbciplayer;

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
use Time::Local;
use URI;

# Inherit from Programme class
use base 'Programme';


# Return hash of version => verpid given a pid
sub get_version_pids {
	my ( $prog, $ua ) = @_;
	my %version_pids;
	my $url = $prog_iplayer_metadata.$prog->{pid};

	main::logger "INFO: iPlayer metadata URL = $url\n" if $opt->{verbose};
	#main::logger "INFO: Getting version pids for programme $prog->{pid}        \n" if ! $opt->{verbose};

	# send request
	my $res = $ua->request( HTTP::Request->new( GET => $url ) );
	if ( ! $res->is_success ) {
		main::logger "\rERROR: Failed to get version pid metadata from iplayer site\n\n";
		return %version_pids;
	}

	# The URL http://www.bbc.co.uk/iplayer/playlist/<PID> contains for example:
	#<?xml version="1.0" encoding="UTF-8"?>                                   
	#<playlist xmlns="http://bbc.co.uk/2008/emp/playlist" revision="1">       
	#  <id>tag:bbc.co.uk,2008:pips:b00dlrc8:playlist</id>                     
	#  <link rel="self" href="http://www.bbc.co.uk/iplayer/playlist/b00dlrc8"/>
	#  <link rel="alternate" href="http://www.bbc.co.uk/iplayer/episode/b00dlrc8"/>
	#  <link rel="holding" href="http://www.bbc.co.uk/iplayer/images/episode/b00dlrc8_640_360.jpg" height="360" width="640" type="image/jpeg" />
	#  <title>Amazon with Bruce Parry: Episode 1</title>                                                                                        
	#  <summary>Bruce Parry begins an epic adventure in the Amazon following the river from source to sea, beginning  in the High Andes and visiting the Ashaninka tribe.</summary>                                                                                                        
	#  <updated>2008-09-18T14:03:35Z</updated>                                                                                                  
	#  <item kind="ident">                                                                                                                      
	#    <id>tag:bbc.co.uk,2008:pips:bbc_two</id>                                                                                               
	#    <mediator identifier="bbc_two" name="pips"/>                                                                                           
	#  </item>                                                                                                                                  
	#  <item kind="programme" duration="3600" identifier="b00dlr9p" group="b00dlrc8" publisher="pips">                                          
	#    <tempav>1</tempav>                                                                                                                     
	#    <id>tag:bbc.co.uk,2008:pips:b00dlr9p</id>                                                                                              
	#    <service id="bbc_two" href="http://www.bbc.co.uk/iplayer/bbc_two">BBC Two</service>                                                    
	#    <masterbrand id="bbc_two" href="http://www.bbc.co.uk/iplayer/bbc_two">BBC Two</masterbrand>                                            
	#
	#    <alternate id="default" />
	#    <guidance>Contains some strong language.</guidance>
	#    <mediator identifier="b00dlr9p" name="pips"/>      
	#  </item>
	#  <item kind="programme" duration="3600" identifier="b00dp4xn" group="b00dlrc8" publisher="pips">
	#    <tempav>1</tempav>
	#    <id>tag:bbc.co.uk,2008:pips:b00dp4xn</id>
	#    <service id="bbc_one" href="http://www.bbc.co.uk/iplayer/bbc_one">BBC One</service>
	#    <masterbrand id="bbc_two" href="http://www.bbc.co.uk/iplayer/bbc_two">BBC Two</masterbrand>
	#
	#    <alternate id="signed" />
	#    <guidance>Contains some strong language.</guidance>
	#    <mediator identifier="b00dp4xn" name="pips"/>
	#  </item>

	# If a prog is totally unavailable you get 
	# ...
	# <updated>2009-01-15T23:13:33Z</updated>
	# <noItems reason="noMedia" />
	#
	#                <relatedLink>
	                
	my $xml = $res->content;	
	# flatten
	$xml =~ s/\n/ /g;

	# Detect noItems or no programmes
	if ( $xml =~ m{<noItems\s+reason="noMedia"} || $xml !~ m{kind="(programme|radioProgramme)"} ) {
		main::logger "\rWARNING: No programmes are available for this pid\n\n";
		return %version_pids;
	}

	# Get title
	# <title>Amazon with Bruce Parry: Episode 1</title>
	my ( $title, $prog_type );
	$title = $1 if $xml =~ m{<title>\s*(.+?)\s*<\/title>};

	# Get type
	$prog_type = 'tv' if grep /kind="programme"/, $xml;
	$prog_type = 'radio' if grep /kind="radioProgramme"/, $xml;

	# Split into <item kind="programme"> sections
	for ( split /<item\s+kind="(radioProgramme|programme)"/, $xml ) {
		main::logger "DEBUG: Block: $_\n" if $opt->{debug};
		my ($verpid, $version);
		#  duration="3600" identifier="b00dp4xn" group="b00dlrc8" publisher="pips">
		$verpid = $1 if m{\s+duration=".*?"\s+identifier="(.+?)"};
		# <alternate id="default" />
		$version = lc($1) if m{<alternate\s+id="(.+?)"};
		next if ! ($verpid && $version);
		$version_pids{$version} = $verpid;
		main::logger "INFO: Version: $version, VersionPid: $verpid\n" if $opt->{verbose};  
	}

	# Extract Long Name, e.g.: iplayer.episode.setTitle("DIY SOS: Series 16: Swansea"), Strip off the episode name
	$title =~ s/^(.+):.*?$/$1/g;

	# Add to prog hash
	$prog->{versions} = join ',', keys %version_pids;
	$prog->{longname} = $title;
	return %version_pids;
}



# get full episode metadata given pid and ua. Uses two different urls to get data
sub get_metadata {
	my $prog = shift;
	my $ua = shift;
	my $metadata;
	my $entry3;
	my ($name, $episode, $duration, $available, $channel, $expiry, $longdesc, $versions, $guidance, $prog_type, $categories, $player, $thumbnail);

	# This URL works for all prog types:
	# http://www.bbc.co.uk/iplayer/playlist/${pid}

	# This URL only works for TV progs:
	# http://www.bbc.co.uk/iplayer/metafiles/episode/${pid}.xml

	# This URL works for tv/radio prog types:
	# http://www.bbc.co.uk/iplayer/widget/episodedetail/episode/${pid}/template/mobile/service_type/tv/

	# This URL works for tv/radio prog types:
	# $prog_feed_url = http://feeds.bbc.co.uk/iplayer/episode/$pid

	$entry3 = main::request_url_retry($ua, $prog_feed_url.$prog->{pid}, 3, '', '');
	decode_entities($entry3);
	main::logger "DEBUG: $prog_feed_url.$prog->{pid}:\n$entry3\n\n" if $opt->{debug};
	# Flatten
	$entry3 =~ s|\n| |g;

	# Entry3 format
	#<?xml version="1.0" encoding="utf-8"?>                                      
	#<?xml-stylesheet href="http://www.bbc.co.uk/iplayer/style/rss.css" type="text/css"?>
	#<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:media="http://search.yahoo.com/mrss/" xml:lang="en-GB">
	#  <title>BBC iPlayer - Episode Detail: Edith Bowman: 22/09/2008</title>                                                                          
	#  <subtitle>Sara Cox sits in for Edith with another Cryptic Randomizer.</subtitle>
	#  <updated>2008-09-29T10:59:45Z</updated>
	#  <id>tag:feeds.bbc.co.uk,2008:/iplayer/feed/episode/b00djtfh</id>
	#  <link rel="related" href="http://www.bbc.co.uk/iplayer" type="text/html" />
	#  <link rel="self" href="http://feeds.bbc.co.uk/iplayer/episode/b00djtfh" type="application/atom+xml" />
	#  <author>
	#    <name>BBC</name>
	#    <uri>http://www.bbc.co.uk</uri>
	#  </author>
	#  <entry>
	#    <title type="text">Edith Bowman: 22/09/2008</title>
	#    <id>tag:feeds.bbc.co.uk,2008:PIPS:b00djtfh</id>
	#    <updated>2008-09-15T01:28:36Z</updated>
	#    <summary>Sara Cox sits in for Edith with another Cryptic Randomizer.</summary>
	#    <content type="html">
	#      &lt;p&gt;
	#        &lt;a href=&quot;http://www.bbc.co.uk/iplayer/episode/b00djtfh?src=a_syn30&quot;&gt;
	#          &lt;img src=&quot;http://www.bbc.co.uk/iplayer/images/episode/b00djtfh_150_84.jpg&quot; alt=&quot;Edith Bowman: 22/09/2008&quot; /&gt;
	#        &lt;/a&gt;
	#      &lt;/p&gt;
	#      &lt;p&gt;
	#        Sara Cox sits in for Edith with movie reviews and great new music, plus another Cryptic Randomizer.
	#      &lt;/p&gt;
	#    </content>
	#    <link rel="alternate" href="http://www.bbc.co.uk/iplayer/episode/b00djtfh?src=a_syn31" type="text/html" title="Edith Bowman: 22/09/2008">
	#      <media:content medium="audio" duration="10800">
	#        <media:title>Edith Bowman: 22/09/2008</media:title>
	#        <media:description>Sara Cox sits in for Edith with movie reviews and great new music, plus another Cryptic Randomizer.</media:description>
	#        <media:player url="http://www.bbc.co.uk/iplayer/episode/b00djtfh?src=a_syn31" />
	#        <media:category scheme="urn:bbc:metadata:cs:iPlayerUXCategoriesCS" label="Entertainment">9100099</media:category>
	#        <media:category scheme="urn:bbc:metadata:cs:iPlayerUXCategoriesCS" label="Music">9100006</media:category>
	#        <media:category scheme="urn:bbc:metadata:cs:iPlayerUXCategoriesCS" label="Pop &amp; Chart">9200069</media:category>
	#        <media:credit role="Production Department" scheme="urn:ebu">BBC Radio 1</media:credit>
	#        <media:credit role="Publishing Company" scheme="urn:ebu">BBC Radio 1</media:credit>
	#        <media:thumbnail url="http://www.bbc.co.uk/iplayer/images/episode/b00djtfh_86_48.jpg" width="86" height="48" />
	#        <media:thumbnail url="http://www.bbc.co.uk/iplayer/images/episode/b00djtfh_150_84.jpg" width="150" height="84" />
	#        <media:thumbnail url="http://www.bbc.co.uk/iplayer/images/episode/b00djtfh_178_100.jpg" width="178" height="100" />
	#        <media:thumbnail url="http://www.bbc.co.uk/iplayer/images/episode/b00djtfh_512_288.jpg" width="512" height="288" />
	#        <media:thumbnail url="http://www.bbc.co.uk/iplayer/images/episode/b00djtfh_528_297.jpg" width="528" height="297" />
	#        <media:thumbnail url="http://www.bbc.co.uk/iplayer/images/episode/b00djtfh_640_360.jpg" width="640" height="360" />
	#        <dcterms:valid>
	#          start=2008-09-22T15:44:20Z;
	#          end=2008-09-29T15:02:00Z;
	#          scheme=W3C-DTF
	#        </dcterms:valid>
	#      </media:content>
	#    </link>
	#    <link rel="self" href="http://feeds.bbc.co.uk/iplayer/episode/b00djtfh?format=atom" type="application/atom+xml" title="22/09/2008" />
	#    <link rel="related" href="http://www.bbc.co.uk/programmes/b006wks4/microsite" type="text/html" title="Edith Bowman" />
	#    <link rel="parent" href="http://feeds.bbc.co.uk/iplayer/programme_set/b006wks4" type="application/atom+xml" title="Edith Bowman" />
	#  </entry>
	#</feed>
		
	$expiry = $1 if $entry3 =~ m{<dcterms:valid>\s*start=.+?;\s*end=(.*?);};
	$available = $1 if $entry3 =~ m{<dcterms:valid>\s*start=(.+?);\s*end=.*?;};
	$duration = $1 if $entry3 =~ m{duration=\"(\d+?)\"};
	$prog_type = $1 if $entry3 =~ m{medium=\"(\w+?)\"};
	$longdesc = $1 if $entry3 =~ m{<media:description>\s*(.*?)\s*<\/media:description>};
	$guidance = $1 if $entry3 =~ m{<media:rating scheme="urn:simple">(.+?)<\/media:rating>};
	$player = $1 if $entry3 =~ m{<media:player\s*url=\"(.*?)\"\s*\/>};
	$thumbnail = $1 if $entry3 =~ m{<media:thumbnail url="([^"]+?)"\s+width="150"\s+height="84"\s*/>};
	
	my @cats;
	for (split /<media:category scheme=\".+?\"/, $entry3) {
		push @cats, $1 if m{\s*label="(.+?)">\d+<\/media:category>};
	}
	$categories = join ',', @cats;

	# populate version pid metadata 
	$prog->get_version_pids( $ua );

	# Fill in from cache if not got from metadata
	my %metadata;
	$metadata{pid}		= $prog->{pid};
	$metadata{index}	= $prog->{index};
	$metadata{name}		= $name || $prog->{name};
	$metadata{episode}	= $episode || $prog->{episode};
	$metadata{type}		= $prog_type || $prog->{type};
	$metadata{duration}	= $duration || $prog->{duration};
	$metadata{channel}	= $channel || $prog->{channel};
	$metadata{available}	= $available || $prog->{available};
	$metadata{expiry}	= $expiry || $prog->{expiry};
	$metadata{versions}	= $versions || $prog->{versions};
	$metadata{guidance}	= $guidance || $prog->{guidance};
	$metadata{categories}	= $categories || $prog->{categories};
	$metadata{desc}		= $longdesc || $prog->{desc};
	$metadata{player}	= $player;
	$metadata{thumbnail}	= $thumbnail || $prog->{thumbnail};

	return %metadata;
}



# Generic
# Gets media streams data for this version pid
# $media = all|flashhigh|flashnormal|iphone|flashlow|n95_wifi|n95_3g|mobile|flashaudio|flashaac|realaudio|wma|subtitles
sub get_stream_data {
	my ( $prog, $verpid, $media ) = @_;
	my %data;

	# Setup user agent with redirection enabled
	my $ua = main::create_ua('desktop');
	$opt->{quiet} = 0 if $opt->{streaminfo};

	# BBC streams
	my $xml1 = main::request_url_retry($ua, $media_stream_data_prefix.$verpid, 3, '', '');
	main::logger "\n$xml1\n" if $opt->{debug};
	# flatten
	$xml1 =~ s/\n/ /g;
		
	for my $xml ( split /<media/, $xml1 ) {
		$xml = "<media".$xml;
		my $prog_type;
		
		# h.264 high quality stream
		#	<media kind="video"
		#        width="640"
		#        height="360"
		#        type="video/mp4"
		#        encoding="h264"  >
		#        <connection
		#                priority="10"
		#                application="bbciplayertok"
		#                kind="level3"
		#                server="bbciplayertokfs.fplive.net"
		#                identifier="mp4:b000zxf4-H26490898078"
		#                authString="d52f77fede048f1ffd6587fd47446dee"
		#        />
		# application: bbciplayertok
		# tcURL: rtmp://bbciplayertokfs.fplive.net:80/bbciplayertok
		if ( $media =~ /^(flashhigh|all)$/ && $xml =~ m{<media\s+kind="video".+?type="video/mp4".+?encoding="h264".+?application="(.+?)".+?kind="level3"\s+server="(.+?)"\s+?identifier="(.+?)"\s+?authString="(.+?)"} ) {
			$prog_type = 'flashhigh';
			main::logger "DEBUG: Processing $prog_type stream\n" if $opt->{verbose};
			( $data{$prog_type}{application}, $data{$prog_type}{server}, $data{$prog_type}{identifier}, $data{$prog_type}{authstring} ) = ( $1, $2, $3, $4 );
			$data{$prog_type}{type} = 'Flash RTMP H.264 high quality stream';
			$data{$prog_type}{tcurl} = "rtmp://$data{$prog_type}{server}:80/$data{$prog_type}{application}";
			$data{$prog_type}{swfurl} = "http://www.bbc.co.uk/emp/9player.swf?revision=7276";
			$data{$prog_type}{streamurl} = "rtmp://$data{$prog_type}{server}:1935/$data{$prog_type}{application}?_fcs_vhost=$data{$prog_type}{server}&auth=$data{$prog_type}{authstring}&aifp=v001&slist=$data{$prog_type}{identifier}";
		}
			
		# h.264 normal quality stream
		#	<media kind="video"
		#        width="640"
		#        height="360"
		#        type="video/x-flv"
		#        encoding="vp6"  >
		#        <connection
		#                priority="10"
		#                kind="akamai"
		#                server="cp41752.edgefcs.net"
		#                identifier="secure/b000zxf4-streaming90898078"
		#                authString="daEdSdgbcaibFa7biaobCaYdadyaTamazbq-biXsum-cCp-FqrECnEoGBwFvwG"
		#        />
		#	</media>
		#
		# application (e.g.):            ondemand?_fcs_vhost=cp41752.edgefcs.net&auth=daEcia8aQaRardxdwb_dCbvc0cPbLavc2cL-bjw5rj-cCp-JnlDCnzn.MEqHpxF&aifp=v001&slist=secure/b000gy717streaming103693754
		# tcURL: rtmp://88.221.26.165:80/ondemand?_fcs_vhost=cp41752.edgefcs.net&auth=daEcia8aQaRardxdwb_dCbvc0cPbLavc.2cL-bjw5rj-cCp-JnlDCnznMEqHpxF&aifp=v001&slist=secure/b000gy717streaming103693754
		if ( $media =~ /^(flashnormal|all)$/ && $xml =~ m{<media\s+kind="video".+?type="video/x-flv".+?encoding="vp6".+?kind="akamai"\s+server="(.+?)"\s+?identifier="(.+?)"\s+?authString="(.+?)"} ) {
			$prog_type = 'flashnormal';
			main::logger "DEBUG: Processing $prog_type stream\n" if $opt->{verbose};
			( $data{$prog_type}{server}, $data{$prog_type}{identifier}, $data{$prog_type}{authstring} ) = ( $1, $2, $3 );
			$data{$prog_type}{application} = "bbciplayertok?_fcs_vhost=$data{$prog_type}{server}&auth=$data{$prog_type}{authstring}&aifp=v001&slist=$data{$prog_type}{identifier}";
			$data{$prog_type}{type} = 'Flash RTMP H.264 normal quality stream';
			$data{$prog_type}{tcurl} = "rtmp://$data{$prog_type}{server}:80/$data{$prog_type}{application}";
			$data{$prog_type}{swfurl} = "http://www.bbc.co.uk/emp/9player.swf?revision=7276";
			$data{$prog_type}{streamurl} = "rtmp://$data{$prog_type}{server}:1935/bbciplayertok?_fcs_vhost=$data{$prog_type}{server}&auth=$data{$prog_type}{authstring}&aifp=v001&slist=$data{$prog_type}{identifier}";
		}
			
		# Wii h.264 standard quality stream
		#<media kind="video"
		#        width="512"
		#        height="288"
		#        type="video/x-flv"
		#        encoding="spark"  >
		#        <connection
		#                priority="10"
		#                kind="akamai"
		#                server="cp41752.edgefcs.net"
		#                identifier="secure/5242138581547639062"
		#                authString="daEd8dLbGaPaZdzdNcwd.auaydJcxcHandp-biX5YL-cCp-BqsECnxnGEsHwyE"
		#        />
		#</media>
		# application (e.g.):               ondemand?_fcs_vhost=cp41752.edgefcs.net&auth=daEcpc6cYbhdIakdWduc6bJdPbydbazdmdp-bjxPBF-cCp-GptFAoDqJBnHvzC&aifp=v001&slist=secure/b000g884xstreaming101052333
		# tcURL: rtmp: //88.221.26.173:1935/ondemand?_fcs_vhost=cp41752.edgefcs.net&auth=daEcpc6cYbhdIakdWduc6bJdPbydbazdmdp-bjxPBF-cCp-GptFAoDqJBnHvzC&aifp=v001&slist=secure/b000g884xstreaming101052333
		# swfUrl: http://www.bbc.co.uk/emp/iplayer/7player.swf?revision=3897
		if ( $media =~ /^(flashlow|all)$/ && $xml =~ m{<media\s+kind="video".+?type="video/x-flv".+?encoding="spark".+?kind="akamai"\s+server="(.+?)"\s+?identifier="(.+?)"\s+?authString="(.+?)"} ) {
			$prog_type = 'flashlow';
			main::logger "DEBUG: Processing $prog_type stream\n" if $opt->{verbose};
			( $data{$prog_type}{server}, $data{$prog_type}{identifier}, $data{$prog_type}{authstring} ) = ( $1, $2, $3 );
			$data{$prog_type}{application} = "bbciplayertok?_fcs_vhost=$data{$prog_type}{server}&auth=$data{$prog_type}{authstring}&aifp=v001&slist=$data{$prog_type}{identifier}";
			$data{$prog_type}{type} = 'Flash RTMP H.264 Wii stream';
			$data{$prog_type}{tcurl} = "rtmp://$data{$prog_type}{server}:1935/$data{$prog_type}{application}";
			$data{$prog_type}{swfurl} = "http://www.bbc.co.uk/emp/iplayer/7player.swf?revision=3897";
			$data{$prog_type}{streamurl} = "rtmp://$data{$prog_type}{server}:1935/bbciplayertok?_fcs_vhost=$data{$prog_type}{server}&auth=$data{$prog_type}{authstring}&aifp=v001&slist=$data{$prog_type}{identifier}";
		}
		
		# iPhone h.264/mp3 stream
		#<media kind="video"
		#        width="480"
		#        height="272"
		#        type="video/mp4"
		#        encoding="h264"  >
		#        <connection
		#                priority="10"
		#                kind="sis"
		#                server="http://www.bbc.co.uk/mediaselector/3/auth/stream/"
		#                identifier="5242138581547639062"
		#                href="http://www.bbc.co.uk/mediaselector/3/auth/stream/5242138581547639062.mp4"
		#        />
		#</media>
		if ( $media =~ /^(iphone|all)$/ && $xml =~ m{<media\s+kind="video".+?type="video/mp4".+?encoding="h264".+?kind="sis"\s+server="(.+?)"\s+?identifier="(.+?)"\s+?href="(http.+?)"} ) {
			$prog_type = 'iphone';
			main::logger "DEBUG: Processing $prog_type stream\n" if $opt->{verbose};
			( $data{$prog_type}{server}, $data{$prog_type}{identifier}, $data{$prog_type}{streamurl} ) = ( $1, $2, $3 );
			$data{$prog_type}{type} = 'iPhone stream';
		}
		
		# Nokia N95 h.264 low quality stream (WiFi)
		#<media kind="video"
		#        type="video/mpeg"
		#        encoding="h264"  >
		#        <connection
		#                priority="10"
		#                kind="sis"
		#                server="http://www.bbc.co.uk/mediaselector/4/sdp/"
		#                identifier="b00108ld/iplayer_streaming_n95_wifi"
		#                href="http://www.bbc.co.uk/mediaselector/4/sdp/b00108ld/iplayer_streaming_n95_wifi"
		#        />
		#</media>
		if ( $media =~ /^(n95_wifi|all)$/ && $xml =~ m{<media\s+kind="video".+?type="video/mpeg".+?encoding="h264".+?kind="sis"\s+server="(.+?)"\s+?identifier="(.+?)"\s+?href="(http.+?)"} ) {
			$prog_type = 'n95_wifi';
			main::logger "DEBUG: Processing $prog_type stream\n" if $opt->{verbose};
			( $data{$prog_type}{server}, $data{$prog_type}{identifier}, $data{$prog_type}{href} ) = ( $1, $2, $3 );
			$data{$prog_type}{type} = 'Nokia N95 h.264 low quality WiFi stream';
			$opt->{quiet} = 1 if $opt->{streaminfo};
			chomp( $data{$prog_type}{streamurl} = main::request_url_retry($ua, $data{$prog_type}{href}, 2, '', '') );
			$opt->{quiet} = 0 if $opt->{streaminfo};
		}
		
		# Nokia N95 h.264 low quality stream (3G)
		#<media kind="" 
		#        expires="2008-10-30T12:29:00+00:00"
		#        type="video/mpeg"                  
		#        encoding="h264"  >                 
		#        <connection                        
		#                priority="10"              
		#                kind="sis"                 
		#                server="http://www.bbc.co.uk/mediaselector/4/sdp/" 
		#                identifier="b009tzxx/iplayer_streaming_n95_3g"     
		#                href="http://www.bbc.co.uk/mediaselector/4/sdp/b009tzxx/iplayer_streaming_n95_3g" 
		#        />                                                                                        
		#</media>    
		if ( $media =~ /^(n95_3g|all)$/ && $xml =~ m{<media\s+kind="".+?type="video/mpeg".+?encoding="h264".+?kind="sis"\s+server="(.+?)"\s+?identifier="(.+?)"\s+?href="(http.+?)"} ) {
			$prog_type = 'n95_3g';
			main::logger "DEBUG: Processing $prog_type stream\n" if $opt->{verbose};
			( $data{$prog_type}{server}, $data{$prog_type}{identifier}, $data{$prog_type}{href} ) = ( $1, $2, $3 );
			$data{$prog_type}{type} = 'Nokia N95 h.264 low quality 3G stream';
			$opt->{quiet} = 1 if $opt->{streaminfo};
			chomp( $data{$prog_type}{streamurl} = main::request_url_retry($ua, $data{$prog_type}{href}, 2, '', '') );
			$opt->{quiet} = 0 if $opt->{streaminfo};
		}
		
		# Mobile WMV DRM
		#<media kind="video"
		#        expires="2008-10-20T21:59:00+01:00"
		#        type="video/wmv"   >
		#        <connection
		#                priority="10"
		#                kind="licence"
		#                server="http://iplayldsvip.iplayer.bbc.co.uk/WMLicenceIssuer/LicenceDelivery.asmx"
		#                identifier="0A1CA43B-98A8-43EA-B684-DA06672C0575"
		#                href="http://iplayldsvip.iplayer.bbc.co.uk/WMLicenceIssuer/LicenceDelivery.asmx/0A1CA43B-98A8-43EA-B684-DA06672C0575"
		#        />
		#<connection
		#                priority="10"
		#                kind="sis"
		#                server="http://directdl.iplayer.bbc.co.uk/windowsmedia/"
		#                identifier="AmazonwithBruceParry_Episode5_200810132100_mobile"
		#                href="http://directdl.iplayer.bbc.co.uk/windowsmedia/AmazonwithBruceParry_Episode5_200810132100_mobile.wmv"
		#        />
		#</media>
		if ( $media =~ /^(mobile|all)$/ && $xml =~ m{<media\s+kind="video".+?type="video/wmv".+?kind="sis"\s+server="(.+?)"\s+?identifier="(.+?)"\s+?href="(http.+?)"} ) {
			$prog_type = 'mobile';
			main::logger "DEBUG: Processing $prog_type stream\n" if $opt->{verbose};
			( $data{$prog_type}{server}, $data{$prog_type}{identifier}, $data{$prog_type}{streamurl} ) = ( $1, $2, $3 );
			$data{$prog_type}{type} = 'Mobile WMV DRM stream';
		}
		
		# Audio rtmp aac
		# <media kind="audio"
		#        expires="2009-02-20T07:02:00+00:00"
		#        type="audio/mp4"
		#        encoding="aac"  >
		#        <connection
		#                priority="10"
		#                kind="akamai"
		#                server="cp48185.edgefcs.net"
		#                identifier="mp4:radio3/RBN2_radio_3_-_friday_0100_b00hgdss_2009_02_13_07_50_29"
		#                authString="dbEbUbHc5aBbNbodoadaXbYd1anboa1bOcd-bjLHLn-cCp-d0i_-HooFHnDoOCrHrwF"
		#        />
		# </media>
		#app: ondemand?_fcs_vhost=cp48181.edgefcs.net&auth=daEasducLbidOancObacmc0amd6d7ana8c6-bjx.9v-cCp-JqlFHoEq.FBqGnxC&aifp=v001&slist=secure/radio1/RBN2_radio_1_-_wednesday_1000_b00g3xcj_2008_12_31_13_21_49
		#swfUrl: http://www.bbc.co.uk/emp/9player.swf?revision=7276
		#tcUrl: rtmp://92.122.210.173:1935/ondemand?_fcs_vhost=cp48181.edgefcs.net&auth=daEasducLbidOancObacmc0amd6d7ana8c6-bjx.9v-cCp-JqlFHoEqFBqGnxC&aifp=v001&slist=secure/radio1/RBN2_radio_1_-_wednesday_1.000_b00g3xcj_2008_12_31_13_21_49
		#pageUrl: http://www.bbc.co.uk/iplayer/episode/b00g3xp7/Annie_Mac_31_12_2008/
		if ( $media =~ /^(flashaac|all)$/ && $xml =~ m{<media\s+kind="audio".+?type="audio/mp4".+?encoding="aac".+?kind="akamai"\s+server="(.+?)"\s+?identifier="(.+?)"\s+?authString="(.+?)"} ) {
			$prog_type = 'flashaac';
			main::logger "DEBUG: Processing $prog_type stream\n" if $opt->{verbose};
			( $data{$prog_type}{server}, $data{$prog_type}{identifier}, $data{$prog_type}{authstring} ) = ( $1, $2, $3 );
			$data{$prog_type}{streamurl} = "rtmp://$data{$prog_type}{server}:1935/bbciplayertok?_fcs_vhost=$data{$prog_type}{server}&auth=$data{$prog_type}{authstring}&aifp=v001&slist=$data{$prog_type}{identifier}";
			# Remove offending mp3: at the start of the identifier (don't remove in stream url)
			$data{$prog_type}{identifier} =~ s/^mp4://;
			$data{$prog_type}{application} = "bbciplayertok?_fcs_vhost=$data{$prog_type}{server}&auth=$data{$prog_type}{authstring}&aifp=v001&slist=$data{$prog_type}{identifier}";
			$data{$prog_type}{type} = 'RTMP AAC stream';
			$data{$prog_type}{tcurl} = "rtmp://$data{$prog_type}{server}:1935/$data{$prog_type}{application}";
			$data{$prog_type}{swfurl} = "http://www.bbc.co.uk/emp/9player.swf?revision=7276";
		}

		# Audio rtmp mp3
		#<media kind="audio"
		#        type="audio/mpeg"
		#        encoding="mp3"  >
		#        <connection
		#                priority="10"
		#                kind="akamai"
		#                server="cp48181.edgefcs.net"
		#                identifier="mp3:secure/radio1/RBN2_mashup_b00d67h9_2008_09_05_22_14_25"
		#                authString="daEbQa1c6cda6aHdudxagcCcUcVbvbncmdK-biXtzq-cCp-DnoFIpznNBqHnzF"
		#        />
		#</media>
		#app: ondemand?_fcs_vhost=cp48181.edgefcs.net&auth=daEasducLbidOancObacmc0amd6d7ana8c6-bjx.9v-cCp-JqlFHoEq.FBqGnxC&aifp=v001&slist=secure/radio1/RBN2_radio_1_-_wednesday_1000_b00g3xcj_2008_12_31_13_21_49
		#swfUrl: http://www.bbc.co.uk/emp/9player.swf?revision=7276
		#tcUrl: rtmp://92.122.210.173:1935/ondemand?_fcs_vhost=cp48181.edgefcs.net&auth=daEasducLbidOancObacmc0amd6d7ana8c6-bjx.9v-cCp-JqlFHoEqFBqGnxC&aifp=v001&slist=secure/radio1/RBN2_radio_1_-_wednesday_1.000_b00g3xcj_2008_12_31_13_21_49
		#pageUrl: http://www.bbc.co.uk/iplayer/episode/b00g3xp7/Annie_Mac_31_12_2008/
		if ( $media =~ /^(flashaudio|all)$/ && $xml =~ m{<media\s+kind="audio".+?type="audio/mpeg".+?encoding="mp3".+?kind="akamai"\s+server="(.+?)"\s+?identifier="(.+?)"\s+?authString="(.+?)"} ) {
			$prog_type = 'flashaudio';
			main::logger "DEBUG: Processing $prog_type stream\n" if $opt->{verbose};
			( $data{$prog_type}{server}, $data{$prog_type}{identifier}, $data{$prog_type}{authstring} ) = ( $1, $2, $3 );
			$data{$prog_type}{streamurl} = "rtmp://$data{$prog_type}{server}:1935/bbciplayertok?_fcs_vhost=$data{$prog_type}{server}&auth=$data{$prog_type}{authstring}&aifp=v001&slist=$data{$prog_type}{identifier}";
			# Remove offending mp3: at the start of the identifier (don't remove in stream url)
			$data{$prog_type}{identifier} =~ s/^mp3://;
			$data{$prog_type}{application} = "bbciplayertok?_fcs_vhost=$data{$prog_type}{server}&auth=$data{$prog_type}{authstring}&aifp=v001&slist=$data{$prog_type}{identifier}";
			$data{$prog_type}{type} = 'RTMP MP3 stream';
			$data{$prog_type}{tcurl} = "rtmp://$data{$prog_type}{server}:1935/$data{$prog_type}{application}";
			$data{$prog_type}{swfurl} = "http://www.bbc.co.uk/emp/9player.swf?revision=7276";
		}
		
		# RealAudio stream
		#<media kind="audio"
		#       type="audio/real"
		#        encoding="real"  >
		#        <connection
		#                priority="10"
		#                kind="sis"
		#                server="http://www.bbc.co.uk"
		#                identifier="/radio/aod/playlists/9h/76/d0/0b/2000_bbc_radio_one"
		#                href="http://www.bbc.co.uk/radio/aod/playlists/9h/76/d0/0b/2000_bbc_radio_one.ram"
		#        />
		#</media>
		# Realaudio for worldservice	
		#<media kind=""
		#type="audio/real"
		#encoding="real"  >
		#<connection
		#        priority="10"
		#        kind="edgesuite"
		#        server="http://http-ws.bbc.co.uk.edgesuite.net"
		#        identifier="/generatecssram.esi?file=/worldservice/css/nb/410060838.ra"
		#        href="http://http-ws.bbc.co.uk.edgesuite.net/generatecssram.esi?file=/worldservice/css/nb/410060838.ra"
		#/>
		#</media>
		#</mediaSelection>
		if ( $media =~ /^(realaudio|all)$/ && $xml =~ m{<media\s+kind="(audio|)".+?type="audio/real".+?encoding="real".+?kind="(sis|edgesuite)"\s+server="(.+?)"\s+?identifier="(.+?)"\s+?href="(http.+?)"} ) {
			$prog_type = 'realaudio';
			main::logger "DEBUG: Processing $prog_type stream\n" if $opt->{verbose};
			( $data{$prog_type}{server}, $data{$prog_type}{identifier}, $data{$prog_type}{href} ) = ( $3, $4, $5 );
			$data{$prog_type}{type} = 'RealAudio RTSP stream';
			$opt->{quiet} = 1 if $opt->{streaminfo};
			chomp( $data{$prog_type}{streamurl} = main::request_url_retry($ua, $data{$prog_type}{href}, 2, '', '') );
			$data{$prog_type}{streamurl} =~ s/[\s\n]//g;
			$opt->{quiet} = 0 if $opt->{streaminfo};
		}
		
		# Radio WMA (low quality)
		#<mediaSelection xmlns="http://bbc.co.uk/2008/mp/mediaselection">
		#<media kind=""
		#        type="audio/wma"
		#        encoding="wma"  >
		#        <connection
		#                priority="10"
		#                kind="edgesuite"
		#                server="http://http-ws.bbc.co.uk.edgesuite.net"
		#                identifier="/generatecssasx.esi?file=/worldservice/css/nb/410060838"
		#                href="http://http-ws.bbc.co.uk.edgesuite.net/generatecssasx.esi?file=/worldservice/css/nb/410060838.wma"
		#        />
		#</media>
		if ( $media =~ /^(wma|all)$/ && $xml =~ m{<media\s+kind="(audio|)".+?type="audio/wma".+?encoding="wma".+?kind="(sis|edgesuite)"\s+server="(.+?)"\s+?identifier="(.+?)"\s+?href="(http.+?)"} ) {
			$prog_type = 'wma';
			main::logger "DEBUG: Processing $prog_type stream\n" if $opt->{verbose};
			( $data{$prog_type}{server}, $data{$prog_type}{identifier}, $data{$prog_type}{href} ) = ( $3, $4, $5 );
			$data{$prog_type}{type} = 'WMA MMS stream';
			$opt->{quiet} = 1 if $opt->{streaminfo};
			chomp( $data{$prog_type}{streamurl} = main::request_url_retry($ua, $data{$prog_type}{href}, 2, '', '') );
			$data{$prog_type}{streamurl} =~ s/[\s\n]//g;
			# HREF="mms://a1899.v394403.c39440.g.vm.akamaistream.net/7/1899/39440/1/bbcworldservice.download.akamai.com/39440//worldservice/css/nb/410060838.wma"
			$data{$prog_type}{streamurl} =~ s/^.*href=\"(.+?)\".*$/$1/gi;
			$opt->{quiet} = 0 if $opt->{streaminfo};
		}
		
		# Subtitles stream
		#<media kind="captions"
		#        type="application/ttaf+xml"   >
		#        <connection
		#                priority="10"
		#                kind="http"
		#                server="http://www.bbc.co.uk/iplayer/subtitles/"
		#                identifier="b0008dc8rstreaming89808204.xml"
		#                href="http://www.bbc.co.uk/iplayer/subtitles/b0008dc8rstreaming89808204.xml"
		#        />
		#</media>
		if ( $media =~ /^(subtitles|all)$/ && $xml =~ m{<media\s+kind="captions".+?type="application/ttaf\+xml".+?kind="http"\s+server="(.+?)"\s+?identifier="(.+?)"\s+?href="(http.+?)"} ) {
			$prog_type = 'subtitles';
			main::logger "DEBUG: Processing $prog_type stream\n" if $opt->{verbose};
			( $data{$prog_type}{server}, $data{$prog_type}{identifier}, $data{$prog_type}{streamurl} ) = ( $1, $2, $3 );
			$data{$prog_type}{type} = 'Subtitles stream';
		}	
	}
	# Do iphone redirect check regardless of an xml entry for iphone - sometimes the iphone streams exist regardless
	if ( my $streamurl = Streamer::iphone->get_url($ua, $verpid) ) {
		my $prog_type = 'iphone';
		$data{$prog_type}{type} = 'iPhone stream';
		# Get iphone redirect
		$data{$prog_type}{streamurl} = $streamurl;
	} else {
		main::logger "DEBUG: No iphone redirect stream\n" if $opt->{verbose};
	}

	# Return a hash with media => url if 'all' is specified - otherwise just the specified url
	if ( $media eq 'all' ) {
		return %data;
	} else {
		# Make sure this hash exists before we pass it back...
		$data{$media}{exists} = 0 if not defined $data{$media};
		return $data{$media};
	}
}





################### TV class #################
package Programme::tv;

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
use Time::Local;
use URI;

# Inherit from Programme class
use base 'Programme::bbciplayer';

# Class vars
sub index_min { return 1 }
sub index_max { return 9999 }
sub channels {
	return {
		'bbc_one'			=> 'tv|BBC One',
		'bbc_two'			=> 'tv|BBC Two',
		'bbc_three'			=> 'tv|BBC Three',
		'bbc_four'			=> 'tv|BBC Four',
		'cbbc'				=> 'tv|CBBC',
		'cbeebies'			=> 'tv|CBeebies',
		'bbc_news24'			=> 'tv|BBC News 24',
		'bbc_parliament'		=> 'tv|BBC Parliament',
		'bbc_one_northern_ireland'	=> 'tv|BBC One Northern Ireland',
		'bbc_one_scotland'		=> 'tv|BBC One Scotland',
		'bbc_one_wales'			=> 'tv|BBC One Wales',
		'bbc_webonly'			=> 'tv|BBC Web Only',
		'bbc_hd'			=> 'tv|BBC HD',
		'bbc_alba'			=> 'tv|BBC Alba',
		'categories/news/tv'		=> 'tv|BBC News',
		'categories/sport/tv'		=> 'tv|BBC Sport',
	#	'categories/tv'			=> 'tv|All',
		'categories/signed'		=> 'tv|Signed',
	};
}


# Class cmdline Options
sub opt_format {
	return {
		n95		=> [ 0, "n95", '', '', ""],
		outputtv	=> [ 1, "outputtv=s", 'Output', '--outputtv <dir>', "Download output directory for tv"],
		vlc		=> [ 0, "vlc=s", 'External Program', '--vlc <path>', "Location of vlc or cvlc binary"],
	};
}



# Method to return optional list_entry format
sub optional_list_entry_format {
	my $prog = shift;
	return ", $prog->{channel}, $prog->{categories}, $prog->{versions}";
}



# Returns the modes to try for this prog type
sub modelist {
	my $prog = shift;
	my $modelist;
	
	# Deal with BBC TV fallback modes
	# Valid modes are iphone,rtmp,flashhigh,flashnormal,flashlow,n95_wifi
	# 'rtmp' or 'flash' => 'flashhigh,flashnormal'
	my @modes = split /,/, $opt->{vmode};
	for (@modes) {
		$_ = 'flashhigh,flashnormal' if $_ eq 'rtmp' || $_ eq 'flash';
	}
	$opt->{vmode} = join ',', @modes;
	# Defaults
	if ( $opt->{vmode} eq 'auto' || ! $opt->{vmode} ) {
		if ( ! main::exists_in_path($rtmpdump) ) {
			main::logger "WARNING: Not using flash modes since rtmpdump is not found\n" if $opt->{verbose};
			$modelist = 'iphone';	
		} else {
			$modelist = 'iphone,flashhigh,flashnormal';
		}
	} else {
		$modelist = $opt->{vmode};
	}
	return $modelist;
}



# Cleans up a pid and removes url parts that might be specified
sub clean_pid {
	my $prog = shift;
	# extract b??????? format
	$prog->{pid} = $1 if $prog->{pid} =~ m{(b\w{7})};
}



# Usage: Programme::tv->get_links( \%prog, 'tv' );
# Uses: %{ channels() }, \%prog
sub get_links {
	shift; # ignore obj ref
	my $progref = shift;
	my $prog_type = shift;
	# Hack to get correct 'channels' method because this methods is being shared with Programme::radio
	my %channels = %{ main::progclass($prog_type)->channels() };

	my $xml;
	my $feed_data;
	my $res;
	main::logger "INFO: Getting $prog_type Index Feeds\n";
	# Setup User agent
	my $ua = main::create_ua('desktop');

	# Download index feed
	# Sort feeds so that category based feeds are done last - this makes sure that the channels get defined correctly if there are dups
	my @channel_list;
	push @channel_list, grep !/categor/, keys %channels;
	push @channel_list, grep  /categor/, keys %channels;
	for ( @channel_list ) {

		my $url = "${channel_feed_url}/$_/list/limit/400";
		main::logger "DEBUG: Getting feed $url\n" if $opt->{verbose};
		$xml = main::request_url_retry($ua, $url, 3, '.', "WARNING: Failed to get programme index feed for $_ from iplayer site\n");
		main::logger "INFO: Got ".(grep /<entry/, split /\n/, $xml)." programmes\n" if $opt->{verbose};
		decode_entities($xml);	
		
		# Feed as of August 2008
		#	 <entry>
		#	   <title type="text">Bargain Hunt: Series 18: Oswestry</title>
		#	   <id>tag:feeds.bbc.co.uk,2008:PIPS:b0088jgs</id>
		#	   <updated>2008-07-22T00:23:50Z</updated>
		#	   <content type="html">
		#	     &lt;p&gt;
		#	       &lt;a href=&quot;http://www.bbc.co.uk/iplayer/episode/b0088jgs?src=a_syn30&quot;&gt;
		#		 &lt;img src=&quot;http://www.bbc.co.uk/iplayer/images/episode/b0088jgs_150_84.jpg&quot; alt=&quot;Bargain Hunt: Series 18: Oswestry&quot; /&gt;
		#	       &lt;/a&gt;
		#	     &lt;/p&gt;
		#	     &lt;p&gt;
		#	       The teams are at an antiques fair in Oswestry showground. Hosted by Tim Wonnacott.
		#	     &lt;/p&gt;
		#	   </content>
		#	   <category term="Factual" />
		#	   <category term="TV" />
		#	   <link rel="via" href="http://www.bbc.co.uk/iplayer/episode/b0088jgs?src=a_syn30" type="text/html" title="Bargain Hunt: Series 18: Oswestry" />
		#       </entry>
		#

		### New Feed
		#  <entry>
		#    <title type="text">House of Lords: 02/07/2008</title>
		#    <id>tag:bbc.co.uk,2008:PIPS:b00cd5p7</id>
		#    <updated>2008-06-24T00:15:11Z</updated>
		#    <content type="html">
		#      <p>
		#	<a href="http://www.bbc.co.uk/iplayer/episode/b00cd5p7?src=a_syn30">
		#	  <img src="http://www.bbc.co.uk/iplayer/images/episode/b00cd5p7_150_84.jpg" alt="House of Lords: 02/07/2008" />
		#	</a>
		#      </p>
		#      <p>
		#	House of Lords, including the third reading of the Health and Social Care Bill. 1 July.
		#      </p>
		#    </content>
		#    <category term="Factual" scheme="urn:bbciplayer:category" />
		#    <link rel="via" href="http://www.bbc.co.uk/iplayer/episode/b00cd5p7?src=a_syn30" type="application/atom+xml" title="House of Lords: 02/07/2008">
		#    </link>
		#  </entry>

		# Parse XML

		# get list of entries within <entry> </entry> tags
		my @entries = split /<entry>/, $xml;
		# Discard first element == header
		shift @entries;

		my ( $name, $episode, $desc, $pid, $available, $channel, $duration, $thumbnail, $prog_type, $versions );
		foreach my $entry (@entries) {

			my $entry_flat = $entry;
			$entry_flat =~ s/\n/ /g;

			# <id>tag:bbc.co.uk,2008:PIPS:b008pj3w</id>
			$pid = $1 if $entry =~ m{<id>.*PIPS:(.+?)</id>};

			# parse name: episode, e.g. Take a Bow: Street Feet on the Farm
			$name = $1 if $entry =~ m{<title\s*.*?>\s*(.*?)\s*</title>};
			$episode = $name;
			$name =~ s/^(.*): .*$/$1/g;
			$episode =~ s/^.*: (.*)$/$1/g;

			# This is not the availability!
			# <updated>2008-06-22T05:01:49Z</updated>
			#$available = Programme::get_available_time_string( $1 ) if $entry =~ m{<updated>(\d{4}\-\d\d\-\d\dT\d\d:\d\d:\d\d.).*?</updated>};

			#<p>    House of Lords, including the third reading of the Health and Social Care Bill. 1 July.   </p>    </content>
			$desc = $1 if $entry =~ m{<p>\s*(.*?)\s*</p>\s*</content>};

			# Parse the categories into hash
			# <category term="Factual" />
			my @category;
			for my $line ( grep /<category/, (split /\n/, $entry) ) {
				push @category, $1 if $line =~ m{<category\s+term="(.+?)"};
			}

			# Extract channel and type
			($prog_type, $channel) = (split /\|/, $channels{$_})[0,1];

			main::logger "DEBUG: '$pid, $name - $episode, $channel'\n" if $opt->{debug};

			# Merge and Skip if this pid is a duplicate
			if ( defined $progref->{$pid} ) {
				main::logger "WARNING: '$pid, $progref->{$pid}->{name} - $progref->{$pid}->{episode}, $progref->{$pid}->{channel}' already exists (this channel = $channel)\n" if $opt->{verbose};
				# Since we use the 'Signed' channel to get sign zone data, merge the categories from this entry to the existing entry
				if ( $progref->{$pid}->{categories} ne join(',', @category) ) {
					my %cats;
					$cats{$_} = 1 for ( split /,/, $progref->{$pid}->{categories} );
					$cats{$_} = 1 for ( @category );
					main::logger "INFO: Merged categories for $pid from $progref->{$pid}->{categories} to ".join(',', sort keys %cats)."\n" if $opt->{verbose};
					$progref->{$pid}->{categories} = join(',', sort keys %cats);
				}
				# If this is a dupicate pid and the channel is now Signed then both versions are available
				$progref->{$pid}->{versions} = 'default,signed' if $channel eq 'Signed';
				next;
			}

			# Check for signed-only version from Channel
			if ($channel eq 'Signed') {
				$versions = 'signed';
			# Else if not channel 'Signed' then this must also have both versions available
			} elsif ( grep /Sign Zone/, @category ) {
				$versions = 'default,signed';
			} else {
				$versions = 'default';
			}
			
			# build data structure
			$progref->{$pid} = main::progclass($prog_type)->new(
				'pid'		=> $pid,
				'name'		=> $name,
				'versions'	=> $versions,
				'episode'	=> $episode,
				'desc'		=> $desc,
				'guidance'	=> ' ',
				'available'	=> 'Unknown',
				'duration'	=> 'Unknown',
				'thumbnail'	=> "${thumbnail_prefix}/${pid}_150_84.jpg",
				'channel'	=> $channel,
				'categories'	=> join(',', @category),
				'type'		=> $prog_type,
				'web'		=> "${bbc_prog_page_prefix}/${pid}.html",
			);
		}
	}
	main::logger "\n";
	return 0;
}



# Usage: download (<prog>, <ua>)
sub download {
	my $prog = shift;
	my $ua = shift; 
	my $mode = shift;
	my %version_pids;
	my %streamdata;
	my $url_2;
	my $got_url;

	# Look up version pids
	%version_pids = $prog->get_version_pids( $ua );

	# if %version_pids is empty then skip this programme download attempt
	if ( (keys %version_pids) == 0 ) {
		return 'skip';
	}

	# Check if we have vlc - if not use iPhone mode
	if ( $opt->{vmode} eq 'n95' && (! main::exists_in_path($vlc)) ) {
		main::logger "\nWARNING: Required $vlc does not exist\n";
		return 'next';
	}		
	# if rtmpdump does not exist
	if ( $mode =~ /^(rtmp|flash)/ && ! main::exists_in_path($rtmpdump)) {
		main::logger "WARNING: Required program $rtmpdump does not exist (see http://linuxcentre.net/getiplayer/installation and http://linuxcentre.net/getiplayer/download)\n";
		return 'next';
	}
	# Force raw mode if ffmpeg is not installed
	if ( $mode =~ /^(flash|rtmp)/ && ! main::exists_in_path($ffmpeg)) {
		main::logger "\nWARNING: $ffmpeg does not exist - not converting flv file\n";
		$opt->{raw} = 1;
	}

	$prog->{ext} = 'mov';
	# Lookup table to determine which ext to use for different download methods
	my %stream_ext = (
		iphone		=> 'mov',
		flashhigh 	=> 'mp4',
		flashnormal	=> 'avi',
		flashlow	=> 'avi',
		n95_wifi	=> '3gp',
		n95_3g		=> '3gp',
	);
	$prog->{ext} = $stream_ext{$mode} if not $opt->{raw};
	$prog->{ext} = 'flv' if $mode =~ /^(flash|rtmp)/ && $opt->{raw};

	# Do this for each version tried in this order (if they appeared in the content)
	# Order with which to search for programme versions (can be overridden by --versionlist option)
	my @version_search_list	= qw/ default original signed audiodescribed opensubtitled shortened lengthened other /;
	@version_search_list 	= split /,/, $opt->{versionlist} if $opt->{versionlist};
	for my $version ( @version_search_list ) {

		# Change $verpid to 'default' type if it exists, then Used 'signed' otherwise
		if ( $version_pids{$version} ) {
			main::logger "INFO: Checking existence of $version version\n";
			$prog->{version} = $version;
			main::logger "INFO: Version = $prog->{version}\n" if $opt->{verbose};
			# Try to get stream data
			%streamdata = %{ $prog->get_stream_data( $version_pids{ $prog->{version} }, $mode) };
			$url_2 = $streamdata{streamurl};
		}
		# Break out of loop if we have an actual URL
		last if $url_2;
	}

	# Display media stream data if required
	if ( $opt->{streaminfo} ) {
		main::display_stream_info( $prog, $version_pids{ $prog->{version} }, 'all' );
		$opt->{quiet} = 1;
		return 'skip';
	}

	# Report error if no versions are available
	if ( ! $url_2 ) {
		main::logger "\nWARNING: No $mode versions available\n";
		return 'next';
	}

	# Determine the correct filenames for this download
	if ( $prog->generate_filenames( "<longname> - <episode> <pid> <version>" ) ) {
		# Create symlink if required
		$prog->create_symlink( $prog->{symlink}, $prog->{filename}) if $opt->{symlink};
		return 'skip';
	}
	
	# Skip from here if we are only testing downloads
	return 'skip' if $opt->{test};

	# Get subtitles if they exist and are required 
	# best to do this before d/l of file so that the subtitles can be enjoyed while download progresses
	my $subfile_done;
	my $subfile;
	if ( $opt->{subtitles} ) {
		$subfile_done = "$prog->{dir}/$prog->{fileprefix}.srt";
		$subfile = "$prog->{dir}/$prog->{fileprefix}.partial.srt";
		$ua->proxy( ['http'] => undef ) if $opt->{partialproxy};
		$prog->download_subtitles( $ua, $subfile, $version_pids{ $prog->{version} } );
		$ua->proxy( ['http'] => $opt->{proxy} ) if $opt->{partialproxy};
	}

	my $return;
	# Do rtmp download
	if ( $mode =~ /^(rtmp|flash)/ ) {
		my $stream = Streamer::rtmp->new;
		$return = $stream->get( $ua, $streamdata{streamurl}, $prog, $mode, $streamdata{application}, $streamdata{tcurl}, $streamdata{authstring}, $streamdata{swfurl} );

	# Do the N95 h.264 download
	} elsif ( $mode =~ /^n95/ ) {
		my $stream = Streamer::3gp->new;
		$return = $stream->get( $ua, $url_2, $prog, $mode );

	# Do the iPhone h.264 download
	} else {
		my $stream = Streamer::iphone->new();
		# Disable proxy here if required
		$ua->proxy( ['http'] => undef ) if $opt->{partialproxy};
		$return = $stream->get( $ua, $url_2, $prog, 1 );
		# Re-enable proxy here if required
		$ua->proxy( ['http'] => $opt->{proxy} ) if $opt->{partialproxy};
	}
	
	# Rename the subtitle file accordingly
	move($subfile, $subfile_done) if $opt->{subtitles} && -f $subfile;

	return $return;
}


# BBC iPlayer TV
# Download Subtitles, convert to srt(SubRip) format and apply time offset
# Todo: get the subtitle streamurl before this...
sub download_subtitles {
	my $prog = shift;
	my ( $ua, $file, $verpid ) = @_;
	my $suburl;
	my $subs;
	main::logger "INFO: Getting Subtitle metadata for $verpid\n" if $opt->{verbose};
	$suburl = %{ Programme::bbciplayer->get_stream_data( $verpid, 'subtitles') }->{streamurl};
	# Return if we have no url
	if (! $suburl) {
		main::logger "\nINFO: Subtitles not available\n";
		return 2;
	}

	main::logger "\nINFO: Getting Subtitles from $suburl\n" if $opt->{verbose};

	# Open subs file
	unlink($file);
	my $fh = main::open_file_append($file);

	# Download subs
	$subs = main::request_url_retry($ua, $suburl, 2);
	if (! $subs ) {
		main::logger "\nERROR: Subtitle Download failed\n";
		return 1;
	} else {
		main::logger "\nINFO: Downloaded Subtitles\n";
	}

	# Convert the format to srt
	# SRT:
	#1
	#00:01:22,490 --> 00:01:26,494
	#Next round!
	#
	#2
	#00:01:33,710 --> 00:01:37,714
	#Now that we've moved to paradise, there's nothing to eat.
	#
	
	# TT:
	#<p begin="0:01:12.400" end="0:01:13.880">Thinking.</p>
	#<p begin="00:01:01.88" id="p15" end="00:01:04.80"><span tts:color="cyan">You're thinking of Hamburger Hill...<br /></span>Since we left...</p>
	#<p begin="00:00:18.48" id="p0" end="00:00:20.52">APPLAUSE AND CHEERING</p>
	my $count = 1;
	my @lines = grep /<p\s.*begin=/, split /\n/, $subs;
	for ( @lines ) {
		my ( $begin, $end, $sub );
		# Remove span elements
		s|<\/?span.*?>||g;
		# Remove <br /> elements
		s|<br.*?>||g;
		( $begin, $end, $sub ) = ( $1, $2, $3 ) if m{<p\s+.*begin="(.+?)".+end="(.+?)".*?>(.+?)<\/p>};
		if ($begin && $end && $sub ) {
			$begin =~ s/\./,/g;
			$end =~ s/\./,/g;
			if ($opt->{suboffset}) {
				$begin = main::subtitle_offset( $begin, $opt->{suboffset} );
				$end = main::subtitle_offset( $end, $opt->{suboffset} );
			}
			decode_entities($sub);
			# Write to file
			print $fh "$count\n";
			print $fh "$begin --> $end\n";
			print $fh "$sub\n\n";
			$count++;
		}
	}	
	close $fh;

	return 0;
}



################### Radio class #################
package Programme::radio;

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
use Time::Local;
use URI;

# Inherit from Programme class
use base 'Programme::bbciplayer';

# Class vars
sub index_min { return 10001 }
sub index_max { return 19999 };
sub channels {
	return {
		'bbc_1xtra'				=> 'radio|BBC 1Xtra',
		'bbc_radio_one'				=> 'radio|BBC Radio 1',
		'bbc_radio_two'				=> 'radio|BBC Radio 2',
		'bbc_radio_three'			=> 'radio|BBC Radio 3',
		'bbc_radio_four'			=> 'radio|BBC Radio 4',
		'bbc_radio_five_live'			=> 'radio|BBC Radio 5 live',
		'bbc_radio_five_live_sports_extra'	=> 'radio|BBC 5 live Sports Extra',
		'bbc_6music'				=> 'radio|BBC 6 Music',
		'bbc_7'					=> 'radio|BBC 7',
		'bbc_asian_network'			=> 'radio|BBC Asian Network',
		'bbc_radio_foyle'			=> 'radio|BBC Radio Foyle',
		'bbc_radio_scotland'			=> 'radio|BBC Radio Scotland',
		'bbc_radio_nan_gaidheal'		=> 'radio|BBC Radio Nan Gaidheal',
		'bbc_radio_ulster'			=> 'radio|BBC Radio Ulster',
		'bbc_radio_wales'			=> 'radio|BBC Radio Wales',
		'bbc_radio_cymru'			=> 'radio|BBC Radio Cymru',
		'bbc_world_service'			=> 'radio|BBC World Service',
#		'categories/radio'			=> 'radio|All',
		'bbc_radio_cumbria'			=> 'radio|BBC Cumbria',
		'bbc_radio_newcastle'			=> 'radio|BBC Newcastle',
		'bbc_tees'				=> 'radio|BBC Tees',
		'bbc_radio_lancashire'			=> 'radio|BBC Lancashire',
		'bbc_radio_merseyside'			=> 'radio|BBC Merseyside',
		'bbc_radio_manchester'			=> 'radio|BBC Manchester',
		'bbc_radio_leeds'			=> 'radio|BBC Leeds',
		'bbc_radio_sheffield'			=> 'radio|BBC Sheffield',
		'bbc_radio_york'			=> 'radio|BBC York',
		'bbc_radio_humberside'			=> 'radio|BBC Humberside',
		'bbc_radio_lincolnshire'		=> 'radio|BBC Lincolnshire',
		'bbc_radio_nottingham'			=> 'radio|BBC Nottingham',
		'bbc_radio_leicester'			=> 'radio|BBC Leicester',
		'bbc_radio_derby'			=> 'radio|BBC Derby',
		'bbc_radio_stoke'			=> 'radio|BBC Stoke',
		'bbc_radio_shropshire'			=> 'radio|BBC Shropshire',
		'bbc_wm'				=> 'radio|BBC WM',
		'bbc_radio_coventry_warwickshire'	=> 'radio|BBC Coventry &amp; Warwickshire',
		'bbc_radio_hereford_worcester'		=> 'radio|BBC Hereford &amp; Worcester',
		'bbc_radio_northampton'			=> 'radio|BBC Northampton',
		'bbc_three_counties_radio'		=> 'radio|BBC Three Counties',
		'bbc_radio_cambridge'			=> 'radio|BBC Cambridgeshire',
		'bbc_radio_norfolk'			=> 'radio|BBC Norfolk',
		'bbc_radio_suffolk'			=> 'radio|BBC Suffolk',
		'bbc_radio_essex'			=> 'radio|BBC Essex',
		'bbc_london'				=> 'radio|BBC London',
		'bbc_radio_kent'			=> 'radio|BBC Kent',
		'bbc_southern_counties_radio'		=> 'radio|BBC Southern Counties',
		'bbc_radio_oxford'			=> 'radio|BBC Oxford',
		'bbc_radio_berkshire'			=> 'radio|BBC Berkshire',
		'bbc_radio_solent'			=> 'radio|BBC Solent',
		'bbc_radio_gloucestershire'		=> 'radio|BBC Gloucestershire',
		'bbc_radio_swindon'			=> 'radio|BBC Swindon',
		'bbc_radio_wiltshire'			=> 'radio|BBC Wiltshire',
		'bbc_radio_bristol'			=> 'radio|BBC Bristol',
		'bbc_radio_somerset_sound'		=> 'radio|BBC Somerset',
		'bbc_radio_devon'			=> 'radio|BBC Devon',
		'bbc_radio_cornwall'			=> 'radio|BBC Cornwall',
		'bbc_radio_guernsey'			=> 'radio|BBC Guernsey',
		'bbc_radio_jersey'			=> 'radio|BBC Jersey',
	};
}


# Class cmdline Options
sub opt_format {
	return {
		bandwidth 	=> [ 1, "bandwidth=n", 'Download', '--bandwidth', "In radio realaudio mode specify the link bandwidth in bps for rtsp streaming (default 512000)"],
		lame		=> [ 0, "lame=s", 'External Program', '--lame <path>', "Location of lame binary"],
		outputradio	=> [ 1, "outputradio=s", 'Output', '--outputradio <dir>', "Download output directory for radio"],
		realaudio	=> [ 0, "realaudio", '', '', ""],
		wav		=> [ 1, "wav", 'Download', '--wav', "In radio realaudio mode output as wav and don't transcode to mp3"],
	};
}



# Method to return optional list_entry format
sub optional_list_entry_format {
	my $prog = shift;
	return ", $prog->{channel}, $prog->{categories}";
}



# Returns the modes to try for this prog type
sub modelist {
	my $prog = shift;
	my $modelist;
	
	# Deal with radio fallback modes
	# Valid modes are mp3|iphone,flash|rtmp,real|ra
	# Defaults
	if ( $opt->{amode} eq 'auto' || ! $opt->{amode} ) {
		if ( ! main::exists_in_path($rtmpdump) ) {
			main::logger "WARNING: Not using flash modes since rtmpdump is not found\n" if $opt->{verbose};
			$modelist = 'iphone,real';
		} else {
			$modelist = 'iphone,flashaac,flashaudio,real';
		}
	} else {
		$modelist = $opt->{amode};
	}
	return $modelist;
}



# Cleans up a pid and removes url parts that might be specified
sub clean_pid {
	my $prog = shift;
	# extract [bbw]??????? format - remove surrounding url
	$prog->{pid} =~ s/^.+\/([bpw]\w{7})(\..+)?$/$1/g;
}



sub get_links {
	shift;
	# Delegate to Programme::tv (same function is used)
	return Programme::tv->get_links(@_);
}


sub download {
	my $prog = shift;
	my $ua = shift; 
	my $mode = shift;
	my %version_pids;
	
	# Look up version pids
	%version_pids = $prog->get_version_pids( $ua );

	# if %version_pids is empty then skip this programme download attempt
	if ( (keys %version_pids) == 0 ) {
		return 'skip';
	}

	# This will always be the pid version for radio
	$prog->{version} = 'default';
	# Display media stream data if required
	if ( $opt->{streaminfo} ) {
		main::display_stream_info( $prog, $version_pids{default}, 'all' );
		$opt->{quiet} = 1;
		return 'skip';
	}

	# RealAudio
	if ( $mode =~ /^(real|ra)/ ) {
		return $prog->download_realaudio( $ua, \%version_pids );

	# FlashAudio/FlashAAC
	} elsif ( $mode =~ /^flash/ ) {
		return $prog->download_rtmp( $ua, $mode, \%version_pids );

	# iPhone
	} elsif ( $mode =~ /^(iphone|mp3)/ ) {
		return $prog->download_iphone( $ua, \%version_pids );
	}
}



sub download_realaudio {
	my $prog = shift;
	my $ua = shift; 
	my %version_pids = %{@_[0]};
	my %streamdata;

	# Check dependancies for radio programme transcoding / streaming
	# Check if we need 'tee'
	if ( (! main::exists_in_path($tee)) && $opt->{stdout} && (! $opt->{nowrite}) ) {
		main::logger "\nERROR: $tee does not exist in path, skipping\n";
		return 'next';
	}
	if (! main::exists_in_path($mplayer)) {
		main::logger "\nWARNING: Required $mplayer does not exist\n";
		return 'next';
	}
	# Check if we have mplayer and lame
	if ( (! $opt->{wav}) && (! $opt->{raw}) && (! main::exists_in_path($lame)) ) {
		main::logger "\nWARNING: Required $lame does not exist, will save file in wav format\n";
		$opt->{wav} = 1;
	}

	$prog->{ext} = 'mp3';
	$prog->{ext} = 'ra'  if $opt->{raw};
	$prog->{ext} = 'wav' if $opt->{wav};

	my $url_2 = %{ $prog->get_stream_data( $version_pids{default}, 'realaudio')}->{streamurl};

	# Report error if no versions are available
	if ( ! $url_2 ) {
		main::logger "WARNING: RealAudio version not available\n";
		return 'next';
	} else {
		main::logger "INFO: Stage 2 URL = $url_2\n" if $opt->{verbose};
	}

	# Determine the correct filenames for this download
	return 'skip' if $prog->generate_filenames( "<longname> - <episode> <pid>" );

	# Skip from here if we are only testing downloads
	return 'skip' if $opt->{test};

	# Do the audio download
	my $stream = Streamer::rtsp->new;
	return $stream->get( $ua, $url_2, $prog );
}



sub download_iphone {
	my $prog = shift;
	my $ua = shift; 
	my %version_pids = %{@_[0]};
	my %streamdata;
	my $url_2;

	$prog->{ext} = 'mp3';
	my $url_2 = %{ $prog->get_stream_data( $version_pids{ $prog->{version} }, 'iphone')}->{streamurl};

	# Report error if no versions are available
	if ( ! $url_2 ) {
		main::logger "WARNING: iPhone stream media not available\n";
		return 'next';
	} else {
		main::logger "INFO: Stage 2 URL = $url_2\n" if $opt->{verbose};
	}

	# Determine the correct filenames for this download
	if ( $prog->generate_filenames( "<longname> - <episode> <pid> <version>" ) ) {
		# Create symlink if required
		$prog->create_symlink( $prog->{symlink}, $prog->{filename}) if $opt->{symlink};
		return 'skip';
	}

	# Skip from here if we are only testing downloads
	return 'skip' if $opt->{test};

	my $return;
	# Disable proxy here if required
	$ua->proxy( ['http'] => undef ) if $opt->{partialproxy};
	my $stream = Streamer::iphone->new;
	$return = $stream->get( $ua, $url_2, $prog, 0 );
	# Re-enable proxy here if required
	$ua->proxy( ['http'] => $opt->{proxy} ) if $opt->{partialproxy};

	return $return;
}



sub download_rtmp {
	my $prog = shift;
	my $ua = shift; 
	my $mode = shift;
	my %version_pids = %{@_[0]};
	my %streamdata;
	my $url_2;

	# Force raw mode if ffmpeg is not installed
	if ( ! main::exists_in_path($mplayer) ) {
		main::logger "\nWARNING: $mplayer does not exist - not converting flv file\n";
		$opt->{raw} = 1;
	}
	# Disable rtmp modes if rtmpdump does not exist
	if ( ! main::exists_in_path($rtmpdump) ) {
		main::logger "\nERROR: Required program $rtmpdump does not exist (see http://linuxcentre.net/getiplayer/installation and http://linuxcentre.net/getiplayer/download)\n";
		return 'next';
	}

	$prog->{ext} = 'mp3' if $mode eq 'flashaudio';
	$prog->{ext} = 'aac' if $mode eq 'flashaac';
	$prog->{ext} = 'flv' if $opt->{raw};

	main::logger "INFO: Trying to get media stream metadata for $mode RTMP mode\n" if $opt->{verbose};
	%streamdata = %{ $prog->get_stream_data( $version_pids{ $prog->{version} }, $mode) };
	$url_2 = $streamdata{streamurl};
	if ( ! $url_2 ) {
		main::logger "\nWARNING: No $mode version available\n";
		return 'next';
	}

	# Determine the correct filenames for this download
	return 'skip' if $prog->generate_filenames( "<longname> - <episode> <pid> <version>" );

	# Skip from here if we are only testing downloads
	return 'skip' if $opt->{test};

	# Do the RTMP download
	my $stream = Streamer::rtmp->new;
	return $stream->get( $ua, $streamdata{streamurl}, $prog, $mode, $streamdata{application}, $streamdata{tcurl}, $streamdata{authstring}, $streamdata{swfurl} );
}



################### Podcast class #################
package Programme::podcast;

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
use Time::Local;
use URI;

# Inherit from Programme class
use base 'Programme';

# Class vars
sub index_min { return 20001 }
sub index_max { return 29999 }
sub channels { return {}; }


# Class cmdline Options
sub opt_format {
	return {
		outputpodcast	=> [ 1, "outputpodcast=s", 'Output', '--outputpodcast <dir>', "Download output directory for podcasts"],
	};
}


# Method to return optional list_entry format
sub optional_list_entry_format {
	my $prog = shift;
	return ", $prog->{available}, $prog->{channel}, $prog->{categories}";
}


# Returns the modes to try for this prog type
sub modelist {
	return 'podcast';
}


# Usage: Programme::podcast->get_links( \%prog, 'podcast' );
# Uses: %{ channels() }, \%prog
# Uses: $podcast_index_feed_url
sub get_links {
	shift; # ignore obj ref
	my $progref = shift;
	my $prog_type = shift;
	my %channels = %{ channels() };

	my $xml;
	my $res;
	main::logger "INFO: Getting podcast Index Feeds\n";
	# Setup User agent
	my $ua = main::create_ua('get_iplayer');
	
	# Method
	# $podcast_index_feed_url (gets list of rss feeds for each podcast prog) =>
	# http://downloads.bbc.co.uk/podcasts/$channel/$name/rss.xml =>
	
	# Download index feed
	my $xmlindex = main::request_url_retry($ua, $podcast_index_feed_url, 3, '.', "WARNING: Failed to get prodcast index from site\n");
	$xmlindex =~ s/\n/ /g;

	# Every RSS feed has an extry like below (all in a text block - not formatted like below)
	#  <program xmlns="" language="en-gb" typicalDuration="P30M" active="true" public="true" bbcFlavour="Programme Highlights" region="all" wwpid="0">
	#    <title>Best of Chris Moyles</title>
	#    <shortTitle>moyles</shortTitle>
	#    <description>Weekly highlights from the award-winning Chris Moyles breakfast show, as broadcast by Chris and team every morning from 6.30am to 10am.</description>
	#    <network id="radio1" name="BBC Radio 1" />
	#    <image use="itunes" url="http://www.bbc.co.uk/radio/podcasts/moyles/assets/_300x300.jpg" />
	#    <link target="homepage" url="http://www.bbc.co.uk/radio1/chrismoyles/" />
	#    <link target="feed" url="http://downloads.bbc.co.uk/podcasts/radio1/moyles/rss.xml" />
	#    <link target="currentItem" url="http://downloads.bbc.co.uk/podcasts/radio1/moyles/moyles_20080926-0630a.mp3">
	#      <title>Moyles: Guestfest. 26 Sep 08</title>
	#      <description>Rihanna, Ross Kemp, Jack Osbourne, John
	#      Barrowman, Cheggars, the legend that is Roy Walker and more,
	#      all join the team in a celeb laden bundle of mirth and
	#      merriment. It&#226;&#8364;&#8482;s all the best bits of the
	#      week from The Chris Moyles Show on BBC Radio 1.</description>
	#      <publishDate>2008-09-26T06:30:00+01:00</publishDate>
	#    </link>
	#    <bbcGenre id="entertainment" name="Entertainment" />
	#    <systemRef systemId="podcast" key="42" />
	#    <systemRef systemId="pid.brand" key="b006wkqb" />
	#    <feed mimeType="audio/mpeg" content="audio" audioCodec="mp3" audioProfile="cbr" />
	#  </program>
	for ( split /<program/, $xmlindex ) {
		# Extract channel name, rss feed data
		my ($channel, $url, $web);

		# <network id="radio1" name="BBC Radio 1" />
		$channel = $1 if m{<network\s+id=".*?"\s+name="(.*?)"\s*\/>};

		# <link target="feed" url="http://downloads.bbc.co.uk/podcasts/radio1/moyles/rss.xml" />
		$url = $1 if m{<link\s+target="feed"\s+url="(.*?)"\s*\/>};

		# <link target="homepage" url="http://www.bbc.co.uk/radio1/chrismoyles/" />
		$web = $1 if m{<link\s+target="homepage"\s+url="(.*?)"\s*\/>};

		# Skip if there is no feed data for channel
		next if ! ($channel || $url);

		my ( $name, $episode, $desc, $pid, $available, $duration, $thumbnail );

		# Get RSS feeds for each podcast programme
		main::logger "DEBUG: Getting podcast feed $url\n" if $opt->{verbose};
		$xml = main::request_url_retry($ua, $url, 3, '.', "WARNING: Failed to get podcast feed for $channel / $_ from iplayer site\n") if $opt->{verbose};
		$xml = main::request_url_retry($ua, $url, 3, '.', '') if ! $opt->{verbose};
		# skip if no data
		next if ! $xml;

		main::logger "INFO: Got ".(grep /<media:content/, split /<item>/, $xml)." programmes\n" if $opt->{verbose};
		decode_entities($xml);
	
		# First entry is channel data
		# <?xml version="1.0" encoding="utf-8"?>
		#<rss xmlns:media="http://search.yahoo.com/mrss/"
		#xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd"
		#version="2.0">
		#  <channel>
		#    <title>Stuart Maconie's Freak Zone</title>
		#    <link>http://www.bbc.co.uk/6music/shows/freakzone/</link>
		#    <description>Weekly highlights from Stuart Maconie's
		#    ...podcast is only available in the UK.</description>
		#    <itunes:summary>Weekly highlights from Stuart Maconie's
		#    ...podcast is only available in the UK.</itunes:summary>
		#    <itunes:author>BBC 6 Music</itunes:author>
		#    <itunes:owner>
		#      <itunes:name>BBC</itunes:name>
		#      <itunes:email>podcast.support@bbc.co.uk</itunes:email>
		#    </itunes:owner>
		#    <language>en</language>
		#    <ttl>720</ttl>
		#    <image>
		#      <url>
		#      http://www.bbc.co.uk/radio/podcasts/freakzone/assets/_300x300.jpg</url>
		#      <title>Stuart Maconie's Freak Zone</title>
		#      <link>http://www.bbc.co.uk/6music/shows/freakzone/</link>
		#    </image>
		#    <itunes:image href="http://www.bbc.co.uk/radio/podcasts/freakzone/assets/_300x300.jpg" />
		#    <copyright>(C) BBC 2008</copyright>
		#    <pubDate>Sun, 06 Jul 2008 20:00:05 +0100</pubDate>
		#    <itunes:category text="Music" />
		#    <itunes:keywords>Stewart Maconie, Macconie, freekzone,
		#    freakzone, macoonie</itunes:keywords>
		#    <media:keywords>Stewart Maconie, Macconie, freekzone,
		#    freakzone, macoonie</media:keywords>
		#   <itunes:explicit>no</itunes:explicit>
		#    <media:rating scheme="urn:simple">nonadult</media:rating>

		# Parse XML

		# get list of entries within <entry> </entry> tags
		my @entries = split /<item>/, $xml;
		# first element == <channel> header
		my $header = shift @entries;

		# Get podcast name
		$name = $1 if $header =~ m{<title>\s*(.+?)\s*</title>};
	
		# Parse the categories into hash
		# <itunes:category text="Music" />
		my @category;
		for my $line ( grep /<itunes:category/, (split /\n/, $header) ) {
			push @category, $1 if $line =~ m{<itunes:category\s+text="\s*(.+?)\s*"};
		}
	
		# Get thumbnail from header
		# <itunes:image href="http://www.bbc.co.uk/radio/podcasts/freakzone/assets/_300x300.jpg" />
		$thumbnail = $1 if $header =~ m{<itunes:image href="\s*(.+?)\s*"};

		# Followed by items:
		#    <item>
		#      <title>FreakZone: C'est Stuart avec le Professeur Spear et le
		#      pop francais?</title>
		#      <description>Stuart and Justin discuss the sub-genre of
		#      French 'cold wave' in this week's module.</description>
		#      <itunes:subtitle>Stuart and Justin discuss the sub-genre of
		#      French 'cold wave' in this week's
		#      module....</itunes:subtitle>
		#      <itunes:summary>Stuart and Justin discuss the sub-genre of
		#      French 'cold wave' in this week's module.</itunes:summary>
		#      <pubDate>Sun, 06 Jul 2008 20:00:00 +0100</pubDate>
		#      <itunes:duration>14:23</itunes:duration>
		#      <enclosure url="http://downloads.bbc.co.uk/podcasts/6music/freakzone/freakzone_20080706-2000.mp3"
		#      length="13891916" type="audio/mpeg" />
		#      <guid isPermaLink="false">
		#      http://downloads.bbc.co.uk/podcasts/6music/freakzone/freakzone_20080706-2000.mp3</guid>
		#      <link>
		#      http://downloads.bbc.co.uk/podcasts/6music/freakzone/freakzone_20080706-2000.mp3</link>
		#      <media:content url="http://downloads.bbc.co.uk/podcasts/6music/freakzone/freakzone_20080706-2000.mp3"
		#      fileSize="13891916" type="audio/mpeg" medium="audio"
		#      expression="full" duration="863" />
		#      <itunes:author>BBC 6 Music</itunes:author>
		#    </item>
	
		foreach my $entry (@entries) {

			my $entry_flat = $entry;
			$entry_flat =~ s/\n/ /g;
	
			# Use the link as a guid
			# <link>   http://downloads.bbc.co.uk/podcasts/6music/freakzone/freakzone_20080706-2000.mp3</link>
			$pid = $1 if $entry =~ m{<link>\s*(.+?)</link>};
	
			# Skip if this pid is a duplicate
			if ( defined $progref->{$pid} ) {
				main::logger "WARNING: '$pid, $progref->{$pid}->{name} - $progref->{$pid}->{episode}, $progref->{$pid}->{channel}' already exists (this channel = $_)\n" if $opt->{verbose};
				next;
			}
	
			# parse episode
			# <title>FreakZone: C'est Stuart avec le Professeur Spear et le pop francais?</title>
			$episode = $1 if $entry =~ m{<title>\s*(.*?)\s*</title>};
	
			# <pubDate>Sun, 06 Jul 2008 20:00:00 +0100</pubDate>
			$available = $1 if $entry =~ m{<pubDate>\s*(.*?)\s*</pubDate>};
	
			# <description>Stuart and Justin discuss the sub-genre of French 'cold wave' in this week's module.</description>
			$desc = $1 if $entry =~ m{<description>\s*(.*?)\s*</description>};
	
			# Duration
			$duration = $1 if $entry =~ m{<itunes:duration>\s*(.*?)\s*</itunes:duration>};
	
			# build data structure
			$progref->{$pid} = Programme::podcast->new(
				'pid'		=> $pid,
				'name'		=> $name,
				'versions'	=> 'default',
				'episode'	=> $episode,
				'desc'		=> $desc,
				'available'	=> $available,
				'duration'	=> $duration,
				'thumbnail'	=> $thumbnail,
				'channel'	=> $channel,
				'categories'	=> join(',', @category),
				'type'		=> 'podcast',
				'web'		=> $web,
			);
		}
	}
	main::logger "\n";
	return 0;
}



sub download {
	my ( $prog, $ua ) = ( @_ );
	my %streamdata;

	# stream data not available
	return 'skip' if $opt->{streaminfo};

	# Determine the correct filename and extension for this download
	my $filename_orig = $prog->{pid};
	$prog->{ext} = $prog->{pid};
	$filename_orig =~ s|^.+/(.+?)\.\w+$|$1|g;
	$prog->{ext} =~ s|^.*\.(\w+)$|$1|g;

	# Determine the correct filenames for this download
	return 'skip' if $prog->generate_filenames( "<longname> - <episode> $filename_orig" );

	# Skip from here if we are only testing downloads
	return 1 if $opt->{test};

	my $stream = Streamer::podcast->new;
	return $stream->get( $ua, $prog->{pid}, $prog );
}



################### ITV class #################
package Programme::itv;

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
use Time::Local;
use URI;

# Inherit from Programme class
use base 'Programme';

# Class vars
sub index_min { return 100001 }
sub index_max { return 199999 }
sub channels {
	return {
		'crime'					=> 'itv|TV Classics Crime Drama',
		'perioddrama'				=> 'itv|TV Classics Period Drama',
		'familydrama'				=> 'itv|TV Classics Family Drama',
		'documentary'				=> 'itv|TV Classics Documentaries',
		'comedy'				=> 'itv|TV Classics Comedy',
		'kids'					=> 'itv|TV Classics Children\'s TV',
		'soaps'					=> 'itv|TV Classics Soaps',
		'/'					=> 'itv|TV Classics',
	};
}


# Class cmdline Options
sub opt_format {
	return {
		outputitv	=> [ 1, "outputitv=s", 'Output', '--outputitv <dir>', "Download output directory for itv"],
	};
}


# Method to return optional list_entry format
sub optional_list_entry_format {
	my $prog = shift;
	return ", $prog->{channel}, $prog->{categories}, $prog->{guidance}";
}



# Returns the modes to try for this prog type
sub modelist {
	return 'mms';
}



# Cleans up a pid and removes url parts that might be specified
sub clean_pid {
	my $prog = shift;
	# extract numerical format - remove surrounding url
	$prog->{pid} = $1 if $prog->{pid} =~ m{(\d{2,8})};
}



# get full episode metadata given pid and ua. Uses two different urls to get data
sub get_metadata {
	my $prog = shift;
	my $ua = shift;
	my $metadata;
	my $entry3;
	my ($name, $episode, $duration, $available, $channel, $expiry, $longdesc, $versions, $guidance, $prog_type, $categories, $player, $thumbnail);

	# ITV Catch-Up metadata
		my $prog_metadata_url_itv = 'http://www.itv.com/_app/Dynamic/CatchUpData.ashx?ViewType=5&Filter='; # +<pid>
		$entry3 = main::request_url_retry($ua, "${prog_metadata_url_itv}$prog->{pid}", 3, '', '');
		decode_entities($entry3);
		main::logger "DEBUG: ${prog_metadata_url_itv}$prog->{pid}:\n$entry3\n\n" if $opt->{debug};
		# Flatten
		$entry3 =~ s|[\r\n]||g;

		#div class="itvCatchUpPlayerPanel" xmlns:ms="urn:schemas-microsoft-com:xslt">
		#  <div class="cu-sponsor"><a href="http://sam.itv.com/accipiter/adclick/CID=000040d70000000000000000/acc_random=1/SITE=CLICKTRACK/AREAITVCATCHUP.VIDEO=CLICKTRACK..FREEVIEW.SPONSORBUTTON.OCT08/AAMSZ=120X60/pageid=1" title="ITV Player in assocation with Freeview"><img src="/_app/img/catchup/catchup_video_freeview2.jpg" alt="ITV Player is sponsored by Freeview"></a></div>
		#  <h2>Doctor Zhivago</h2>
		#  <p>Part 1 of 3. Dramatisation of the epic novel by Boris Pasternak. Growing up in Moscow with his uncle, aunt and cousin Tonya, Yury is captivated by a stunning young girl called ...</p>
		#  <p class="timings"><span class="date">Mon 29 Dec 2008</span><br /><br /><span>
		#
		#        Duration: 1hr 30 min |
		#                                Expires in
		#                                <strong>22</strong>
		#                                                days
		#                                        </span></p>
		#  <p><a href="http://www.itv.com/CatchUp/Programmes/default.html?ViewType=1&amp;Filter=2352">3 Episodes Available
		#        </a><br></br></p>
		#  <p class="channelLogo"><img src="/_app/img/logos/itv3-black.gif" alt="ITV 4"></p>
		#  <div id="cu-2-0-VideoID">33105</div>
		#  <div id="cu-2-0-DentonId">17</div>
		#  <div id="cu-2-0-ItemMediaUrl">http://www.itv.com//img/480x272/Doctor-Zhivago-c47828f8-a1af-4cd2-b5a2-40c18eb7e63c.jpg</div>
		#</div><script language="javascript" type="text/javascript" xmlns:ms="urn:schemas-microsoft-com:xslt">
		#                        SetCatchUpModuleID(0);
		#                </script>
		#

		#<div class="itvCatchUpPlayerPanel" xmlns:ms="urn:schemas-microsoft-com:xslt">
		#  <div class="cu-sponsor"><a href="http://sam.itv.com/accipiter/adclick/CID=000040d70000000000000000/acc_random=1/SITE=CLICKTRACK/AREAITVCATCHUP.VIDEO=CLICKTRACK..FREEVIEW.SPONSORBUTTON.OCT08/AAMSZ=120X60/pageid=1" title="ITV Player in assocation with Freeview"><img src="/_app/img/catchup/catchup_video_freeview2.jpg" alt="ITV Player is sponsored by Freeview"></a></div>
		#  <h2>Affinity</h2>
		#  <p>Victorian period drama with a murderous, pyschological twist.</p>
		#  <p class="timings"><span class="date">Sun 28 Dec 2008</span><br /><br /><span>
		#
		#        Duration: 2hr 00 min |
		#                                Expires in
		#                                <strong>21</strong>
		#                                                days
		#                                        </span></p>
		#  <p class="channelLogo"><img src="/_app/img/logos/itv1-black.gif" alt="ITV 2"></p>
		#  <div class="guidance">
		#    <div><strong>ITV Video Guidance</strong><p>This programme contains strong language and scenes of a sexual nature                                                                                                                           </p>
		#    </div>
		#  </div>
		#  <div id="cu-2-0-VideoID">33076</div>
		#  <div id="cu-2-0-DentonId">11</div>
		#  <div id="cu-2-0-ItemMediaUrl">http://www.itv.com//img/480x272/Affinity-9624033b-6e05-4784-85f7-114be0559b24.jpg</div>
		#</div><script language="javascript" type="text/javascript" xmlns:ms="urn:schemas-microsoft-com:xslt">
		#                        SetCatchUpModuleID(0);
		#                </script>
		#

		#$expiry = $1 if $entry3 =~ m{<dcterms:valid>\s*start=.+?;\s*end=(.*?);};
		$available = $1 if $entry3 =~ m{<p\s+class="timings">\s*<span\s+class="date">(.+?)<\/span>};
		$duration = $1 if $entry3 =~ m{Duration:\s*(.+?)\s+\|};
		#$prog_type = $1 if $entry3 =~ m{medium=\"(\w+?)\"};
		$longdesc = $1 if $entry3 =~ m{<p>(.+?)<\/p>}i;
		$guidance = $1 if $entry3 =~ m{ITV Video Guidance<\/strong><p>\s*(.+?)[\W\s]*<\/p>};
		#$player = $1 if $entry3 =~ m{<media:player\s*url=\"(.*?)\"\s*\/>};
		$thumbnail = $1 if $entry3 =~ m{<div id="cu-2-0-ItemMediaUrl">(.+?)</div>};
		$name = $1 if $entry3 =~ m{<h2>(.+?)</h2>};

	# Fill in from cache if not got from metadata
	my %metadata;
	$metadata{pid}		= $prog->{pid};
	$metadata{index}	= $prog->{index};
	$metadata{name}		= $name || $prog->{name};
	$metadata{episode}	= $episode || $prog->{episode};
	$metadata{type}		= $prog_type || $prog->{type};
	$metadata{duration}	= $duration || $prog->{duration};
	$metadata{channel}	= $channel || $prog->{channel};
	$metadata{available}	= $available || $prog->{available};
	$metadata{expiry}	= $expiry || $prog->{expiry};
	$metadata{versions}	= $versions || $prog->{versions};
	$metadata{guidance}	= $guidance || $prog->{guidance};
	$metadata{categories}	= $categories || $prog->{categories};
	$metadata{desc}		= $longdesc || $prog->{desc};
	$metadata{player}	= $player;
	$metadata{thumbnail}	= $thumbnail || $prog->{thumbnail};

	return %metadata;
}



# Usage: Programme::itv->get_links( \%prog, 'itv' );
# Uses: %{ channels() }, \%prog
sub get_links {
	shift; # ignore obj ref
	my $progref = shift;
	my $prog_type = shift;
	my %channels = %{ channels() };

	my $xml;
	my $res;
	my %series_pid;
	my %episode_pid;
	main::logger "INFO: Getting itv Index Feeds\n";
	# Setup User agent
	my $ua = main::create_ua('desktop');

	# Method
	# http://www.itv.com/_data/xml/CatchUpData/CatchUp360/CatchUpMenu.xml (gets list of urls for each prog series) =>
	#  =>
	
	# Download index feed
	my $itv_index_shows_url = 'http://www.itv.com/ClassicTVshows/'; # $channel/default.html
	my $itv_index_feed_url = 'http://www.itv.com/_data/xml/CatchUpData/CatchUp360/CatchUpMenu.xml';

	# Sort feeds so that pages are done last - this makes sure that the channels get defined correctly if there are dups
	my @channel_list;
	push @channel_list, grep !/\//, keys %channels;
	push @channel_list, grep  /\//, keys %channels;
	# ITV ClassicShows parsing
	for my $channel ( @channel_list ) {
		# <li class="first-child"><a href="http://www.itv.com/ClassicTVshows/comedy/ABitofaDo/default.html">A Bit of a Do</a><br></li>
		# <li><a href="http://www.itv.com/ClassicTVshows/familydrama/achristmascarol/default.html">A Christmas Carol</a><br></li>
		# Get page, search for relevent lines which contain series links and loop through each matching line
		for my $s_line ( grep /(<li><a\s+href=".+?"><img\s+src=".+?"\s+alt=".+?"><\/a><h4>|<li.*?><a href=".+?">.+?<\/a><br><\/li>)/, ( split /\n/, main::request_url_retry($ua, $itv_index_shows_url.${channel}.'/default.html', 3, '.', "WARNING: Failed to get itv ${channel} index from site\n") ) ) {
			my ($url, $name);
			# Extract series url + series description
			($url, $name) = ($1, $2) if $s_line =~ m{<li><a\s+href="\s*(.+?)\s*"><img\s+src=".+?"\s+alt="\s*(.+?)\s*"><\/a><h4>};
			($url, $name) = ($1, $2) if $s_line =~ m{<li.*?><a href="\s*(.+?)\s*">\s*(.+?)\s*<\/a><br><\/li>};
			chomp($url);
			chomp($name);
			next if ! ($url && $name);
			main::logger "DEBUG: Channel: '$channel' Series: '$name' URL: '$url'\n" if $opt->{verbose};

			# Get list of episodes for this series
			# e.g. <li class="first-child"><a title="Play" href="?vodcrid=crid://itv.com/993&amp;DF=0">Episode one</a><br>The Sun in a Bottle</li>
			#      <li><a title="Play" href="?vodcrid=crid://itv.com/994&amp;DF=0">Episode two</a><br>Castle Saburac</li>
			#      <li class="first-child"><a class="nsat" title="This programme contains strong language and violence       " href="?vodcrid=crid://itv.com/588&amp;G=10&amp;DF=0">Episode one</a><br>The Dead of Jericho</li>
			#
			# e.g. <li><a class="playVideo" title="Play" href="?vodcrid=crid://itv.com/1232&amp;DF=0"><img src="img/60x45/Crossroads-Rosemary-shoots-David-efeef7cd-8d41-416c-9e30-26ce1b3d625c.jpg" alt="Crossroads: Rosemary shoots David"><span>Play</span></a><h4>
			#      vodcrid=crid://itv.com/971&amp;DF=0"><img src="img/60x45/9d20fd47-5d4b-44f5-9188-856505de0d0f.jpg" alt="Emmerdale  2002 Louise kills Ray"
			#
			# e.g. <a class="playVideo" title="Play" href="?vodcrid=crid://itv.com/1854&amp;DF=1"><img src="img/157x104/140c456c-d8bd-49d5-90f8-f7cc6d86f132.jpg" alt="Soldier Soldier "><span>Play</span></a><h2>Soldier Soldier</h2>
			#
			for my $e_line ( grep /vodcrid=crid/, ( split /\n/, main::request_url_retry($ua, $url, 3, '.', "WARNING: Failed to get ${name} index from site\n") ) ) {
				my ($guidance, $pid, $episode, $thumbnail);
				main::logger "DEBUG: Match Line: $e_line\n" if $opt->{debug};
				# Extract episode data
				($guidance, $pid, $episode)  = ($2, $3, $4) if $e_line =~ m{<li.*?><a\s+(class="nsat"\s+)?title="\s*(.+?)\s*"\s+href="\?vodcrid=crid://itv.com/(\d+?)&.+?>\s*(.+?)\s*<};
				($pid, $thumbnail, $episode) = ($1, $2, $3) if $e_line =~ m{vodcrid=crid://itv.com/(\d+?)&.+?><img\s+src="(.+?)"\s+alt="\s*(.+?)\s*"};
				next if ! ($pid && $episode);
				# Remove 'Play'
				$guidance =~ s/^Play$//ig;
				# Strip non-printables
				$guidance =~ s/[\s\x00\xc2\xa0]+$//ig;
				#$guidance =~ s|[^\w\s\-\!"£\$\\/%\^&\*\(\)\+=,\.\?':;@~\[\]]+||gi;
				#$guidance =~ s/(\s\s)+//g;
				main::logger "DEBUG: PID: '$pid' Episode: '$episode' Guidance: '$guidance'\n" if $opt->{debug};

				# Skip if this pid is a duplicate
				if ( defined $progref->{$pid} ) {
					main::logger "WARNING: '$pid, $progref->{$pid}->{name} - $progref->{$pid}->{episode}, $progref->{$pid}->{channel}' already exists (this channel = $channel)\n" if $opt->{verbose};
					# Merge data (hack)
					#$progref->{$pid}->{episode} .= ','.$episode;
					my $oldname = $progref->{$pid}->{name};
					$progref->{$pid}->{episode} = $episode if (! $progref->{$pid}->{episode}) || $progref->{$pid}->{episode} =~ /$oldname/i;
					$progref->{$pid}->{thumbnail} = $thumbnail if ! $progref->{$pid}->{thumbnail};
					$progref->{$pid}->{guidance} = $guidance if ! $progref->{$pid}->{guidance};
					next;
				}

				# build data structure
				$progref->{$pid} = Programme::itv->new(
					'pid'		=> $pid,
					'name'		=> $name,
					'versions'	=> 'default',
					'episode'	=> $episode,
					'channel'	=> (split /\|/, $channels{$channel})[1],
					'guidance'	=> $guidance,
					'categories'	=> (split /\|/, $channels{$channel})[1],
					'type'		=> 'itv',
					'web'		=> $url,
				);
			}
		}
	}

	my $xmlindex = main::request_url_retry($ua, $itv_index_feed_url, 3, '.', "WARNING: Failed to get itv index from site\n");
	$xmlindex =~ s/[\n\r]//g;

	# This gives a list of programme series (sometimes episodes)
	#    <ITVCatchUpProgramme>
	#      <ProgrammeId>50</ProgrammeId>
	#      <ProgrammeTitle>A CHRISTMAS CAROL</ProgrammeTitle>
	#      <ProgrammeMediaId>615915</ProgrammeMediaId>
	#      <ProgrammeMediaUrl>
	#      http://www.itv.com//img/150x113/A-Christmas-Carol-2f16d25a-de1d-4a3a-90cb-d47489eee98e.jpg</ProgrammeMediaUrl>
	#      <LastUpdated>2009-01-06T12:24:22.7419643+00:00</LastUpdated>
	#      <Url>
	#      http://www.itv.com/CatchUp/Video/default.html?ViewType=5&amp;Filter=32910</Url>
	#      <EpisodeCount>1</EpisodeCount>
	#      <VideoID>32910</VideoID>
	#      <DentonID>-1</DentonID>
	#      <DentonRating></DentonRating>
	#      <AdditionalContentUrl />
	#      <AdditionalContentUrlText />
	#    </ITVCatchUpProgramme>

	for my $feedxml ( split /<ITVCatchUpProgramme>/, $xmlindex ) {
		# Extract feed data
		my ($episodecount, $viewtype, $videoid, $url);
		my @entries;

		main::logger "\n\nDEBUG: XML: $feedxml\n"  if $opt->{debug}; 

		# <EpisodeCount>1</EpisodeCount>
		$episodecount = $1 if $feedxml =~ m{<EpisodeCount>\s*(\d+)\s*<\/EpisodeCount>};

		# <Url>http://www.itv.com/CatchUp/Video/default.html?ViewType=5&amp;Filter=32910</Url>
		($viewtype, $videoid) = ($1, $2) if $feedxml =~ m{<Url>\s*.+?ViewType=(\d+).+?Filter=(\d+)\s*<\/Url>}i;

		## <VideoID>32910</VideoID>
		#$videoid = $1 if $feedxml =~ m{<VideoID>\s*(\d+)\s*<\/VideoID>};

		# Skip if there is no feed data for channel
		next if ($viewtype =~ /^0*$/ || $videoid =~ /^0*$/ );

		main::logger "DEBUG: Got ViewType=$viewtype VideoId=$videoid EpisodeCount=$episodecount\n" if $opt->{debug};

		my $url = "http://www.itv.com/_app/Dynamic/CatchUpData.ashx?ViewType=${viewtype}&Filter=${videoid}";

		# Add response from episode metadata url to list to be parsed if this is an episode link
		if ( $viewtype == 5 ) {
			next if $episode_pid{$videoid};
			$episode_pid{$videoid} = 1;
			# Get metadata pages for episode

			my ( $name, $guidance, $channel, $episode, $desc, $pid, $available, $duration, $thumbnail );

			$pid = $videoid;
			$channel = 'ITV Catch-up';

			# Skip if this pid is a duplicate
			if ( defined $progref->{$pid} ) {
				main::logger "WARNING: '$pid, $progref->{$pid}->{name} - $progref->{$pid}->{episode}, $progref->{$pid}->{channel}' already exists (this channel = $channel)\n" if $opt->{verbose};
				next;
			}

			$name = $1 if $feedxml =~ m{<ProgrammeTitle>\s*(.+?)\s*<\/ProgrammeTitle>};
			$guidance = $1 if $feedxml =~ m{<DentonRating>\s*(.+?)\s*<\/DentonRating>};
			$thumbnail = $1 if $feedxml =~ m{<ProgrammeMediaUrl>\s*(.+?)\s*<\/ProgrammeMediaUrl>};
			$episode = $pid;
			# Strip non-printable chars
			$guidance =~ s/[\s\x00\xc2\xa0]+$//ig;

			# build data structure
			$progref->{$pid} = Programme::itv->new(
				'pid'		=> $pid,
				'name'		=> $name,
				'versions'	=> 'default',
				'episode'	=> $episode,
				'guidance'	=> $guidance,
				'desc'		=> $desc,
				'available'	=> $available,
				'duration'	=> $duration,
				'thumbnail'	=> $thumbnail,
				'channel'	=> $channel,
				'categories'	=> 'TV',
				'type'		=> 'itv',
				'web'		=> ${itv_catchup_page_prefix}.${pid},
			);





		# Get next episode list and parse
		#     <div class="listItem highlight contain">
		#      <div class="floatLeft"><a href="http://www.itv.com/CatchUp/Video/default.html?ViewType=5&amp;Filter=33383"><img src="http://www.itv.com//img/157x88/P7-67e0b86f-b335-4f6b-8db
		#      <div class="content">
		#        <h3><a href="http://www.itv.com/CatchUp/Video/default.html?ViewType=5&amp;Filter=33383">Emmerdale</a></h3>
		#        <p class="date">Mon 05 Jan 2009</p>
		#        <p class="progDesc">Donna is stunned to learn Marlon has pointed the finger at Ross. Aaron defaces Tom King's grave.</p>
		#        <ul class="progDetails">
		#          <li>
		#                          Duration: 30 min
		#          </li>
		#          <li class="days">
		#            Expires in
		#                        <strong>29</strong>
		#                                        days
		#                                </li>
		#        </ul>
		#      </div>
		#    </div>
		#    <div class="listItem contain">
		#      <div class="floatLeft"><a href="http://www.itv.com/CatchUp/Video/default.html?ViewType=5&amp;Filter=33245"><img src="http://www.itv.com//img/157x88/Marlon-Dingle-742c50b3-3b
		#      <div class="content">
		#        <h3><a href="http://www.itv.com/CatchUp/Video/default.html?ViewType=5&amp;Filter=33245">Emmerdale</a></h3>
		#        <p class="date">Fri 02 Jan 2009</p>
		#        <p class="progDesc">Marlon gets his revenge on Ross. The King brothers struggle to restart their business without Matthew. Scarlett is fed up with Victoria getting all Daz
		#        <ul class="progDetails">
		#          <li>
		#                          Duration: 30 min
		#          </li>
		#          <li class="days">
		#            Expires in
		#                        <strong>26</strong>
		#                                        days
		#                                </li>
		#        </ul>
		#      </div>
		#    </div>
		# 
		} elsif ( $viewtype == 1 ) {
			# Make sure we don't duplicate parsing a series
			next if $series_pid{$videoid};
			$series_pid{$videoid} = 1;

			# Get metadata pages for each series
			main::logger "DEBUG: Getting series metadata $url\n" if $opt->{debug};
			$xml = main::main::request_url_retry($ua, $url, 2, '.', "WARNING: Failed to get itv series data for ${videoid} from itv site\n") if $opt->{verbose};
			$xml = main::request_url_retry($ua, $url, 2, '.', '') if ! $opt->{verbose};

			# skip if no data
			next if ! $xml;

			decode_entities($xml);
			# Flatten entry
			$xml =~ s/[\n\r]//g;

			# Extract Filter (pids) from this list
			# e.g. <h3><a href="http://www.itv.com/CatchUp/Video/default.html?ViewType=5&amp;Filter=32042">Emmerdale</a></h3>
			my @videoids = (split /<h3><a href=.+?Filter=/, $xml);

			# Get episode data for each videoid
			$viewtype = 5;

			my @episode_data = split/<h3><a href=.+?Filter=/, $xml;
			# Ignore first entry
			shift @episode_data;
			main::logger "INFO: Got ".($#episode_data+1)." programmes\n" if $opt->{verbose};

			for my $xml (@episode_data) {
				$videoid = $1 if $xml =~ m{^(\d+?)".+$}i;

				# Make sure we don't duplicate parsing an episode
				next if $episode_pid{$videoid};
				$episode_pid{$videoid} = 1;

				my ( $name, $guidance, $channel, $episode, $desc, $pid, $available, $duration, $thumbnail );
	
				$pid = $videoid;
				$channel = 'ITV Catch-up';
	
				# Skip if this pid is a duplicate
				if ( defined $progref->{$pid} ) {
					main::logger "WARNING: '$pid, $progref->{$pid}->{name} - $progref->{$pid}->{episode}, $progref->{$pid}->{channel}' already exists (this channel = $channel)\n" if $opt->{verbose};
					next;
				}
				$name = $1 if $feedxml =~ m{<ProgrammeTitle>\s*(.+?)\s*<\/ProgrammeTitle>};
				$available = $1 if $xml =~ m{<p\s+class="date">(.+?)<\/p>}i;
				$episode = $available;
				$duration = $1 if $xml =~ m{<li>Duration:\s*(.+?)\s*<\/li>}i;
				$desc = $1 if $xml =~ m{<p\s+class="progDesc">(.+?)\s*<\/p>};
				$guidance = $1 if $feedxml =~ m{<DentonRating>\s*(.+?)\s*<\/DentonRating>};
				$thumbnail = $1 if $feedxml =~ m{<ProgrammeMediaUrl>\s*(.+?)\s*<\/ProgrammeMediaUrl>};
				$guidance =~ s/[\s\x00\xc2\xa0]+$//ig;

				main::logger "DEBUG: name='$name' episode='$episode' pid=$pid available='$available' \n" if $opt->{debug};	
	
				# build data structure
				$progref->{$pid} = Programme::itv->new(
					'pid'		=> $pid,
					'name'		=> $name,
					'versions'	=> 'default',
					'episode'	=> $episode,
					'guidance'	=> $guidance,
					'desc'		=> $desc,
					'available'	=> $available,
					'duration'	=> $duration,
					'thumbnail'	=> $thumbnail,
					'channel'	=> $channel,
					'categories'	=> 'TV',
					'type'		=> 'itv',
					'web'           => ${itv_catchup_page_prefix}.${pid},
				);
			}
		}	

	}
	main::logger "\n";
	return 0;
}


sub download {
	my ( $prog, $ua ) = ( @_ );
	my %streamdata;

	# stream data
	# Display media stream data if required
	if ( $opt->{streaminfo} ) {
		main::display_stream_info( $prog, undef, 'all' );
		$opt->{quiet} = 1;
		return 'skip';
	}

	# Check for mplayer (required)
	if (! main::exists_in_path($mplayer)) {
		main::logger "ERROR: Required $mplayer does not exist, skipping\n";
		return 21;
	}

	$prog->{ext} = 'mp4';
	$prog->{ext} = 'asf' if $opt->{raw};
	
	my @url_list = split /\|/, %{ $prog->get_stream_data( undef, 'itv')}->{streamurl};

	if ( $#url_list < 0 ) {
		main::logger "WARNING: No programme stream URLs were found, skipping\n";
		return 'skip';
	}
	
	# Get and set more meta data - Set the %prog values from metadata if they aren't already set
	my %metadata = $prog->get_metadata($ua);
	for ( qw/ name episode available duration thumbnail desc guidance / ) {
		$prog->{$_} = $metadata{$_} if ! $prog->{$_};
	}

	# Determine the correct filenames for this download
	return 'skip' if $prog->generate_filenames( "<name> <episode> <pid>", $#url_list );

	# Skip from here if we are only testing downloads
	return 'skip' if $opt->{test};

	my $stream = Streamer::mms->new;
	return $stream->get( $ua, (join '|', @url_list), $prog );
}


# Generic
# Gets media streams data for this version pid
# $media = all|itv
sub get_stream_data {
	my ( $prog, $verpid, $media ) = @_;
	my %data;

	# Setup user agent with redirection enabled
	my $ua = main::create_ua('desktop');
	$opt->{quiet} = 0 if $opt->{streaminfo};

	# ITV streams
	my $prog_type = 'itv';
	$data{$prog_type}{type} = 'ITV ASF Video stream';
	$opt->{quiet} = 1 if $opt->{streaminfo};
	$data{$prog_type}{streamurl} = join('|', Streamer::mms->get_url( $ua, $prog->{pid} ) );
	$opt->{quiet} = 0 if $opt->{streaminfo};

	# Return a hash with media => url if 'all' is specified - otherwise just the specified url
	if ( $media eq 'all' ) {
		return %data;
	} else {
		# Make sure this hash exists before we pass it back...
		$data{$media}{exists} = 0 if not defined $data{$media};
		return $data{$media};
	}
}



################### Hulu class #################
package Programme::hulu;

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
use Time::Local;
use URI;

# Inherit from Programme class
use base 'Programme';

# Class vars
sub index_min { return 200001 }
sub index_max { return 299999 }
sub channels {
	return {
		# From http://www.hulu.com/channels (# <no of pages>, each page has 20 episodes)
		# Takes about 25 mins to get 9000 progs
		'Action and Adventure'		=> 'hulu|Action and Adventure', # 89
		'Animation and Cartoons'	=> 'hulu|Animation and Cartoons', # 52
		'Comedy'			=> 'hulu|Comedy', # 144 pages
		'Drama'				=> 'hulu|Drama', # 125
		'Family'			=> 'hulu|Family', # 23
		'Food and Leisure'		=> 'hulu|Food and Leisure', # 39
		'Home and Garden'		=> 'hulu|Home and Garden', # 8
		'Horror and Suspense'		=> 'hulu|Horror and Suspense', #63
		'Music'				=> 'hulu|Music', # 2
		'News and Information'		=> 'hulu|News and Information', # 19
		'Other'				=> 'hulu|Other', # 0
		'Reality and Game Shows'	=> 'hulu|Reality and Game Shows', # 33
		'Science Fiction'		=> 'hulu|Science Fiction', # 56
		'Sports'			=> 'hulu|Sports', # 27
		'Talk and Interview'		=> 'hulu|Talk and Interview', # 10
		'Videogames'			=> 'hulu|Videogames', # 0
		'Web'				=> 'hulu|Web', # 48
		#"15+gigs"				=> "hulu|15 Gigs",
		#"60frames"				=> "hulu|60Frames",
		#"abc+studios"				=> "hulu|ABC Studios",
		#"alli"					=> "hulu|Alli",
		#"attentionspan.tv"			=> "hulu|AttentionSpan.TV",
		#"australian+food+tv"			=> "hulu|Australian Food TV",
		#"bravo"					=> "hulu|Bravo",
		#"c+spot"				=> "hulu|C Spot",
		#"chiller"				=> "hulu|Chiller",
		#"clubwpt"				=> "hulu|ClubWPT",
		#"cnbc"					=> "hulu|CNBC",
		#"comedy+central"			=> "hulu|Comedy Central",
		#"crackle"				=> "hulu|Crackle",
		#"crime+&amp;+investigation+network"	=> "hulu|Crime &amp; Investigation Network",
		#"davis+panzer"				=> "hulu|Davis Panzer",
		#"diy+network"				=> "hulu|DIY Network",
		#"e!+entertainment"			=> "hulu|E! Entertainment",
		#"entertainment+rights"			=> "hulu|Entertainment Rights",
		#"entertainment+studios"			=> "hulu|Entertainment Studios",
		#"eqal"					=> "hulu|Eqal",
		#"fearnet"				=> "hulu|FEARnet",
		#"fine+living"				=> "hulu|Fine Living",
		#"fox+business"				=> "hulu|Fox Business",
		#"fox+movie+channel"			=> "hulu|Fox Movie Channel",
		#"fox+news"				=> "hulu|Fox News",
		#"fox+reality"				=> "hulu|Fox Reality",
		#"fox+sports"				=> "hulu|Fox Sports",
		#"fox+television+classics"		=> "hulu|Fox Television Classics",
		#"fox+television+studios"		=> "hulu|Fox Television Studios",
		#"fox"					=> "hulu|FOX",
		#"fuel+tv"				=> "hulu|FUEL TV",
		#"funimation"				=> "hulu|FUNimation",
		#"fx"					=> "hulu|FX",
		#"generate"				=> "hulu|Generate",
		#"gong"					=> "hulu|Gong",
		#"hgtv"					=> "hulu|HGTV",
		#"historic+films"			=> "hulu|Historic Films",
		#"hype"					=> "hulu|Hype",
		#"image+entertainment"			=> "hulu|Image Entertainment",
		#"independent+comedy+network"		=> "hulu|Independent Comedy Network",
		#"itsallinyourhands.tv"			=> "hulu|itsallinyourhands.tv",
		#"jackass+world"				=> "hulu|Jackass World",
		#"japanese+humor+owarai"			=> "hulu|Japanese Humor Owarai",
		#"lionsgate"				=> "hulu|Lionsgate",
		#"local+food+sustainable+network"	=> "hulu|Local Food Sustainable Network",
		#"mgm"					=> "hulu|MGM",
		#"military+history"			=> "hulu|Military History",
		#"the+minisode+network"			=> "hulu|The Minisode Network",
		#"mojo"					=> "hulu|Mojo",
		#"mrc+studios"				=> "hulu|MRC Studios",
		#"mynetworktv"				=> "hulu|MyNetworkTV",
		#"nbc+sports"				=> "hulu|NBC Sports",
		#"nbc+universal+television+distribution"	=> "hulu|NBC Universal Television Distribution",
		#"nbc"					=> "hulu|NBC",
		#"nhl"					=> "hulu|NHL",
		#"oxygen"				=> "hulu|Oxygen",
		#"pbs"					=> "hulu|PBS",
		#"program+partners"			=> "hulu|Program Partners",
		#"sci+fi"				=> "hulu|SCI FI",
		#"shout!+factory"			=> "hulu|Shout! Factory",
		#"sleuth"				=> "hulu|Sleuth",
		#"sony"					=> "hulu|Sony",
		#"speed+racer+enterprises"		=> "hulu|Speed Racer Enterprises",
		#"speed"					=> "hulu|SPEED",
		#"stage+9"				=> "hulu|Stage 9",
		#"strike.tv"				=> "hulu|Strike.TV",
		#"sundance+channel"			=> "hulu|Sundance Channel",
		#"telenext+media"			=> "hulu|Telenext Media",
		#"tvg+interactive+horseracing"		=> "hulu|TVG Interactive Horseracing",
		#"tvguide"				=> "hulu|TVGuide",
		#"ums"					=> "hulu|UMS",
		#"usa"					=> "hulu|USA",
		#"viz+media"				=> "hulu|VIZ Media",
		#"vogue.tv"				=> "hulu|Vogue.TV",
		#"vuguru"				=> "hulu|Vuguru",
		#"warner+bros."				=> "hulu|Warner Bros.",
		#"the+wine+library"			=> "hulu|The Wine Library",
		#"wwe"					=> "hulu|WWE",
		#"the+zalman+king+company"		=> "hulu|The Zalman King Company",
	};
}


# Class cmdline Options
sub opt_format {
	return {
		outputhulu	=> [ 1, "outputhulu=s", 'Output', '--outputhulu <dir>', "Download output directory for hulu"],
	};
}


# Method to return optional list_entry format
sub optional_list_entry_format {
	my $prog = shift;
	return ", $prog->{channel}";
}



# Returns the modes to try for this prog type
sub modelist {
	my $prog = shift;
	my $modelist;
	
	# Deal with Hulu fallback modes
	# Valid modes are flashhigh,flashnormal,flashlow
	# flashhigh doesn't seem to be supported yet by rtmpdump due to requiring RTMPE (encrypted streaming)
	# 'rtmp' or 'flash' => 'flashnormal,flashlow'
	my @modes = split /,/, $opt->{vmode};
	for (@modes) {
		$_ = 'flashnormal,flashlow' if $_ eq 'rtmp' || $_ eq 'flash';
	}
	$opt->{vmode} = join ',', @modes;
	# Defaults
	if ( $opt->{vmode} eq 'auto' || ! $opt->{vmode} ) {
		$modelist = 'flashnormal,flashlow';
	} else {
		$modelist = $opt->{vmode};
	}
	return $modelist;
}



# Cleans up a pid and removes url parts that might be specified
sub clean_pid {
	my $prog = shift;

	# strip out any prefix leaving just numbers
	$prog->{pid} =~ s/[^\d]//g;
	# rewrite pid to be in correct form
	$prog->{pid} = 'hulu-'.$prog->{pid};
}



# get full episode metadata given pid and ua.
sub get_metadata {
	my $prog = shift;
	my $ua = shift;
	my $metadata;
	my ($name, $episode, $duration, $available, $channel, $expiry, $longdesc, $versions, $guidance, $prog_type, $categories, $player, $thumbnail);

	my $url = $prog->get_metadata_url( $ua );

	#    <switch>
	#      <video src="rtmp://cp39465.hulu.com/ondemand/?auth=daEbhaAdLakaVbsb8aLarb6cZbQcXcTaCc6-bjI2E9-8-3nLEyCnYHyu&amp;aifp=NS20070910&amp;slist=content/39814/9/842/HuluTranscode_31469_FLASH_480K_4x3_23_98__EilrFmip5kSuC5UQXYh6sQ&lt;break&gt;content/39814/9/842/HuluTranscode_31469_FLASH_480K_4x3_23_98__EilrFmip5kSuC5UQXYh6sQ"                                                                                                                                                 
	#      system-bitrate="516701" width="384" height="288"
	#      profile="4x3 24fps Medium" />
	#      <video src="rtmp://cp39465.hulu.com/ondemand/?auth=daEc1dkbdalc7c9cabbd1chagdzdMb2drbU-bjI2E9-8-ZqFCuCo0Jzn&amp;aifp=NS20070910&amp;slist=content/39814/9/842/HuluTranscode_31469_FLASH_700K_4x3_23_98__inQKbph8fEGc2PD1zT-X3g&lt;break&gt;content/39814/9/842/HuluTranscode_31469_FLASH_700K_4x3_23_98__inQKbph8fEGc2PD1zT-X3g"
	#      system-bitrate="750859" width="480" height="360"
	#      profile="4x3 24fps High" />
	#      <video src="rtmp://cp47346.edgefcs.net/ondemand/mp4:hulufms3/47311/9/842/HuluTranscode_31469_H_264_1Mbps_4x3_23_98__GpXVaGDdGU++XzofmLqcJQ.flv?auth=daEbBb8a7aqdEbMdRcbdXcDd7cNdmbMdAaz-bjI2E9-4q-3oFBACt1Ayu&amp;aifp=sll02152008&amp;slist=hulufms3/47311/9/842/HuluTranscode_31469_H_264_1Mbps_4x3_23_98__GpXVaGDdGU++XzofmLqcJQ.flv;.international=false"
	#      system-bitrate="998383" width="640" height="480"
	#      profile="4x3 24fps H264 Medium" />
	#      <ref src="rtmp://cp39465.hulu.com/ondemand/?auth=daEbhaAdLakaVbsb8aLarb6cZbQcXcTaCc6-bjI2E9-8-3nLEyCnYHyu&amp;aifp=NS20070910&amp;slist=content/39814/9/842/HuluTranscode_31469_FLASH_480K_4x3_23_98__EilrFmip5kSuC5UQXYh6sQ&lt;break&gt;content/39814/9/842/HuluTranscode_31469_FLASH_480K_4x3_23_98__EilrFmip5kSuC5UQXYh6sQ"
	#      title="What Makes Doogie Run"
	#      abstract="Vinnie convinces Doogie to enroll in an acting class. Enlightened by the experience, Doogie decides he has been on the fast tract too long, and decides to resign from Eastman and travel abroad."
	#      copyright="(c) 1992-1993 Twentieth Century Fox Film Corporation"
	#      dur="1380087ms" width="384" height="288"
	#      keywords="doogie,howser,comedy,neil,patrick,harris,vinnie,delphino,classics,fox,doctor,genius,david,kelley,steven,bochco,Best,Friend,Child,Prodigy,Dramedy,California,Operating,Room,Computer,Family,Medical,Sitcom,Boy,Genius,Doctor,Genius,Hospital,Journal"
	#      tp:Ad_Model="longform" tp:Aspect_Ratio="4x3"
	#      tp:CP_Promotional_Link="http://www.amazon.com/dp/B000EBGF6I?tag=hulu-20"
	#      tp:CP_Promotional_Text="Buy this season today"
	#      tp:CPIdentifier="Twentieth Century Fox Television"
	#      tp:Channel="Fox Television Classics" tp:Daypart="Prime Time"
	#      tp:Episode_Number="22" tp:Frame_Rate="24"
	#      tp:Primary_Category="Comedy"
	#      tp:Programming_Type="Full Episode"
	#      tp:Promotional_Type="non-promo" tp:Season_Number="4"
	#      tp:Segments="00:04:19;18,00:11:18;02,00:22:04;02"
	#      tp:Series_Title="Doogie Howser, M.D."
	#      tp:TMS_Program_ID="EP000171090113"
	#      tp:TMS_Series_ID="SH000171090000"
	#      tp:endCreditsTime="00:22:07;00" tp:hasBug="false"
	#      tp:isEmbeddable="True" tp:requiresEncryption="no"
	#      tp:seriesIdentifier="doogie-howser-md"
	#      tp:siteChannels="Drama|Comedy~Sitcoms" />
	#    </switch>
	my $xml = main::request_url_retry($ua, $url, 3, '.', "WARNING: Failed to get programme stream data for $prog->{name} from site\n");
	# flatten xml
	$xml =~ s/[\n\r]//g;

	decode_entities($xml);
	main::logger "DEBUG: $url:\n$xml\n\n" if $opt->{debug};
	# Flatten
	$xml =~ s|[\r\n]||g;
	
	# Extract categories
	$categories = $1 if $xml =~ m{tp:siteChannels="(.+?)"};
	$categories =~ s/\|/,/g;

	$name = $1 if $xml =~ m{tp:Series_Title="(.+?)"};

	$channel = $1 if $xml =~ m{tp:Channel="(.+?)"};

	( $episode, $longdesc ) = ( $1, $2 ) if $xml =~ m{title="([^"]+?)"\s+abstract="(.+?)"};

	$duration = $1 if $xml =~ m{dur="(.+?)\d\d\dms"};

	# Fill in from cache if not got from metadata
	my %metadata;
	$metadata{pid}		= $prog->{pid};
	$metadata{index}	= $prog->{index};
	$metadata{name}		= $name || $prog->{name};
	$metadata{episode}	= $episode || $prog->{episode};
	$metadata{type}		= $prog_type || $prog->{type};
	$metadata{duration}	= $duration || $prog->{duration};
	$metadata{channel}	= $channel || $prog->{channel};
	$metadata{available}	= $available || $prog->{available};
	$metadata{expiry}	= $expiry || $prog->{expiry};
	$metadata{versions}	= $versions || $prog->{versions};
	$metadata{guidance}	= $guidance || $prog->{guidance};
	$metadata{categories}	= $categories || $prog->{categories};
	$metadata{desc}		= $longdesc || $prog->{desc};
	$metadata{player}	= $player;
	$metadata{thumbnail}	= $thumbnail || $prog->{thumbnail};

	return %metadata;
}



# Usage: Programme::hulu->get_links( \%prog, 'hulu' );
# Uses: %{ channels() }, \%prog
sub get_links {
	shift; # ignore obj ref
	my $progref = shift;
	my $prog_type = shift;
	my %channels = %{ channels() };

	
	# Maximum number of pages per channel we scrape to get episodes (20 episdoes per page)
	# 10 results in 2000+ episodes ou of approx 9000
	my $hulu_max_pages_per_channel = 10;

	# What to sort the pages by: pub_date?, popularity, release, rating
	my $hulu_channel_page_sort = 'popularity';

	# What hulu prog types to get: episodes, feature_film, tv, clips, film_trailers, film_clips, movies
	# The two useful ones are episodes (9000+ full length TV episodes) and feature_film (200+ full-length movies)
	my @htypes = qw(feature_film episodes);
	

	main::logger "INFO: Getting hulu Index Feeds\n";
	# Setup User agent
	my $ua = main::create_ua('desktop');

	# Extract channels names from http://www.hulu.com/browse/network/episodes

	# Search URLs:
	#http://www.hulu.com/videos/search?sort_by=relevance&company=history&query=* (query must be at end)
	# Search for all full TV episodes on Fox => 1829 results: 
	# channels: 15+gigs fox sci-fi 
	# http://www.hulu.com/search/<channel>/<page>?sort_by=pub_date&type=episode
	# Limit by show name, insert: ?showname=doogie+howser%2C+m.d.&

	# Search for all full feature films on <channel>
	# http://www.hulu.com/search/<channel>/<page>?sort_by=pub_date&type=feature_film

	# For full-movie pages http://www.hulu.com/browse/alphabetical/feature_film
	# just search for 
	# add_to_playlist?video_id=(\d+?)'

	# Method used:
	# Use category-based channels like 'Comedy' using types: 'episodes'|'feature_film'

	# An expanded example is here:	  	
	#                   <div class="home-thumb">
	#                      <div class="home-play-container">
	#                        <span class="play-button-hover"><a href=
	#                        "http://www.hulu.com/watch/19199/gaytown-boiling-point?c=Comedy"
	#                        class="info_hover" onclick=
	#                        "SearchTracking.send(null, null, null, null, 'hulu_19199')">
	#                        <img src=
	#                        "http://thumbnails.hulu.com/7/925/19225_145x80_manicured__mLKcuWdu+E2pPh0pjfMQWw.jpg"
	#                        class="thumbnail" border="0" alt=
	#                        "Gaytown: Boiling Point (season 1, episode 8)"
	#                        width="145" height="80" title="" style=
	#                        "width: 145px; height: 80px;" /></a></span>
	#                        <span class="add-me"><a href="#" onclick=
	#                        "var self = this;; new Ajax.Request('/users/add_to_playlist?video_id=19199',
	#                        {asynchronous:true, evalScripts:true, onSuccess:function(request){if (typeof(Behaviors)
	#                         != 'undefined') {Behaviors.onQueueSuccess(self);}}}); return false;">
	#                        <img alt="" border="0" class="hover-me" id=
	#                        "icon-add.gif123395627913173" src=
	#                        "http://static.hulu.com/images/icon-add.gif?1233824978"
	#                        title="Queue this video" name=
	#                        "icon-add.gif123395627913173" /></a></span>
	#                      </div>
	#
	#                      <div class="show-title-container">
	#                        <img alt="Closed Captions available" class=
        #	                "closed-captions" height="12" src=
        #	                "http://static.hulu.com/images/icon-cc.png?1233824978"
        #       	         title="Closed Captions available" width=
        #               	 "17" /><a href=
	#                        "http://www.hulu.com/watch/19199/gaytown-boiling-point?c=Comedy"
	#                        class="show-title-gray info_hover">Gaytown:
	#                        <span class="episode-title">Boiling
	#                        Point</span></a>
	#                      </div><span class="video-info">Season 1 : Ep.
	#                      8&nbsp;&nbsp;&nbsp;(04:57)</span>
	#                      <span class="video-info">More: <a href=
	#                      "http://www.hulu.com/gaytown?c=Comedy" class=
	#                      "info_hover">Gaytown</a></span>
	#                    </div>
	## For films:
	#                      <div class="show-title-container">
	#                        <img alt="Closed Captions available" class=
	#                        "closed-captions" height="12" src=
	#                        "http://static.hulu.com/images/icon-cc.png?1233824978"
	#                        title="Closed Captions available" width=
	#                        "17" /> <a href=
	#                        "http://www.hulu.com/watch/49352/21-grams?c=Drama"
	#                        class="show-title-gray info_hover">21
	#                        Grams</a>
	#                      </div><span class="video-info">Feature
	#                      Film&nbsp;&nbsp;&nbsp;(2:04:37)</span>
	#                      <span class="video-info">More: <a href=
	#                      "http://www.hulu.com/21-grams?c=Drama" class=
	#                      "info_hover">21 Grams</a></span>
	#                    </div>

	for my $channel ( keys %channels ) {

		# Get incremental pages until no matches
		# http://www.hulu.com/channels/<channel>?kind=videos&page=<page>&sort=popularity&type=<type>

		# loop through both hulu prog types
		for my $htype ( @htypes ) {
			main::logger "DEBUG: Channel: $channel/$htype\n" if $opt->{verbose};

			# loop through each pageno until no episodes found (or max 10 pages per channel)
			my $page = 0;
			my $episode_count = 1;
			while ($episode_count != 0 && $page < $hulu_max_pages_per_channel) {
				$page++;
				$episode_count = 0;

				# Build Hulu URL
				my $hulu_prog_page_url = "http://www.hulu.com/channels/${channel}?kind=videos&page=${page}&sort=${hulu_channel_page_sort}&type=${htype}";

				# Get page
				my $html = main::request_url_retry($ua, $hulu_prog_page_url, 3, '.', "WARNING: Failed to get episode page for channel ${channel}, page ${page}, type ${htype}\n");
				# flatten html
				$html =~ s/[\n\r]//g;

				#loop through each episode section
				for my $entry ( split /class="home-play-container"/, $html ) { 

					# Extract episode data
					$entry =~ s/\&nbsp;/ /g;
					decode_entities($entry);

					my ($guidance, $name, $pid, $episode, $web, $thumbnail, $duration, $description );

					main::logger "DEBUG: Match Line: $entry\n" if $opt->{debug};
					# Extract pid
					$pid = $1 if $entry =~ m{href="http://www.hulu.com/watch/(\d+)/};

					# Construct web url
					$web = 'http://www.hulu.com/watch/'.$pid;

					# Prepend 'hulu-' to pid to keep as a GUID
					$pid = 'hulu-'.$pid;

					# Name
					$name = $1 if $entry =~ m{class="show-title-gray info_hover">\s*(.+?)\s*<}i;
					$name =~ s/:$//g;

					# Episode
					$episode = $1 if $entry =~ m{class="episode-title">\s*(.+?)\s*<}i;
					# Remove any '|'s
					$episode =~ s/\|/_/g;
					# Films don't have episode names
					$episode = 'Film' if !$episode;

					# Description
					( $description , $duration )= ( $1, $2 ) if $entry =~ m{class="video-info">\s*(.+?)\s*\(([\d:]+?)\)}i;

					# Extract thumbnail
					$thumbnail = $1 if $entry =~ m{<img\s+src="(http.+?)"\s+class="thumbnail"}i;

					# Guidance (subtitles)
					$guidance = 'Subtitles Available' if $entry =~ m{"Closed Captions available"}i;

					# skip if no data
					next if ! ($pid && $episode && $name);
					main::logger "DEBUG: PID: '$pid', Name: '$name', Episode: '$episode'\n" if $opt->{debug};
					$episode_count++;

					# Skip if this pid is a duplicate
					if ( defined $progref->{$pid} ) {
						main::logger "WARNING: '$pid, $progref->{$pid}->{name} - $progref->{$pid}->{episode}' in Channel: '$progref->{$pid}->{channel}' already exists (this name-episode = '$name - $episode' pid= $pid, channel = $channel)\n" if $opt->{verbose};
						# append categories here if we have a dup and category is not there already
						$progref->{$pid}->{categories} .= ",$channel" if $progref->{$pid}->{categories} !~ /$channel/;
						next;
					}

					# build data structure
					$progref->{$pid} = Programme::itv->new(
						'pid'		=> $pid,
						'name'		=> $name,
						'versions'	=> 'default',
						'episode'	=> $episode,
						'channel'	=> $channel,
						'guidance'	=> $guidance,
						'categories'	=> $channel,
						'desc'		=> $description,
						'duration'	=> $duration,
						'type'		=> 'hulu',
						'web'		=> $web,
						'thumbnail'	=> $thumbnail,
					);


				} # end of episode loop
				main::logger "INFO: Got $episode_count programmes\n" if $opt->{verbose};

			} # end of page loop

		} # end of htype loop

	} # end of channel loop


	main::logger "\n";
	return 0;
}


# This version only gets most recent series and results in about 5000 programmes
# Does not get films
# Usage: Programme::hulu->get_links( \%prog, 'hulu' );
# Uses: %{ channels() }, \%prog
sub get_links_old {
	shift; # ignore obj ref
	my $progref = shift;
	my $prog_type = shift;
	my %channels = %{ channels() };

	my $xml;
	my $res;
	my %series_pid;
	my %episode_pid;
	main::logger "INFO: Getting hulu Index Feeds\n";
	# Setup User agent
	my $ua = main::create_ua('desktop');

	# Extract channels names from http://www.hulu.com/browse/network/episodes

	# Search URLs:
	#http://www.hulu.com/videos/search?sort_by=relevance&company=history&query=* (query must be at end)
	# Search for all full TV episodes on Fox => 1829 results: 
	# channels: 15+gigs fox sci-fi 
	# http://www.hulu.com/search/<channel>/<page>?sort_by=pub_date&type=episode
	# Limit by show name, insert: ?showname=doogie+howser%2C+m.d.&

	# Search for all full feature films on <channel>
	# http://www.hulu.com/search/<channel>/<page>?sort_by=pub_date&type=feature_film

	# For full-movie pages http://www.hulu.com/browse/alphabetical/feature_film
	# just search for 
	# add_to_playlist?video_id=(\d+?)'

	# Use category-based channels like 'Comedy' using type: episodes|feature_film
	# http://www.hulu.com/channels/<channel>?kind=videos&page=2&sort=popularity&type=episodes

	# Method
	# http://www.hulu.com/browse/alphabetical/episode (gets url for each prog series) =>
	#  =>
	
	# Download index feed
	my $hulu_index_shows_url = 'http://www.hulu.com/browse/alphabetical/episode';

	# E.g.
	# <li class="full-episode-icon" onclick="window.location='http://www.hulu.com/the-facts-of-life';">
	# <a href="http://www.hulu.com/the-facts-of-life" class="show-thumb info_hover">The Facts Of Life</a></li>
	my $html = main::request_url_retry($ua, $hulu_index_shows_url, 3, '.', "WARNING: Failed to get hulu episode index from site\n");

	# flatten
	$html =~ s/[\n\r]//g;

	for my $s_line ( (split /<li\s+class="full-episode-icon"/, $html) ) {
	
		# Get page, search for relevent lines which contain series links and loop through each matching line
		my ($url, $name);
		# Extract series url + series description
		($url, $name) = ($1, $2) if $s_line =~ m{<a\s+href="\s*(http.+?)\s*"\s+class="show-thumb info_hover">(.+?)<\/a>};
		chomp($url);
		chomp($name);
		next if ! ($url && $name);
		main::logger "DEBUG: Series: '$name' URL: '$url'\n" if $opt->{verbose};

		# look for:
		# http://www.hulu.com/feed/show/<showid>/episodes
		# Another feed?
		# GET "http://r.hulu.com/videos?show_id=<showid>&sort=episode_number&order=asc&video_type=episode&items_per_page=20&page=3&unexpired_only=1"
		# Extract the feed url
		my $feed_url = "http://www.hulu.com/feed/show/$1/episodes" if main::request_url_retry($ua, $url, 3, '.', "WARNING: Failed to get ${name} index from site\n") =~ m{http://www.hulu.com/feed/show/(\d+?)/episodes};
		# Get the feed xml data
		my $xml = main::request_url_retry($ua, $feed_url, 3, '.', "WARNING: Failed to get XML feed for ${name} index from site\n");
		# flatten xml
		$xml =~ s/[\n\r]//g;

		# e.g.
		#   <channel>
		#    <atom:link type="application/rss+xml" rel="self"
		#    href="http://www.hulu.com/feed/show/24/episodes" />
		#    <title>Hulu - Episodes for Doogie Howser, M.D.</title>
		#    <link>http://www.hulu.com/feed</link>
		#    <description>Hulu - Episodes for Doogie Howser, M.D.</description>
		#    <pubDate>Thu, 05 Feb 2009 21:24:28 -0000</pubDate>
		#
		#    <item>
		#      <title>Doogie Howser, M.D.: What Makes Doogie Run (s4 | e22)</title>
		#      <guid isPermaLink="true">
		#      http://www.hulu.com/watch/30185/doogie-howser-md-what-makes-doogie-run#http%3A%2F%2Fwww.hulu.com%2Ffeed%2Fshow%2F24%2Fepisodes</guid>
		#      <link>
		#      http://www.hulu.com/watch/30185/doogie-howser-md-what-makes-doogie-run#http%3A%2F%2Fwww.hulu.com%2Ffeed%2Fshow%2F24%2Fepisodes</link>
		#	<description>
		#        <![CDATA[<a href="http://www.hulu.com/watch/30185/doogie-howser-md-what-makes-doogie-\
		#		run#http%3A%2F%2Fwww.hulu.com%2Ffeed%2Fshow%2F24%2Fepisodes"><img
		#		 src="http://thumbnails.hulu.com/9/842/31469_145x80_generated__TzOk71X7tE6DEvgMzoB1Fg.jpg" 
		#		align="right" hspace="10" vspace="10" width="145" height="80" border="0" />
		#		</a><p>Vinnie convinces Doogie to enroll in an acting class.  Enlightened by the experience, 
		#		Doogie decides he has been on the fast tract too long, and decides to resign from Eastman and travel abroad.</p>
		#		<p>Added: July 28, 2008<br/>Air date: March 24, 1993<br/>Duration: 23:00<br/>Rating: 4.6 / 5.0<br/></p>]]>
		#	</description>		
		#      <pubDate>Tue, 01 Jul 2008 00:00:00 -0000</pubDate>
		#      <media:thumbnail width="145"
		#      url="http://thumbnails.hulu.com/9/842/31469_145x80_generated__TzOk71X7tE6DEvgMzoB1Fg.jpg"
		#      height="80" />
		#      <media:credit>Twentieth Century Fox Television</media:credit>
		#      <media:player url="http://www.hulu.com/embed/xovA2hGgoYQjuAfB0lAWYg"
		#      width="512" height="296" />
		#    </item>

		for my $entry ( split /<item>/, $xml ) {
			decode_entities($entry);

			my ($guidance, $pid, $episode, $web, $thumbnail, $channel, $duration, $description );

			main::logger "DEBUG: Match Line: $entry\n" if $opt->{debug};

			# Extract episode data
			$episode = $1 if $entry =~ m{<title>.+?:\s+(.+?)<\/title>}i;
			# Remove any '|'s
			$episode =~ s/\|/_/g;

			# Extract pid
			$pid = $1 if $entry =~ m{<link>\s*http://www.hulu.com/watch/(\d+)/};

			# Construct web url
			$web = 'http://www.hulu.com/watch/'.$pid;

			# Prepend 'hulu-' to pid to keep as a GUID
			$pid = 'hulu-'.$pid;

			# Description
			$description = $1 if $entry =~ m{<description>.+?<p>\s*(.+?)\s*<\/p>}i;

			# Duration
			$duration = $1 if $entry =~ m{>Duration:\s*([\d:]+?)\s*<}i;


			# Extract thumbnail
			$thumbnail = $1 if $entry =~ m{<media:thumbnail.+?url="(http.+?)"}i;

			# Extract channel
			$channel = $1 if $entry =~ m{<media:credit>\s*(.+?)\s*<}i;

			# skip if no data
			next if ! ($pid && $episode);
			main::logger "DEBUG: PID: '$pid' Episode: '$episode'\n" if $opt->{debug};

			# Skip if this pid is a duplicate
			if ( defined $progref->{$pid} ) {
				main::logger "WARNING: '$pid, $progref->{$pid}->{name} - $progref->{$pid}->{episode}, $progref->{$pid}->{channel}' already exists (this channel = $channel)\n" if $opt->{verbose};
				next;
			}

			# build data structure
			$progref->{$pid} = Programme::itv->new(
				'pid'		=> $pid,
				'name'		=> $name,
				'versions'	=> 'default',
				'episode'	=> $episode,
				'channel'	=> $channel,
				'guidance'	=> $guidance,
				'categories'	=> '',
				'desc'		=> $description,
				'duration'	=> $duration,
				'type'		=> 'hulu',
				'web'		=> $web,
				'thumbnail'	=> $thumbnail,
			);
		}
	}

	main::logger "\n";
	return 0;
}


# Usage: download (<prog>, <ua>)
sub download {
	my $prog = shift;
	my $ua = shift; 
	my $mode = shift;
	my %version_pids;
	my %streamdata;
	my $url_2;
	my $got_url;

	# stream data
	# Display media stream data if required
	if ( $opt->{streaminfo} ) {
		main::display_stream_info( $prog, undef, 'all' );
		$opt->{quiet} = 1;
		return 'skip';
	}

	# if rtmpdump does not exist
	if ( ! main::exists_in_path($rtmpdump) ) {
		main::logger "WARNING: Required program $rtmpdump does not exist (see http://linuxcentre.net/getiplayer/installation and http://linuxcentre.net/getiplayer/download)\n";
		return 'next';
	}
	# Force raw mode if ffmpeg is not installed
	if ( ! main::exists_in_path($ffmpeg) ) {
		main::logger "\nWARNING: $ffmpeg does not exist - not converting flv file\n";
		$opt->{raw} = 1;
		$prog->{ext} = 'flv';
	} else {
		$prog->{ext} = 'avi';
	}

	# Get and set more meta data - Set the %prog values from metadata if they aren't already set
	my %metadata = $prog->get_metadata($ua);
	for ( qw/ name episode available duration thumbnail desc guidance / ) {
		$prog->{$_} = $metadata{$_} if ! $prog->{$_};
	}

	# Get all streams data because we might need the subtitles url also later
	my %all_stream_data = $prog->get_stream_data( undef, 'all');
	%streamdata = %{ $all_stream_data{$mode} } if $all_stream_data{$mode};
	#%streamdata = %{ $prog->get_stream_data( undef, $mode) };

	if ( ! $streamdata{streamurl} ) {
		main::logger "WARNING: No programme stream URLs were found for $mode, skipping\n";
		return 'next';
	}

	# Determine the correct filenames for this download
	if ( $prog->generate_filenames( "<name> - <episode> <pid> $mode" ) ) {
		# Create symlink if required
		$prog->create_symlink( $prog->{symlink}, $prog->{filename}) if $opt->{symlink};
		return 'skip';
	}
	
	# Skip from here if we are only testing downloads
	return 'skip' if $opt->{test};

	# Get subtitles if they exist and are required 
	# best to do this before d/l of file so that the subtitles can be enjoyed while download progresses
	my $subfile_done;
	my $subfile;
	if ( $opt->{subtitles} ) {
		$subfile_done = "$prog->{dir}/$prog->{fileprefix}.srt";
		$subfile = "$prog->{dir}/$prog->{fileprefix}.partial.srt";
		$ua->proxy( ['http'] => undef ) if $opt->{partialproxy};
		$prog->download_subtitles( $ua, $subfile, $all_stream_data{subtitles}{streamurl} );
		$ua->proxy( ['http'] => $opt->{proxy} ) if $opt->{partialproxy};
	}

	my $return;
	# Do rtmp download
	my $stream = Streamer::rtmp->new;
	$return = $stream->get( $ua, $streamdata{streamurl}, $prog, $mode, $streamdata{application}, $streamdata{tcurl}, $streamdata{authstring}, $streamdata{swfurl} );
	
	# Rename the subtitle file accordingly
	move($subfile, $subfile_done) if $opt->{subtitles} && -f $subfile;

	return $return;
}



# get Hulu subtitles stream then convert to srt
sub download_subtitles {
	my $prog = shift;
	my ( $ua, $file, $suburl ) = @_;
	my $subs;

	# Return if we have no url
	if (! $suburl) {
		main::logger "\nINFO: Subtitles not available\n";
		return 2;
	}

	main::logger "\nINFO: Getting Subtitles from $suburl\n" if $opt->{verbose};


	# Download subs
	$subs = main::request_url_retry($ua, $suburl, 2);
	if (! $subs ) {
		main::logger "\nERROR: Subtitle Download failed\n";
		return 1;
	} else {
		main::logger "\nINFO: Downloaded Subtitles\n";
	}

	# Convert smil the format to srt
	# SRT:
	#1
	#00:01:22,490 --> 00:01:26,494
	#Next round!
	#
	#2
	#00:01:33,710 --> 00:01:37,714
	#Now that we've moved to paradise, there's nothing to eat.
	#
	# SMIL:
	# timestamps are in milliseconds
	#   <Sync Start="18664">
	#      <P Class="ENCC">I got a call from an old friend,
	#      <br />heard Scylla was</P>
	#    </Sync>
	#    <Sync Start="20864">
	#      <P Class="ENCC">in play and he wants to know</P>
	#    </Sync>
	#    <Sync Start="21864">
	#      <P Class="ENCC">if he can get in on it.
	#      <br />I've set up a safe house</P>
	#    </Sync>
	#    <Sync Start="23598">
	#      <P Class="ENCC">where you can hear him out.</P>
	#    </Sync>
	#    <Sync Start="25031">
	#      <P Class="ENCC">Do you have a pen?
	#      <br />Just a minute.</P>
	#    </Sync>
	#    <Sync Start="26431">
	#      <P Class="ENCC">1917 Piermont.</P>
	#    </Sync>
	
	# TT:
	#<p begin="0:01:12.400" end="0:01:13.880">Thinking.</p>
	#<p begin="00:01:01.88" id="p15" end="00:01:04.80"><span tts:color="cyan">You're thinking of Hamburger Hill...<br /></span>Since we left...</p>
	#<p begin="00:00:18.48" id="p0" end="00:00:20.52">APPLAUSE AND CHEERING</p>

	my $count = 1;
	# flatten
	$subs =~ s/[\r\n]//g;
	# $subdata{<count>}{start|end|text} = 'value';
	my %subdata; 
	my @lines = split /<Sync\s/i, $subs;
	for ( @lines ) {
		my ( $begin, $sub );
		# Remove span elements
		s|<\/?span.*?>| |g;
		# Remove <br /> elements
		s|<br.*?>| |g;
		# Start="2284698"><P Class="ENCC">I won't have to drink it<br />in this crappy warehouse.</P></Sync>
		( $begin, $sub ) = ( $1, $2 ) if m{.*Start="(.+?)".+<P.+?>(.+?)<\/p>.*?<\/Sync>}i;
		decode_entities($sub);
		if ($begin && $sub ) { ### !~ /^.amp.nbsp.$/ ) {
			# Convert milliseconds into HH:MM:ss,mmm format
			my $seconds = int( $begin / 1000.0 );
			my $ms = $begin - ( $seconds * 1000.0 );
			$begin = sprintf("%02d:%02d:%02d,%03d", (gmtime($seconds))[2,1,0], $ms );
			decode_entities($sub);
			# Remove any simple html elements
			$sub =~ s|<\/?(\w)+>| |g;
			# strip multispaces
			$sub =~ s/\s+/ /g;
			# Write to file
			$subdata{$count}{start} = $begin;
			$subdata{$count}{text} = $sub;
			# set the end of the previous sub line
			$subdata{$count-1}{end} = $begin;
			$count++;
		}
	}	
	$subdata{$count-1}{end} = $subdata{$count-1}{start};

	# Open subs file
	unlink($file);
	my $fh = main::open_file_append($file);

	# write each sub to file
	for my $count ( sort {$a <=> $b} keys %subdata ) {
		if ( $subdata{$count}{start} && $subdata{$count}{text} && $subdata{$count}{end} ) {
			#main::logger "$count\n$subdata{$count}{start} --> $subdata{$count}{end}\n$subdata{$count}{text}\n\n";
			print $fh "$count\n$subdata{$count}{start} --> $subdata{$count}{end}\n$subdata{$count}{text}\n\n";
		}
	}

	close $fh;

	return 0;
}


# retrieves the metadata URL for hulu and sets $prog->{metadata_url} - also returns it
sub get_metadata_url {
	my $prog = shift;
	my $ua = shift;

	return $prog->{metadata_url} if $prog->{metadata_url};

	# Don't rely on {web} being set (espcially if were called using --pid) - use {pid}
	$prog->{web} = $prog->{pid};
	# strip out any prefix leaving just numbers
	$prog->{web} =~ s/[^\d]//g;
	# rewrite pid to be in correct form
	$prog->{pid} = 'hulu-'.$prog->{web};
	# Add in the web page prefix
	$prog->{web} = 'http://www.hulu.com/watch/'.$prog->{web};

	# download/stream method.....
	# GET $web -> $cid = grep UserHistory.add_watched_history(\d+)
	# GET http://r.hulu.com/videos?content_id=$cid
	# $pid = ^^^->{video}->{pid}
	# $xml = GET http://releasegeo.hulu.com/content.select?pid=$pid&mbr=true&format=smil

	# GET $web -> $cid = grep UserHistory.add_watched_history(\d+)
	my $html = main::request_url_retry($ua, $prog->{web}, 3, '.', "WARNING: Failed to get programme page for $prog->{name} from site\n");
	my $cid = $1 if $html =~ m{UserHistory.add_watched_history\((\d+)\)};
	main::logger "INFO: CID=$cid\n" if $opt->{verbose};

	# GET http://r.hulu.com/videos?content_id=$cid
	my $html = main::request_url_retry($ua, "http://r.hulu.com/videos?content_id=$cid", 3, '.', "WARNING: Failed to get programme metadata for $prog->{name} from site\n");
	main::logger "DEBUG: http://r.hulu.com/videos?content_id=$cid :\n\n$html\n\n" if $opt->{debug};
	my $hpid = $1 if $html=~ m{<pid>(.+?)<\/pid>};
	main::logger "INFO: HPID=$hpid\n" if $opt->{verbose};

	$prog->{subtitle_url} = "http://www.hulu.com/transcripts/$hpid.smi";
	$prog->{metadata_url} = "http://releasegeo.hulu.com/content.select?pid=$hpid&mbr=true&format=smil";
	return $prog->{metadata_url};
}


# Gets media streams data for this version pid
# $media = flashhigh|flashnormal|flashlow|all
sub get_stream_data {
	my ( $prog, $verpid, $media ) = @_;
	my %data;

	# Setup user agent with redirection enabled
	my $ua = main::create_ua('desktop');
	$opt->{quiet} = 0 if $opt->{streaminfo};

	my $url = $prog->get_metadata_url( $ua );

	#<smil xmlns="http://www.w3.org/2001/SMIL20/Language"
	#xmlns:tp="http://xml.theplatform.com/mps/metadata/content/custom">
	#  <head>                                                          
	#	#    <meta base="http://p.hulu.com/Default.aspx/" />               
	#  </head>                                                         
	#  <body>                                                          
	#    <switch>                                                      
	#      <ref src="getPlaylist?nwid=55212&amp;content=9250783&amp;adType=&amp;adsRatingOverride=&amp;level=Comedy:SH000171090000&amp;attr=[Daypart,Prime+Time][ContentProvider,Twentieth+Century+Fox+Television][Series,SH000171090000][Network,Fox+Television+Classics][ContentID,9250783][rating,Not+Rated][AdModel,longform][pid,dT23irk_fUOTvyHuPYQ9kwFy5V_TgovF]"                                                                                                                    
	#      title="Lightningcast Ads - PreMidPost"                                                                                                                 
	#      copyright="(c) NS DP Newsite" no-skip="true"                                                                                                           
	#      tags="pre,mid,post" />                                                                                                                                 
	#    </switch>                                                                                                                                                
	#    <switch>                                                                                                                                                 
	#      <video src="rtmp://cp39465.hulu.com/ondemand/?auth=daEbhaAdLakaVbsb8aLarb6cZbQcXcTaCc6-bjI2E9-8-3nLEyCnYHyu&amp;aifp=NS20070910&amp;slist=content/39814/9/842/HuluTranscode_31469_FLASH_480K_4x3_23_98__EilrFmip5kSuC5UQXYh6sQ&lt;break&gt;content/39814/9/842/HuluTranscode_31469_FLASH_480K_4x3_23_98__EilrFmip5kSuC5UQXYh6sQ"                                                                                                                                                 
	#      system-bitrate="516701" width="384" height="288"                                                                                                       
	#      profile="4x3 24fps Medium" />
	#      <video src="rtmp://cp39465.hulu.com/ondemand/?auth=daEc1dkbdalc7c9cabbd1chagdzdMb2drbU-bjI2E9-8-ZqFCuCo0Jzn&amp;aifp=NS20070910&amp;slist=content/39814/9/842/HuluTranscode_31469_FLASH_700K_4x3_23_98__inQKbph8fEGc2PD1zT-X3g&lt;break&gt;content/39814/9/842/HuluTranscode_31469_FLASH_700K_4x3_23_98__inQKbph8fEGc2PD1zT-X3g"
	#      system-bitrate="750859" width="480" height="360"
	#      profile="4x3 24fps High" />
	#      <video src="rtmp://cp47346.edgefcs.net/ondemand/mp4:hulufms3/47311/9/842/HuluTranscode_31469_H_264_1Mbps_4x3_23_98__GpXVaGDdGU++XzofmLqcJQ.flv?auth=daEbBb8a7aqdEbMdRcbdXcDd7cNdmbMdAaz-bjI2E9-4q-3oFBACt1Ayu&amp;aifp=sll02152008&amp;slist=hulufms3/47311/9/842/HuluTranscode_31469_H_264_1Mbps_4x3_23_98__GpXVaGDdGU++XzofmLqcJQ.flv;.international=false"
	#      system-bitrate="998383" width="640" height="480"
	#      profile="4x3 24fps H264 Medium" />
	#      <ref src="rtmp://cp39465.hulu.com/ondemand/?auth=daEbhaAdLakaVbsb8aLarb6cZbQcXcTaCc6-bjI2E9-8-3nLEyCnYHyu&amp;aifp=NS20070910&amp;slist=content/39814/9/842/HuluTranscode_31469_FLASH_480K_4x3_23_98__EilrFmip5kSuC5UQXYh6sQ&lt;break&gt;content/39814/9/842/HuluTranscode_31469_FLASH_480K_4x3_23_98__EilrFmip5kSuC5UQXYh6sQ"
	#      title="What Makes Doogie Run"
	#      abstract="Vinnie convinces Doogie to enroll in an acting class. Enlightened by the experience, Doogie decides he has been on the fast tract too long, and decides to resign from Eastman and travel abroad."
	#      copyright="(c) 1992-1993 Twentieth Century Fox Film Corporation"
	#      dur="1380087ms" width="384" height="288"
	#      keywords="doogie,howser,comedy,neil,patrick,harris,vinnie,delphino,classics,fox,doctor,genius,david,kelley,steven,bochco,Best,Friend,Child,Prodigy,Dramedy,California,Operating,Room,Computer,Family,Medical,Sitcom,Boy,Genius,Doctor,Genius,Hospital,Journal"
	#      tp:Ad_Model="longform" tp:Aspect_Ratio="4x3"
	#      tp:CP_Promotional_Link="http://www.amazon.com/dp/B000EBGF6I?tag=hulu-20"
	#      tp:CP_Promotional_Text="Buy this season today"
	#      tp:CPIdentifier="Twentieth Century Fox Television"
	#      tp:Channel="Fox Television Classics" tp:Daypart="Prime Time"
	#      tp:Episode_Number="22" tp:Frame_Rate="24"
	#      tp:Primary_Category="Comedy"
	#      tp:Programming_Type="Full Episode"
	#      tp:Promotional_Type="non-promo" tp:Season_Number="4"
	#      tp:Segments="00:04:19;18,00:11:18;02,00:22:04;02"
	#      tp:Series_Title="Doogie Howser, M.D."
	#      tp:TMS_Program_ID="EP000171090113"
	#      tp:TMS_Series_ID="SH000171090000"
	#      tp:endCreditsTime="00:22:07;00" tp:hasBug="false"
	#      tp:isEmbeddable="True" tp:requiresEncryption="no"
	#      tp:seriesIdentifier="doogie-howser-md"
	#      tp:siteChannels="Drama|Comedy~Sitcoms" />
	#    </switch>
	#  </body>
	#</smil>
	my $xml1 = main::request_url_retry($ua, $url, 3, '.', "WARNING: Failed to get programme stream data for $prog->{name} from site\n");
	# flatten xml1
	$xml1 =~ s/[\n\r]//g;

	# Each prog has up to 3 different qualities/bitrates available. They start with '<video src='
	# This loop names them respectively
	for my $xml ( split /<video/, $xml1 ) {
		$xml = "<video".$xml;
		my $prog_type;

		#      <video src="rtmp://cp39465.hulu.com/ondemand/?auth=daEbhaAdLakaVbsb8aLarb6cZbQcXcTaCc6-bjI2E9-8-3nLEyCnYHyu&amp;aifp=NS20070910&\
		#	slist=content/39814/9/842/HuluTranscode_31469_FLASH_480K_4x3_23_98__EilrFmip5kSuC5UQXYh6sQ<break>\
		#	content/39814/9/842/HuluTranscode_31469_FLASH_480K_4x3_23_98__EilrFmip5kSuC5UQXYh6sQ"
		#      system-bitrate="516701" width="384" height="288"
		#      profile="4x3 24fps Medium" />
		#
		#     <video src="rtmp://cp47346.edgefcs.net/ondemand/mp4:hulufms3/47311/11/841/HuluTranscode_45826_28030_H_264_1Mbps_4x3_29_\
		#	 97__Dd7ie-YcyEq2-8Jf18VTKg.flv?auth=daEbxdldwabdJbBdmb1dzcvd4cebIbRaxcg-bjJb0J-4q-ZqGEtCo1Fyt&aifp=sll02152008&slist=\
		#	 hulufms3/47311/11/841/HuluTranscode_45826_28030_H_264_1Mbps_4x3_29_97__Dd7ie-YcyEq2-8Jf18VTKg.flv;.international=false" 
		#	system-bitrate="998123" width="640" height="480" 
		#	profile="4x3 30fps H264 Medium"/>
		#
		# application: "ondemand?_fcs_vhost=${server_hostname}&auth=${auth}&aifp=NS20070910&slist=${playpath}"
		# flashver: "WIN 10,0,1.2,36"
		# swfurl: "http://www.hulu.com/player.swf"
		# tcurl: "rtmp://${serverip}:1935/${app}"
		# pageurl: "http://www.hulu.com/watch/2711/family-guy-padre-de-familia"
		# application: "ondemand?_fcs_vhost=${server_hostname}&auth=${auth}&aifp=sll02152008&slist=${playpath};.international=false"
		#
		decode_entities($xml);
		# Get RTMPURL, bitrate, width, height, profilename
		if ( $xml =~ m{<video\s+src="(rtmp.+?)".+?system-bitrate="(\d+?)"\s*width="(\d+?)"\s*height="(\d+?)"\s*profile="(.+?)"}i ) {
			# initially set the key to be the 'bitrate|profile' so we can sort/rename keys afterwards
			my ($rtmpurl, $bitrate, $width, $height, $profile) = ($1, $2, $3, $4, $5);
			$prog_type = "$bitrate|$profile";
			main::logger "DEBUG: stream XML: $xml\nDEBUG: RTMPurl = '$1', bitrate = '$2', profile = '$5'\n\n" if $opt->{debug};
			main::logger "DEBUG: Processing $profile (bitrate = $bitrate) stream\n" if $opt->{verbose};
			$data{$prog_type}{streamurl} = $rtmpurl;
			$data{$prog_type}{type} = "Flash RTMP $profile stream";
			$data{$prog_type}{bitrate} = $bitrate;
			$data{$prog_type}{width} = $width;
			$data{$prog_type}{height} = $height;
			# if <break> is in streamurl then strip from there
			$data{$prog_type}{streamurl} =~ s|<break>.*$||g;
			my ( $servername, $parameters, $playpath );
			( $servername, $parameters ) = ( $1, $2 ) if $data{$prog_type}{streamurl} =~ m{rtmp://(.+?)/.*ondemand.*(auth.+)$};
			# get playpath if necessary
			$playpath = $1 if $data{$prog_type}{streamurl} =~ m{rtmp://.+?ondemand/(.+?)\?};
			if( $playpath ) {
				$data{$prog_type}{streamurl} = "rtmp://$servername:1935/ondemand?_fcs_vhost=$servername&slist=$playpath";	
			} else {
				$data{$prog_type}{streamurl} = "rtmp://$servername:1935/ondemand?_fcs_vhost=$servername&$parameters";
			}
			# strip out .international from streamurl
			$data{$prog_type}{streamurl} =~ s/\;\.international.*$//;
			$data{$prog_type}{application} = "ondemand?_fcs_vhost=$servername&$parameters";
			$data{$prog_type}{tcurl}   = "rtmp://".inet_ntoa(inet_aton($servername)).":1935/ondemand?_fcs_vhost=$servername&$parameters";
			$data{$prog_type}{swfurl} = "http://www.hulu.com/player.swf";
			$data{$prog_type}{flashver} = "WIN 10,0,1.2,36";
		}
	}

	# Sort and rename %data keys to flash(high|normal|low) based on bitrate
	#my @modename = qw( flashhigh flashnormal flashlow flashverylow );
	#my $count = 1;
	#for my $old ( reverse sort {$a <=> $b} keys %data ) {
	#	# Get the next modename
	#	my $vmode = shift @modename;
	#	# Create new key
	#	main::logger "DEBUG: Renaming mode '$old' to '$vmode'\n" if $opt->{debug};
	#	$data{$vmode} = $data{$old};
	#	# Remove old key
	#	delete $data{$old};
	#}
	# Now do this on bitrate range mapping - works better if there is no 1Mbps version
	for my $old ( reverse sort {$a <=> $b} keys %data ) {
		my $vmode;
		# Get the next modename
		if ( $data{$old}{bitrate} > 800000 ) {
			$vmode = 'flashhigh';
		} elsif ( $data{$old}{bitrate} > 600000 ) {
			$vmode = 'flashnormal';
		} elsif ( $data{$old}{bitrate} > 400000 ) {
			$vmode = 'flashlow';
		} elsif ( $data{$old}{bitrate} > 200000 ) {
			$vmode = 'flashverylow';
		} else {
			main::logger "INFO: unmatched mode '$old'\n";
			next;
		}
		main::logger "DEBUG: Renaming mode '$old' to '$vmode'\n" if $opt->{verbose};
		$data{$vmode} = $data{$old};
		delete $data{$old};
	}

	# Check if subtitles are available (broken with --pid) then creates the URL for the smil file
	if ( $prog->{subtitle_url} ) { # && $prog->{guidance} =~ /captions|subtitles/i ) {
		$data{subtitles}{type} = 'Subtitles stream';
		$data{subtitles}{streamurl} = $prog->{subtitle_url};
	}

	# Return a hash with media => url if 'all' is specified - otherwise just the specified url
	if ( $media eq 'all' ) {
		return %data;
	} else {
		# Make sure this hash exists before we pass it back...
		$data{$media}{exists} = 0 if not defined $data{$media};
		return $data{$media};
	}
}



################### Streamer class #################
package Streamer;

# Class vars
# Global options
my $optref;
my $opt;


# Constructor
# Usage: $streamer = Streamer->new();
sub new {
	my $type = shift;
	my %params = @_;
	my $self = {};
	for (keys %params) {
		$self->{$_} = $params{$_};
	}
	# Ensure the subclass $opt var is pointing to the Superclass global optref
	$opt = $Streamer::optref;
	bless $self, $type;
}


# Use to bind a new options ref to the class global $optref var
sub add_opt_object {
	my $self = shift;
	$Streamer::optref = shift;
}


# $opt->{<option>} access method
sub opt {
	my $self = shift;
	my $optname = shift;
	return $opt->{$optname};
}


################### Streamer::iphone class #################
package Streamer::iphone;

# Inherit from Streamer class
use base 'Streamer';

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
use Time::Local;
use URI;



# Generic
# Get streaming iphone URL
sub get_url {
	shift;
	my $ua = shift;
	my $pid = shift;

	# Create url with appended 6 digit random number
	my $url_1 = ${iphone_download_prefix}.'/'.${pid}.'?'.(sprintf "%06.0f", 1000000*rand(0)).'%20';
	main::logger "INFO: media stream download URL = $url_1\n" if $opt->{verbose};
		
	# Stage 2: e.g. "Location: http://download.iplayer.bbc.co.uk/iplayer_streaming_http_mp4/121285241910131406.mp4?token=iVXexp1yQt4jalB2Hkl%2BMqI25nz2WKiSsqD7LzRmowrwXGe%2Bq94k8KPsm7pI8kDkLslodvHySUyU%0ApM76%2BxEGtoQTF20ZdFjuqo1%2B3b7Qmb2StOGniozptrHEVQl%2FYebFKVNINg%3D%3D%0A"
	main::logger "\rGetting iplayer download URL         " if (! $opt->{verbose}) && ! $opt->{streaminfo};
	my $h = new HTTP::Headers(
		'User-Agent'	=> $user_agent{coremedia},
		'Accept'	=> '*/*',
		'Range'		=> 'bytes=0-1',
	);
	my $req = HTTP::Request->new ('GET', $url_1, $h);
	# send request (use simple_request here because that will not allow redirects)
	my $res = $ua->simple_request($req);
	# Get resulting Location header (i.e. redirect URL)
	my $url_2 = $res->header("location");
	if ( ! $res->is_redirect ) {
		main::logger "ERROR: Failed to get redirect from iplayer site\n\n";
		return '';
	}
	# Extract redirection Location URL
	$url_2 =~ s/^Location: (.*)$/$1/g;
	# If we get a Redirection containing statuscode=404 then this prog is not yet ready
	if ( $url_2 =~ /statuscode=404/ ) {
		main::logger "\rERROR: Programme is not yet ready for download\n" if $opt->{verbose};
		return '';
	}

	return $url_2;
}



# %prog (only for %prog for mode and tagging)
# Get the h.264/mp3 stream
# ( $ua, $url_2, $prog '0|1 == rearrange moov' )
sub get {
	my ( $stream, $ua, $url_2, $prog, $rearrange ) = @_;
	my $childpid;

	# Stage 3a: Download 1st byte to get exact file length
	main::logger "INFO: Stage 3 URL = $url_2\n" if $opt->{verbose};

	# Override the $rearrange value is --raw option is specified
	$rearrange = 0 if $opt->{raw};
	
	# Setup request header
	my $h = new HTTP::Headers(
		'User-Agent'	=> $user_agent{coremedia},
		'Accept'	=> '*/*',
		'Range'		=> 'bytes=0-1',
	);
	# detect bad url => not available
	if ( $url_2 !~ /^http:\/\// ) {
		main::logger "WARNING: iphone version not available\n";
		return 'next';
	}
	my $req = HTTP::Request->new ('GET', $url_2, $h);
	my $res = $ua->request($req);
	# e.g. Content-Range: bytes 0-1/181338136 (return if no content length returned)
	my $download_len = $res->header("Content-Range");
	if ( ! $download_len ) {
		main::logger "WARNING: iphone version not available\n";
		return 'retry';
	}
	$download_len =~ s|^bytes 0-1/(\d+).*$|$1|;
	main::logger "INFO: Download File Length $download_len\n" if $opt->{verbose};

	# Only do this if we're rearranging QT streams
	my $mdat_start = 0;
	# default to this if we are not rearranging (tells the download chunk loop where to stop - i.e. EOF instead of end of mdat atom)
	my $moov_start = $download_len + 1;
	my $header;
	if ($rearrange) {
		# Get ftyp+wide header etc
		$mdat_start = 0x1c;
		my $buffer = main::download_block(undef, $url_2, $ua, 0, $mdat_start + 4);
		# Get bytes upto (but not including) mdat atom start -> $header
		$header = substr($buffer, 0, $mdat_start);
		
		# Detemine moov start
		# Get mdat_length_chars from downloaded block
		my $mdat_length_chars = substr($buffer, $mdat_start, 4);
		my $mdat_length = bytestring_to_int($mdat_length_chars);
		main::logger "DEBUG: mdat_length = ".get_hex($mdat_length_chars)." = $mdat_length\n" if $opt->{debug};
		main::logger "DEBUG: mdat_length (decimal) = $mdat_length\n" if $opt->{debug};
		# The MOOV box starts one byte after MDAT box ends
		$moov_start = $mdat_start + $mdat_length;
	}

	# If we have partial content and wish to stream, resume the download & spawn off STDOUT from existing file start 
	# Sanity check - we cannot support downloading of partial content if we're streaming also. 
	if ( $opt->{stdout} && (! $opt->{nowrite}) && -f $prog->{filepart} ) {
		main::logger "WARNING: Partially downloaded file exists, streaming will start from the beginning of the programme\n";
		# Don't do usual streaming code - also force all messages to go to stderr
		delete $opt->{stdout};
		$opt->{stderr} = 1;
		$childpid = fork();
		if (! $childpid) {
			# Child starts here
			main::logger "INFO: Streaming directly for partially downloaded file $prog->{filepart}\n";
			if ( ! open( STREAMIN, "< $prog->{filepart}" ) ) {
				main::logger "INFO: Cannot Read partially downloaded file to stream\n";
				exit 4;
			}
			my $outbuf;
			# Write out until we run out of bytes
			my $bytes_read = 65536;
			while ( $bytes_read == 65536 ) {
				$bytes_read = read(STREAMIN, $outbuf, 65536 );
				#main::logger "INFO: Read $bytes_read bytes\n";
				print STDOUT $outbuf;
			}
			close STREAMIN;
			main::logger "INFO: Stream thread has completed\n";
			exit 0;
		}
	}

	# Open file if required
	my $fh = main::open_file_append($prog->{filepart});

	# If the partial file already exists, then resume from the correct mdat/download offset
	my $restart_offset = 0;
	my $moovdata;
	my $moov_length = 0;

	if ($rearrange) {
		# if cookie fails then trigger a retry after deleting cookiejar
		# Determine orginal moov atom length so we can work out if the partially downloaded file has the moov atom in it already
		$moov_length = bytestring_to_int( main::download_block( undef, $url_2, $ua, $moov_start, $moov_start+3 ) );
		main::logger "INFO: original moov atom length = $moov_length                          \n" if $opt->{verbose};
		# Sanity check this moov length - chances are that were being served up a duff file if this is > 10% of the file size or < 64k
		if ( $moov_length > (${moov_start}/9.0) || $moov_length < 65536 ) {
			main::logger "WARNING: Bad file download, deleting cookie                 \n";
			$ua->cookie_jar( HTTP::Cookies->new( file => $cookiejar, autosave => 0, ignore_discard => 0 ) );
			unlink $cookiejar;
			unlink $prog->{filepart};
			return 'retry';
		}

		# we still need an accurate moovlength for the already downloaded moov atom for resume restart_offset.....
		# If we have no existing file, a file which doesn't yet even have the moov atom, or using stdout (or no-write option)
		# (allow extra 1k on moov_length for metadata when testing)
		if ( $opt->{stdout} || $opt->{nowrite} || stat($prog->{filepart})->size < ($moov_length+$mdat_start+1024) ) {
			# get moov chunk into memory
			$moovdata = main::download_block( undef, $url_2, $ua, $moov_start, (${download_len}-1) );

			# Create new udta atom with child atoms for metadata
			my $udta_new = create_qt_atom('udta',
				create_qt_atom( chr(0xa9).'nam', $prog->{name}.' - '.$prog->{episode}, 'string' ).
				create_qt_atom( chr(0xa9).'alb', $prog->{name}, 'string' ).
				create_qt_atom( chr(0xa9).'trk', $prog->{episode}, 'string' ).
				create_qt_atom( chr(0xa9).'aut', $prog->{channel}, 'string' ).
				create_qt_atom( chr(0xa9).'ART', $prog->{channel}, 'string' ).
				create_qt_atom( chr(0xa9).'des', $prog->{desc}, 'string' ).
				create_qt_atom( chr(0xa9).'cmt', 'Downloaded with get_iplayer', 'string' ).
				create_qt_atom( chr(0xa9).'req', 'QuickTime 6.0 or greater', 'string' ).
				create_qt_atom( chr(0xa9).'day', (localtime())[5] + 1900, 'string' )
			);
			# Insert new udta atom over the old one and get the new $moov_length (and update moov atom size field)
			replace_moov_udta_atom ( $udta_new, $moovdata );

			# Process the moov data so that we can relocate it (change the chunk offsets that are absolute)
			# Also update moov+_length to be accurate after metadata is added etc
			$moov_length = relocate_moov_chunk_offsets( $moovdata );
			main::logger "INFO: New moov atom length = $moov_length                          \n" if $opt->{verbose};
			# write moov atom to file next (yes - were rearranging the file - header+moov+mdat - not header+mdat+moov)
			main::logger "INFO: Appending ftype+wide+moov atoms to $prog->{filepart}\n" if $opt->{verbose};
			# Write header atoms (ftyp, wide)
			print $fh $header if ! $opt->{nowrite};
			print STDOUT $header if $opt->{stdout};
			# Write moov atom
			print $fh $moovdata if ! $opt->{nowrite};
			print STDOUT $moovdata if $opt->{stdout};
			# If were not resuming we want to only start the download chunk loop from mdat_start 
			$restart_offset = $mdat_start;
		}

		# Get accurate moov_length from file (unless stdout or nowrite options are specified)
		# Assume header+moov+mdat atom layout
		if ( (! $opt->{stdout}) && (! $opt->{nowrite}) && stat($prog->{filepart})->size > ($moov_length+$mdat_start) ) {
				main::logger "INFO: Getting moov atom length from partially downloaded file $prog->{filepart}\n" if $opt->{verbose};
				if ( ! open( MOOVDATA, "< $prog->{filepart}" ) ) {
					main::logger "ERROR: Cannot Read partially downloaded file\n";
					return 4;
				}
				my $data;
				seek(MOOVDATA, $mdat_start, 0);
				if ( read(MOOVDATA, $data, 4, 0) != 4 ) {
					main::logger "ERROR: Cannot Read moov atom length from partially downloaded file\n";
					return 4;
				}
				close MOOVDATA;
				# Get moov atom size from file
				$moov_length = bytestring_to_int( substr($data, 0, 4) );
				main::logger "INFO: moov atom length (from partially downloaded file) = $moov_length                          \n" if $opt->{verbose};
		}
	}

	# If we have a too-small-sized file (greater than moov_length+mdat_start) and not stdout and not no-write then this is a partial download
	if (-f $prog->{filepart} && (! $opt->{stdout}) && (! $opt->{nowrite}) && stat($prog->{filepart})->size > ($moov_length+$mdat_start) ) {
		# Calculate new start offset (considering that we've put moov first in file)
		$restart_offset = stat($prog->{filepart})->size - $moov_length;
		main::logger "INFO: Resuming download from $restart_offset                        \n";
	}

	# Not sure if this is already done in download method???
	# Create symlink if required
	$prog->create_symlink( $prog->{symlink}, $prog->{filepart} ) if $opt->{symlink};

	# Start marker
	my $start_time = time();

	# Download mdat in blocks
	my $chunk_size = $iphone_block_size;
	for ( my $s = $restart_offset; $s < ${moov_start}-1; $s+= $chunk_size ) {
		# get mdat chunk into file
		my $retcode;
		my $e;
		# Get block end offset
		if ( ($s + $chunk_size - 1) > (${moov_start}-1) ) {
			$e = $moov_start - 1;
		} else {
			$e = $s + $chunk_size - 1;
		}
		# Get block from URL and append to $prog->{filepart}
		if ( main::download_block($prog->{filepart}, $url_2, $ua, $s, $e, $download_len, $fh ) ) {
			main::logger "ERROR: Could not download block $s - $e from $prog->{filepart}\n\n";
			return 'retry';
		}
	}

	# end marker
	my $end_time = time();

	# Calculate average speed, duration and total bytes downloaded
	main::logger sprintf("INFO: Downloaded %.2fMB in %s at %5.0fkbps to %s\n", 
		($moov_start - 1 - $restart_offset) / (1024.0 * 1024.0),
		sprintf("%02d:%02d:%02d", ( gmtime($end_time - $start_time))[2,1,0] ), 
		( $moov_start - 1 - $restart_offset ) / ($end_time - $start_time) / 1024.0 * 8.0, 
		$prog->{filename} );

	# Moving file into place as complete (if not stdout)
	move($prog->{filepart}, $prog->{filename}) if ! $opt->{stdout};

	# Re-symlink file
	$prog->create_symlink( $prog->{symlink}, $prog->{filename} ) if $opt->{symlink};

	$prog->{mode} = 'iphone';
	return 0;
}



# Usage: moov_length = relocate_moov_chunk_offsets(<binary string>)
sub relocate_moov_chunk_offsets {
	my $moovdata = $_[0];
	# Change all the chunk offsets in moov->stco atoms and add moov_length to them all
	# get moov atom length
	my $moov_length = bytestring_to_int( substr($moovdata, 0, 4) );
	# Use index() to search for a string within a string
	my $i = -1;
	while (($i = index($moovdata, 'stco', $i)) > -1) {

		# determine length of atom (4 bytes preceding stco)
		my $stco_len = bytestring_to_int( substr($moovdata, $i-4, 4) );
		main::logger "INFO: Found stco atom at moov atom offset: $i length $stco_len\n" if $opt->{verbose};

		# loop through all chunk offsets in this atom and add offset (== moov atom length)
		for (my $j = $i+12; $j < $stco_len+$i-4; $j+=4) {
			my $chunk_offset = bytestring_to_int( substr($moovdata, $j, 4) );
			$chunk_offset += $moov_length;
			# write back bytes into $moovdata
			write_msb_value_at_offset( $moovdata, $j, $chunk_offset );
		}

		# skip over this whole atom now it is processed
		$i += $stco_len;
	}
	# Write $moovdata back to calling string
	$_[0] = $moovdata;
	return $moov_length;
}



# Replace the moov->udta atom with a new user-supplied one and update the moov atom size
# Usage: replace_moov_udta_atom ( $udta_new, $moovdata )
sub replace_moov_udta_atom {
	my $udta_new = $_[0];
	my $moovdata = $_[1];

	# get moov atom length
	my $moov_length = bytestring_to_int( substr($moovdata, 0, 4) );

	# Find the original udta atom start 
	# Use index() to search for a string within a string ($i will point at the beginning of the atom)
	my $i = index($moovdata, 'udta', -1) - 4;

	# determine length of atom (4 bytes preceding the name)
	my $udta_len = bytestring_to_int( substr($moovdata, $i, 4) );
	main::logger "INFO: Found udta atom at moov atom offset: $i length $udta_len\n" if $opt->{verbose};

	# Save the data before the udta atom
	my $moovdata_before_udta = substr($moovdata, 0, $i);

	# Save the remainder portion of data after the udta atom for later
	my $moovdata_after_udta = substr($moovdata, $i, $moovdata - $i + $udta_len);

	# Old udta atom should we need it
	### my $udta_old = substr($moovdata, $i, $udta_len);

	# Create new moov atom
	$moovdata = $moovdata_before_udta.$udta_new.$moovdata_after_udta;
	
	# Recalculate the moov size and insert into moovdata
	write_msb_value_at_offset( $moovdata, 0, length($moovdata) );
	
	# Write $moovdata back to calling string
	$_[1] = $moovdata;

	return 0;
}



# Converts a string of chars to it's MSB decimal value
sub bytestring_to_int {
	# Reverse to LSB order
        my $buf = reverse shift;
        my $dec = 0;
        for (my $i=0; $i<length($buf); $i++) {
		# Multiply byte value by 256^$i then accumulate
                $dec += (ord substr($buf, $i, 1)) * 256 ** $i;
        }
        #main::logger "DEBUG: Decimal value = $dec\n" if $opt->{verbose};
        return $dec;
}



# Write the msb 4 byte $value starting at $offset into the passed string
# Usage: write_msb_value($string, $offset, $value)
sub write_msb_value_at_offset {
	my $offset = $_[1];
	my $value = $_[2];
	substr($_[0], $offset+0, 1) = chr( ($value >> 24) & 0xFF );
	substr($_[0], $offset+1, 1) = chr( ($value >> 16) & 0xFF );
	substr($_[0], $offset+2, 1) = chr( ($value >>  8) & 0xFF );
	substr($_[0], $offset+3, 1) = chr( ($value >>  0) & 0xFF );
	return 0;
}



# Returns a string containing an QT atom
# Usage: create_qt_atom(<atome name>, <atom data>, ['string'])
sub create_qt_atom {
	my ($name, $data, $prog_type) = (@_);
	if (length($name) != 4) {
		main::logger "ERROR: Inavlid QT atom name length '$name'\n";
		exit 1;
	}
	# prepend string length if this is a string type
	if ( $prog_type eq 'string' ) {
		my $value = length($data);
		$data = '1111'.$data;
		# overwrite '1111' with total atom length in 2-byte MSB + 0x0 0x0
		substr($data, 0, 1) = chr( ($value >> 8) & 0xFF );
		substr($data, 1, 1) = chr( ($value >> 0) & 0xFF );
		substr($data, 2, 1) = chr(0);
		substr($data, 3, 1) = chr(0);
	}
	my $atom = '0000'.$name.$data;
	# overwrite '0000' with total atom length in MSB
	write_msb_value_at_offset( $atom, 0, length($name.$data) + 4 );
	return $atom;
}



################### Streamer::rtmp class #################
package Streamer::rtmp;

# Inherit from Streamer class
use base 'Streamer';

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
use Time::Local;
use URI;


sub opt_format {
	return {
		ffmpeg		=> [ 0, "ffmpeg=s", 'External Program', '--ffmpeg <path>', "Location of ffmpeg binary"],
		rtmp		=> [ 0, "rtmp", '', '', ""],
		rtmpdump	=> [ 0, "rtmpdump=s", 'External Program', '--rtmpdump <path>', "Location of rtmpdump binary"],
	};
}


# %prog (only for {ext} and {mode})
# Actually do the RTMP stream downloading
sub get {
	my ( $stream, $ua, $url_2, $prog, $mode, $application, $tcurl, $authstring, $swfurl ) = @_;
	my $file_tmp;
	my $cmd;
	
	if ( $opt->{raw} ) {
		$file_tmp = $prog->{filepart};
	} else {
		$file_tmp = $prog->{filepart}.'.flv'
	}

	# Remove failed file download (below a certain size) - hack to get around rtmpdump not returning correct exit code
	if ( -f $file_tmp && stat($file_tmp)->size < $min_download_size ) {
		unlink( $file_tmp );
	}
		
	main::logger "INFO: RTMP_URL: $url_2, tcUrl: $tcurl, application: $application, authString: $authstring, swfUrl: $swfurl, file: $prog->{filepart}, file_done: $prog->{filename}\n" if $opt->{verbose};

	# Create symlink if required
	$prog->create_symlink( $prog->{symlink}, $file_tmp ) if $opt->{symlink};

	$cmd = "$rtmpdump --resume --rtmp \"$url_2\" --auth \"$authstring\" --swfUrl \"$swfurl\" --tcUrl \"$tcurl\" --app \"$application\" -o \"$file_tmp\" 1>&2";
	#$cmd = "$rtmpdump --resume --rtmp \"$url_2\" --auth \"$authstring\" --swfUrl \"$swfurl\" -o \"$file_tmp\" 1>&2";
	main::logger "\n\nINFO: Command: $cmd\n";
	my $return = system($cmd) >> 8;
	main::logger "INFO: Command exit code = $return\n" if $opt->{verbose};
	#if ( (! -f $file_tmp) || ($return && -f $file_tmp && stat($file_tmp)->size < $min_download_size) ) {
	# Hack to get around rtmpdump prentending to fail on successful flash downloads or pretending to succeed where it failed
	if ( (! -f $file_tmp) || ( -f $file_tmp && stat($file_tmp)->size < $min_download_size) ) {
		main::logger "INFO: Command: $cmd\n" if $opt->{verbose};
		main::logger "WARNING: Failed to download file $file_tmp via RTMP\n";
		unlink $file_tmp;
		return 'next';
	}
	
	# Retain raw flv format if required
	if ( $opt->{raw} ) {
		move($file_tmp, $prog->{filename}) if ! $opt->{stdout};
		return 0;

	# Convert flv to mp3/aac
	} elsif ( $mode eq 'flashaudio' ) {
		# We could do id3 tagging here with ffmpeg but id3v2 does this later anyway
		# This fails
		#$cmd = "$ffmpeg -i \"$file_tmp\" -vn -acodec copy -y \"$prog->{filepart}\" 1>&2";
		# This works but it's really bad bacause it re-transcodes mp3 and takes forever :-(
		# $cmd = "$ffmpeg -i \"$file_tmp\" -acodec libmp3lame -ac 2 -ab 128k -vn -y \"$prog->{filepart}\" 1>&2";
		# At last this removes the flv container and dumps the mp3 stream! - mplayer dumps core but apparently succeeds
		$cmd = "$mplayer $mplayer_opts -dumpaudio \"$file_tmp\" -dumpfile \"$prog->{filepart}\" 1>&2";
	# Convert flv to aac/mp4a
	} elsif ( $mode eq 'flashaac' ) {
		# This works as long as we specify aac andnot mp4a
		$cmd = "$ffmpeg -i \"$file_tmp\" -vn -acodec copy -y \"$prog->{filepart}\" 1>&2";
	# Convert video flv to mp4/avi if required
	} else {
		$cmd = "$ffmpeg $ffmpeg_opts -i \"$file_tmp\" -vcodec copy -acodec copy -f $prog->{ext} -y \"$prog->{filepart}\" 1>&2";
	}

	main::logger "\n\nINFO: Command: $cmd\n\n" if $opt->{verbose};
	# Run flv conversion and delete source file on success
	my $return = system($cmd) >> 8;
	main::logger "INFO: Command exit code = $return\n" if $opt->{verbose};
	if ( (! $return) && -f $prog->{filepart} && stat($prog->{filepart})->size > $min_download_size ) {
			unlink( $file_tmp );

	# If the ffmpeg conversion failed, remove the failed-converted file attempt - move the file as done anyway
	} else {
		main::logger "WARNING: flv conversion failed - retaining flv file\n";
		unlink $prog->{filepart};
		$prog->{filepart} = $file_tmp;
		$prog->{filename} = $file_tmp;
	}
	# Moving file into place as complete (if not stdout)
	move($prog->{filepart}, $prog->{filename}) if ! $opt->{stdout};
	
	# Re-symlink file
	$prog->create_symlink( $prog->{symlink}, $prog->{filename} ) if $opt->{symlink};

	main::logger "INFO: Downloaded $prog->{filename}\n";
	$prog->{mode} = $mode;
	return 0;
}



package Streamer::rtsp;

# Inherit from Streamer class
use base 'Streamer';

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
use Time::Local;
use URI;


# %prog (only for lame id3 tagging and {mode})
# Actually do the rtsp downloading
sub get {
	my ( $stream, $ua, $url, $prog ) = @_;
	my $childpid;

	# Create named pipe
	if ( $^O !~ /^MSWin32$/ ) {
		mkfifo($namedpipe, 0700) if (! $opt->{wav}) && (! $opt->{raw});
	} else {
		main::logger "WARNING: fifos/named pipes are not supported\n" if $opt->{verbose};
	}
	
	main::logger "INFO: Stage 3 URL = $url\n" if $opt->{verbose};

	# Create ID3 tagging options for lame (escape " for shell)
	my ( $id3_name, $id3_episode, $id3_desc, $id3_channel ) = ( $prog->{name}, $prog->{episode}, $prog->{desc}, $prog->{channel} );
	$id3_name =~ s|"|\"|g for ($id3_name, $id3_episode, $id3_desc, $id3_channel);
	$lame_opts .= " --ignore-tag-errors --ty ".( (localtime())[5] + 1900 )." --tl \"$id3_name\" --tt \"$id3_episode\" --ta \"$id3_channel\" --tc \"$id3_desc\" ";

	# Use post-download transcoding using lame if namedpipes are not supported (i.e. ActivePerl/Windows)
	# (Fallback if no namedpipe support and raw/wav not specified)
	if ( (! -p $namedpipe) && ! ( $opt->{raw} || $opt->{wav} ) ) {
		my $cmd;
		# Remove filename extension
		$prog->{filepart} =~ s/\.mp3$//gi;
		# Remove named pipe
		unlink $namedpipe;
		main::logger "INFO: Downloading wav format (followed by transcoding)\n";
		$cmd = "$mplayer $mplayer_opts -cache 128 -bandwidth $bandwidth -vc null -vo null -ao pcm:waveheader:fast:file=\"$prog->{filepart}.wav\" \"$url\" 1>&2";
		if ( system($cmd) ) {
			return 'next';
		}
		# Transcode
		main::logger "INFO: Transcoding $prog->{filepart}.wav\n";
		$cmd = "$lame $lame_opts \"$prog->{filepart}.wav\" \"$prog->{filepart}.mp3\" 1>&2";
		main::logger "DEGUG: Running $cmd\n" if $opt->{debug};
		if ( system($cmd) || (-f "$prog->{filepart}.wav" && stat("$prog->{filepart}.wav")->size < $min_download_size) ) {
			return 'next';
		}
		unlink "$prog->{filepart}.wav";
		move "$prog->{filepart}.mp3", $prog->{filename};
		$prog->{ext} = 'mp3';

	# Fork a child to do transcoding on the fly using a named pipe written to by mplayer
	# else do direct mplayer write to wav file if:
	#  1) we don't have a named pipe available (e.g. in activeperl)
	#  2) --wav was specified to write file only
	} elsif ( $opt->{wav} && ! $opt->{stdout} ) {
		main::logger "INFO: Writing wav format\n";
		# Start the mplayer process and write to wav file
		my $cmd = "$mplayer $mplayer_opts -cache 128 -bandwidth $bandwidth -vc null -vo null -ao pcm:waveheader:fast:file=\"$prog->{filepart}\" \"$url\" 1>&2";
		main::logger "DEGUG: Running $cmd\n" if $opt->{debug};
		if ( system($cmd) ) {
			return 'next';
		}
		# Move file to done state
		move $prog->{filepart}, $prog->{filename} if ! $opt->{nowrite};

	# No transcoding if --raw was specified
	} elsif ( $opt->{raw} && ! $opt->{stdout} ) {
		# Write out to .ra ext instead (used on fallback if no fifo support)
		main::logger "INFO: Writing raw realaudio stream\n";
		# Start the mplayer process and write to raw file
		my $cmd = "$mplayer $mplayer_opts -cache 128 -bandwidth $bandwidth -dumpstream -dumpfile \"$prog->{filepart}\" \"$url\" 1>&2";
		main::logger "DEGUG: Running $cmd\n" if $opt->{debug};
		if ( system($cmd) ) {
			return 'next';
		}
		# Move file to done state
		move $prog->{filepart}, $prog->{filename} if ! $opt->{nowrite};

	# Use transcoding via named pipes
	} else {
		$childpid = fork();
		if (! $childpid) {
			# Child starts here
			$| = 1;
			main::logger "INFO: Transcoding $prog->{filepart}\n";

			# Stream mp3 to file and stdout simultaneously
			if ( $opt->{stdout} && ! $opt->{nowrite} ) {
				if ( $opt->{wav} || $opt->{raw} ) {
					# Race condition - closes named pipe immediately unless we wait
					sleep 5;
					tee($namedpipe, $prog->{filepart});
					#system( "cat $namedpipe 2>/dev/null| $tee $prog->{filepart}");
				} else {
					my $cmd = "$lame $lame_opts $namedpipe - 2>/dev/null| $tee \"$prog->{filepart}\"";
					main::logger "DEGUG: Running $cmd\n" if $opt->{debug};
					system($cmd);
				}

			# Stream mp3 stdout only
			} elsif ( $opt->{stdout} && $opt->{nowrite} ) {
				if ( $opt->{wav} || $opt->{raw} ) {
					sleep 5;
					tee($namedpipe);
					#system( "cat $namedpipe 2>/dev/null");
				} else {
					my $cmd = "$lame $lame_opts $namedpipe - 2>/dev/null";
					main::logger "DEGUG: Running $cmd\n" if $opt->{debug};
					system( "$lame $lame_opts $namedpipe - 2>/dev/null");
				}

			# Stream mp3 to file directly
			} elsif ( ! $opt->{stdout} ) {
				my $cmd = "$lame $lame_opts $namedpipe \"$prog->{filepart}\" >/dev/null 2>/dev/null";
				main::logger "DEGUG: Running $cmd\n" if $opt->{debug};
				system($cmd);
			}
			# Remove named pipe
			unlink $namedpipe;

			# Move file to done state
			move $prog->{filepart}, $prog->{filename} if ! $opt->{nowrite};
			main::logger "INFO: Transcoding thread has completed\n";
			exit 0;
		}
		# Start the mplayer process and write to named pipe
		# Raw mode
		if ( $opt->{raw} ) {
			my $cmd = "$mplayer $mplayer_opts -cache 32 -bandwidth $bandwidth -dumpstream -dumpfile $namedpipe \"$url\" 1>&2";
			main::logger "DEGUG: Running $cmd\n" if $opt->{debug};
			if ( system($cmd) ) {
				# If we fail then kill off child processes
				kill 9, $childpid;
				return 'next';
			}
		# WAV / mp3 mode
		} else {
			my $cmd = "$mplayer $mplayer_opts -cache 128 -bandwidth $bandwidth -vc null -vo null -ao pcm:waveheader:fast:file=$namedpipe \"$url\" 1>&2";
			if ( system($cmd) ) {
				# If we fail then kill off child processes
				kill 9, $childpid;
				return 'next';
			}
		}
		# Wait for child processes to prevent zombies
		wait;
	}
	main::logger "INFO: Downloaded $prog->{filename}\n";

	# Create symlink if required
	$prog->create_symlink( $prog->{symlink}, $prog->{filename} ) if $opt->{symlink};

	$prog->{mode} = 'realaudio';
	return 0;
}




package Streamer::mms;

# Inherit from Streamer class
use base 'Streamer';

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
use Time::Local;
use URI;


# get hulu prog info
sub get_url {
	my ( undef, $ua, $pid ) = ( @_ );

	my ( $response, $url_1, $url_2, $url_3, $url_4 );
	my $part;
	my $duration;
	my $filename;
	my @url_list;

	# construct stage 1 request url
	$url_1 = 'http://www.itv.com/_app/video/GetMediaItem.ashx?vodcrid=crid://itv.com/'.$pid.'&bitrate=384&adparams=SITE=ITV/AREA=CATCHUP.VIDEO/SEG=CATCHUP.VIDEO%20HTTP/1.1';

	# Extract '<LicencePlaylist>(.+?) HTTP/1.1</LicencePlaylist>'
	main::logger "INFO: ITV Video Stage 1 URL: $url_1\n" if $opt->{verbose};
	$response = main::request_url_retry($ua, $url_1, 2, '', '');
	main::logger "DEBUG: Response data: $response\n" if $opt->{debug};
	$url_2 = $1 if $response =~ m{<LicencePlaylist>(.+?) HTTP/1.1</LicencePlaylist>};
	# replace '&amp;' with '&' and append '%20HTTP/1.1'
	$url_2 =~ s/&amp;/&/g;
	$url_2 .= '%20HTTP/1.1';
	return '' if $url_2 !~ m{http\:\/\/}i;
	main::logger "INFO: ITV Video Stage 2 URL: $url_2\n" if $opt->{verbose};
	$response = main::request_url_retry($ua, $url_2, 2, '', '');
	main::logger "DEBUG: Response data: $response\n" if $opt->{debug};

	# Extract hrefs and names. There are multiple entries for parts of prog (due to ads):
	# e.g. <asx><Title>Doctor Zhivago</Title><EntryRef href="HTTP://SAM.ITV.COM/XTSERVER/ACC_RANDOM=1231194223/SITE=ITV/AREA=CATCHUP.VIDEO/SEG=CATCHUP.VIDEO HTTP/1.1/SOURCE=CATCH.UP/GENRE=DRAMA/PROGNAME=DOCTOR.ZHIVAGO/PROGID=33105/SERIES=DOCTOR.ZHIVAGO/EPNUM=/EPTITLE=/BREAKNUM=0/ADPOS=1/PAGEID=01231194223/DENTON=0/CUSTOMRATING=/TOTDUR=90/PREDUR=0/POSDUR=905/GENERIC=6e0536bf-7883-4aaa-9230-94ecc4aea403/AAMSZ=VIDEO" /><EntryRef href="HTTP://SAM.ITV.COM/XTSERVER/ACC_RANDOM=1231194223/SITE=ITV/AREA=CATCHUP.VIDEO/SEG=CATCHUP.VIDEOHTTP/1.1/SOURCE=CATCH.UP/GENRE=DRAMA/PROGNAME=DOCTOR.ZHIVAGO/PROGID=33105/SERIES=DOCTOR.ZHIVAGO/EPNUM=/EPTITLE=/BREAKNUM=0/ADPOS=LAST/PAGEID=01231194223/DENTON=0/CUSTOMRATING=/TOTDUR=90/PREDUR=0/POSDUR=905/GENERIC=6e0536bf-7883-4aaa-9230-94ecc4aea403/AAMSZ=VIDEO" />
	#$prog->{name} = $1 if $response =~ m{<Title>(.+?)<\/Title>};
	for my $entry (split /<Entry><ref\s+href=/, $response) {
		main::logger "DEBUG: Entry data: $entry\n" if $opt->{debug};
		$entry .= '<Entry><ref href='.$entry;

		( $url_3, $part, $filename, $duration ) = ( $1, $2, $3, $4 ) if $entry =~ m{<Entry><ref\s+href="(.+?)"\s+\/><param\s+value="true"\s+name="Prebuffer"\s+\/>\s*<PARAM\s+NAME="PrgPartNumber"\s+VALUE="(.+?)"\s*\/><PARAM\s+NAME="FileName"\s+VALUE="(.+?)"\s*\/><PARAM\s+NAME="PrgLength"\s+VALUE="(.+?)"\s*\/>};
		next if not $url_3;
		# Replace '&amp;' with '&' in url
		$url_3 =~ s/&amp;/&/g;
		main::logger "INFO: ITV Video Name: $part\n";

		main::logger "INFO: ITV Video Stage 3 URL: $url_3\n" if $opt->{verbose};
		$entry = main::request_url_retry($ua, $url_3, 2, '', '');
		main::logger "DEBUG: Response data: $entry\n" if $opt->{debug};

		# Extract mms (replace 'http' with 'mms') url: e.g.: Ref1=http://itvbrdbnd.wmod.llnwd.net/a1379/o21/ucontent/2007/6/22/1549_384_1_2.wmv?MSWMExt=.asf
		chomp( $url_4 = 'mms'.$1 ) if $entry =~ m{Ref1=http(.+?)[\r\n]+};
		main::logger "INFO: ITV Video URL: $url_4\n" if $opt->{verbose};
		push @url_list, $url_4;
	}
	return @url_list;
}



# %prog (only used for {mode} and generating multi-part file prefixes)
# Actually do the MMS video stream downloading
sub get {
	my ( $stream, $ua, $urls, $prog ) = @_;
	my $file_tmp;
	my $cmd;
	my @url_list = split /\|/, $urls;
	my @file_tmp_list;
	my %threadpid;
	my $retries = 3;
		
	main::logger "INFO: MMS_URLs: ".(join ', ', @url_list).", file: $prog->{filepart}, file_done: $prog->{filename}\n" if $opt->{verbose};

	# Start marker
	my $start_time = time();
	# Download each mms url (multi-threaded to download in parallel)
	my $file_part_prefix = "$prog->{dir}/$prog->{fileprefix}_part";
	for ( my $count = 0; $count <= $#url_list; $count++ ) {

		# Create temp download filename
		$file_tmp = sprintf( "%s%02d.asf", $file_part_prefix, $count+1);
		$file_tmp_list[$count] = $file_tmp;
		#my $null;
		#$null = '-really-quiet' if ! $opt->{quiet};
		# Can also use 'mencoder mms://url/ -oac copy -ovc copy -o out.asf' - still gives zero exit code on failed stream...
		# $cmd = "$mplayer $mplayer_opts -dumpstream \"$url_list[$count]\" -dumpfile \"$file_tmp\" $null 1>&2";
		# Use backticks to invoke mplayer and grab all output then grep for 'read error'
		$cmd = "$mplayer $mplayer_opts -dumpstream \"$url_list[$count]\" -dumpfile \"$file_tmp\" 2>&1";
		main::logger "INFO: Command: $cmd\n" if $opt->{verbose};

		my $childpid = fork();
		if (! $childpid) {
			# Child starts here
			main::logger "INFO: Downloading file $file_tmp\n";
			# Remove old file
			unlink $file_tmp;
			# Retry loop
			my $retry = $retries;
			while ($retry) {
				my $cmdoutput = `$cmd`;
				my $exitcode = $?;
				main::logger "DEBUG: Command '$cmd', Output:\n$cmdoutput\n\n" if $opt->{debug};
				if ( grep /(read error|connect error|Failed, exiting)/i, $cmdoutput || $exitcode ) {
					# Failed, retry
					main::logger "WARNING: Failed, retrying to download $file_tmp, exit code: $exitcode\n";
					$retry--;
				} else {
					# Successfully downloaded
					main::logger "INFO: Download thread has completed for file $file_tmp\n";
					exit 0;
				}
			}
			main::logger "ERROR: Download thread failed after $retries retries for $file_tmp (renamed to ${file_tmp}.failed)\n";
			move $file_tmp, "${file_tmp}.failed";
			exit 1;
		}
		# Create a hash of process_id => 'count'
		$threadpid{$childpid} = $count;
	}
	# Wait for all threads to complete
	$| = 1;
	# Autoreap zombies
	$SIG{CHLD}='IGNORE';
	my $done = 0;
	my $done_symlink;
	while (keys %threadpid) {
		my @sizes;
		my $total_size = 0;
		my $total_size_new = 0;
		my $format = "Threads: ";
		sleep 1;
		#main::logger "DEBUG: ProcessIDs: ".(join ',', keys %threadpid)."\n";
		for my $procid (sort keys %threadpid) {
			my $size = 0;
			# Is this child still alive?
			if ( kill 0 => $procid ) {
				main::logger "DEBUG Thread $threadpid{$procid} still alive ($file_tmp_list[$threadpid{$procid}])\n" if $opt->{debug};
				# Build the status string
				$format .= "%d) %.3fMB   ";
				$size = stat($file_tmp_list[$threadpid{$procid}])->size if -f $file_tmp_list[$threadpid{$procid}];
				push @sizes, $threadpid{$procid}+1, $size/(1024.0*1024.0);
				$total_size_new += $size;
				# Now create a symlink if this is the first part and size > min_download_size
				if ( $threadpid{$procid} == 0 && $done_symlink != 1 && $opt->{symlink} && $size > $min_download_size ) {
					# Symlink to file if only one part or to dir if multi-part
					if ( $#url_list ) {
						$prog->create_symlink( $prog->{symlink}, $prog->{dir} );
					} else {
						$prog->create_symlink( $prog->{symlink}, $file_tmp_list[$threadpid{$procid}] );
					}
					$done_symlink = 1;
				}
			# Thread has completed/failed
			} else {
				$size = stat($file_tmp_list[$threadpid{$procid}])->size if -f $file_tmp_list[$threadpid{$procid}];
				# end marker
				my $end_time = time();
				# Calculate average speed, duration and total bytes downloaded
				main::logger sprintf("INFO: Thread #%d Downloaded %.2fMB in %s at %5.0fkbps to %s\n", 
					($threadpid{$procid}+1),
					$size / (1024.0 * 1024.0),
					sprintf("%02d:%02d:%02d", ( gmtime($end_time - $start_time))[2,1,0] ), 
					$size / ($end_time - $start_time) / 1024.0 * 8.0,
					$file_tmp_list[$threadpid{$procid}] );
				# Remove from thread test list
				delete $threadpid{$procid};
			}
		}
		$format .= " downloaded (%.0fkbps)        \r";
		main::logger sprintf $format, @sizes, ($total_size_new - $total_size) / (time() - $start_time) / 1024.0 * 8.0;
	}
	main::logger "INFO: All download threads completed\n";	
	# Unset autoreap
	delete $SIG{CHLD};

	# If not all files > min_size then assume download failed
	for (@file_tmp_list) {
		# If file doesnt exist or too small then skip
		if ( (! -f $_) || ( -f $_ && stat($_)->size < $min_download_size ) ) {
			main::logger "ERROR: Download of programme failed, skipping\n" if $opt->{verbose};
			return 1;
		}
	}

	$prog->{mode} = 'hulu';
#	# Retain raw format if required
#	if ( $opt->{raw} ) {
#		# Create symlink to first part file
#		$prog->create_symlink( $prog->{symlink}, $file_tmp_list[0] ) if $opt->{symlink};
#		return 0;
#	}
#
#	# Convert video asf to mp4 if required - need to find a suitable converter...
#	} else {
#		# Create part of cmd that specifies each partial file
#		my $filestring;
#		$filestring .= " -i \"$_\" " for (@file_tmp_list);
#		$cmd = "$ffmpeg $ffmpeg_opts $filestring -vcodec copy -acodec copy -f $prog->{ext} -y \"$prog->{filepart}\" 1>&2";
#	}
#
#	main::logger "INFO: Command: $cmd\n\n" if $opt->{verbose};
#	# Run asf conversion and delete source file on success
#	if ( ! system($cmd) ) {
#		unlink( @file_tmp_list );
#	} else {
#		main::logger "ERROR: asf conversion failed - retaining files ".(join ', ', @file_tmp_list)."\n";
#		return 2;
#	}
#	# Moving file into place as complete (if not stdout)
#	move($prog->{filepart}, $prog->{filename}) if ! $opt->{stdout};
#	# Create symlink if required
#	$prog->create_symlink( $prog->{symlink}, $prog->{filename} ) if $opt->{symlink};
	return 0;
}



package Streamer::3gp;

# Inherit from Streamer class
use base 'Streamer';

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
use Time::Local;
use URI;


# Generic
# Actually do the 3gp / N95 h.264 downloading
sub get {
	my ( $stream, $ua, $url_2, $prog, $mode ) = @_;

	# Change filename extension
	$prog->{filepart} =~ s/mov$/mpg/gi;
	$prog->{filename} =~ s/mov$/mpg/gi;

	main::logger "INFO: Stage 3 URL = $url_2\n" if $opt->{verbose};
	if ( ! $opt->{stdout} ) {
		main::logger "INFO: Downloading Low Quality H.264 stream\n";
		my $cmd = "$vlc $vlc_opts --sout file/ts:$prog->{filepart} $url_2 1>&2";
		if ( system($cmd) ) {
			return 'next';
		}

	# to STDOUT
	} else {
		main::logger "INFO: Streaming Low Quality H.264 stream to stdout\n";
		my $cmd = "$vlc $vlc_opts --sout file/ts:- $url_2 1>&2";
		if ( system($cmd) ) {
			return 'next';
		}	
	}
	main::logger "INFO: Downloaded $prog->{filename}\n";
	# Moving file into place as complete (if not stdout)
	move($prog->{filepart}, $prog->{filename}) if ! $opt->{stdout};

	$prog->create_symlink( $prog->{symlink}, $prog->{filename} ) if $opt->{symlink};

	$prog->{mode} = $mode;
	return 0;
}



package Streamer::podcast;

# Inherit from Streamer class
use base 'Streamer';

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use HTML::Entities;
use HTTP::Cookies;
use HTTP::Headers;
use IO::Seekable;
use IO::Socket;
use LWP::ConnCache;
use LWP::UserAgent;
use POSIX qw(mkfifo);
use strict;
use Time::Local;
use URI;

# Generic
# Actually do the podcast downloading
sub get {
	my ( $stream, $ua, $url_2, $prog ) = @_;
	my $start_time = time();

	# Set user agent
	$ua->agent( $user_agent{get_iplayer} );

	main::logger "INFO: Stage 3 URL = $url_2\n" if $opt->{verbose};

	# Resume partial download?
	my $start = 0;
	if ( -f $prog->{filepart} ) {
		$start = stat($prog->{filepart})->size;
		main::logger "INFO: Resuming download from $start\n";
	}

	my $fh = main::open_file_append($prog->{filepart});

	if ( main::download_block($prog->{filepart}, $url_2, $ua, $start, undef, undef, $fh) != 0 ) {
		main::logger "ERROR: Download failed\n";
		return 'next';
	} else {
		# end marker
		my $end_time = time();
		# Final file size
		my $size = stat($prog->{filepart})->size;
		# Calculate average speed, duration and total bytes downloaded
		main::logger sprintf("INFO: Downloaded %.2fMB in %s at %5.0fkbps to %s\n", 
			($size - $start) / (1024.0 * 1024.0),
			sprintf("%02d:%02d:%02d", ( gmtime($end_time - $start_time))[2,1,0] ), 
			( $size - $start ) / ($end_time - $start_time) / 1024.0 * 8.0, 
			$prog->{filename} );
		move $prog->{filepart}, $prog->{filename};
		# re-symlink file
		$prog->create_symlink( $prog->{symlink}, $prog->{filename} ) if $opt->{symlink};
	}

	$prog->{mode} = 'podcast';
	return 0;
}



############# PVR Class ##############
package Pvr;

use Env qw[@PATH];
use Fcntl;
use File::Copy;
use File::Path;
use File::stat;
use IO::Seekable;
use IO::Socket;
use strict;
use Time::Local;

# Class vars
my %vars = {};
# Global options
my $optref;
my $opt_fileref;
my $opt_cmdlineref;
my $opt;
my $opt_file;
my $opt_cmdline;

# Class cmdline Options
sub opt_format {
	return {
		pvr		=> [ 0, "pvr|pvrrun|pvr-run", 'PVR', '--pvr', "Runs the PVR download using all saved PVR searches (intended to be run every hour from cron etc)"],
		pvradd		=> [ 0, "pvradd|pvr-add=s", 'PVR', '--pvradd <search name>', "Add the current search terms to the named PVR search"],
		pvrdel		=> [ 0, "pvrdel|pvr-del=s", 'PVR', '--pvrdel <search name>', "Remove the named search from the PVR searches"],
		pvrdisable	=> [ 0, "pvrdisable|pvr-disable=s", 'PVR', '--pvr-disable <search name>', "Disable (not delete) a named PVR search"],
		pvrenable	=> [ 0, "pvrenable|pvr-enable=s", 'PVR', '--pvr-enable <search name>', "Enable a previously disabled named PVR search"],
		pvrlist		=> [ 0, "pvrlist|pvr-list", 'PVR', '--pvrlist', "Show the PVR search list"],
		pvrqueue	=> [ 0, "pvrqueue|pvr-queue", 'PVR', '--pvrqueue', "Add currently matched programmes to queue for later one-off downloading using the --pvr option"],
		comment		=> [ 0, "comment=s", '', '', "Adds a comment to a PVR search"],
	};
}


# Constructor
# Usage: $pvr = Pvr->new();
sub new {
	my $type = shift;
	my %params = @_;
	my $self = {};
	for (keys %params) {
		$self->{$_} = $params{$_};
	}
	## Ensure the subclass $opt var is pointing to the Superclass global optref
	$opt = $Pvr::optref;
	$opt_file = $Pvr::opt_fileref;
	$opt_cmdline = $Pvr::opt_cmdlineref;
	bless $self, $type;
}


# Use to bind a new options ref to the class global $opt_ref var
sub add_opt_object {
	my $self = shift;
	$Pvr::optref = shift;
}
# Use to bind a new options ref to the class global $opt_fileref var
sub add_opt_file_object {
	my $self = shift;
	$Pvr::opt_fileref = shift;
}
# Use to bind a new options ref to the class global $opt_cmdlineref var
sub add_opt_cmdline_object {
	my $self = shift;
	$Pvr::opt_cmdlineref = shift;
}


# Use to bind a new options ref to the class global $optref var
sub setvar {
	my $self = shift;
	my $varname = shift;
	my $value = shift;
	$vars{$varname} = $value;
}
sub getvar {
	my $self = shift;
	my $varname = shift;
	return $vars{$varname};
}


# $opt->{<option>} access method
sub opt {
	my $self = shift;
	my $optname = shift;
	return $opt->{$optname};
}


# Load all PVR searches and run one-by-one
# Usage: $pvr->run( $opt_file, \$lockfile, @search_args )
sub run {
	my $pvr = shift;
	my $opt_file = shift;
	my $lockfile_ref = shift;
	my @search_args = shift;

	# Don't attempt to download pids in download history
	my %pids_history = main::load_download_history();

	# Load all PVR searches
	$pvr->load_list();

	# Display default options from options files only
	$opt_file->display('Default Options', '(help|debug|get|^pvr)');

	# For each PVR search
	for my $name ( sort {lc $a cmp lc $b} keys %{$pvr} ) {
		# Ignore if this search is disabled
		if ( $pvr->{$name}->{disable} ) {
			main::logger "\nSkipping disabled PVR Search '$name'\n" if $opt->{verbose};
			next;
		}
		main::logger "\nRunning PVR Search '$name'\n";
		# Clear then Load options for specified pvr search name
		my @search_args = $pvr->load_options($name);
		# Switch on --hide option
		$opt->{hide} = 1;
		# Dont allow --flush with --pvr
		$opt->{flush} = '';
		# Do the downloads (force --get option)
		$opt->{get} = 1 if ! $opt->{test};
		# If this is a one-off queue pid entry then delete the PVR entry upon successful download(s)
		if ( $pvr->{$name}->{pid} ) {
			my $failcount = main::find_matches( \%pids_history );
			$pvr->del( $name ) if not $failcount;
		# Just download matching progs
		} else {
			main::download_matches( main::find_matches( \%pids_history, @search_args ) );
		}
	}
}



# If queuing, only add pids because the index number might change by the time the pvr runs
# If --pid and --type <type> is specified then add this prog also
sub queue {
	my $pvr = shift;
	my @search_args = @_;

	# Switch on --hide option
	$opt->{hide} = 1;
	my %pids_history = main::load_download_history();

	# PID and TYPE specified
	if ( $opt_cmdline->{pid} ) {
		if ( $opt_cmdline->{type} && $opt_cmdline->{type} !~ ',' ) {
			$pvr->add( "ONCE: ($opt_cmdline->{pid})" ) if ! main::check_download_history( $opt_cmdline->{pid} );
		} else {
			main::logger "ERROR: Cannot add a pid to the PVR queue without a single --type specified\n";
			return 1;
		}

	# Search specified
	} else {
		my @matches = main::find_matches( \%pids_history, @search_args );
		# Add a PVR entry for each matching prog PID
		for my $this ( @matches ) {
			$opt_cmdline->{pid} = $this->{pid};
			$opt_cmdline->{type} = $this->{type};
			$pvr->add( $this->substitute('ONCE: <name> - <episode> (<pid>)') );
		}

	}
	return 0;
}



# Save the options on the cmdline as a PVR search with the specified name
sub add {
	my $pvr = shift;
	my $name = shift;
	my @search_args = @_;
	my @options;
	# validate name
	if ( $name !~ m{[\w\-\+]+} ) {
		main::logger "ERROR: Invalid PVR search name '$name'\n";
		return 1;
	}
	# Parse valid options and create array (ignore options from the options files that have not been overriden on the cmdline)
	for (grep /^(pid|comment|amode|vmode|long|output.*|proxy|subdir|whitespace|versions|type|(exclude)?category|(exclude)?channel|exclude|listformat|command|realaudio|mp3audio|wav|raw|bandwidth|subtitles|suboffset|since|versionlist|verbose)$/, sort {lc $a cmp lc $b} keys %{$opt_cmdline} ) {
		if ( defined $opt_cmdline->{$_} ) {
				push @options, "$_ $opt_cmdline->{$_}";
				main::logger "DEBUG: Adding option $_ = $opt_cmdline->{$_}\n" if $opt->{debug};
		}
	}
	# Add search args to array
	for ( my $count = 0; $count <= $#search_args; $count++ ) {
		push @options, "search${count} $search_args[$count]";
		main::logger "DEBUG: Adding search${count} = $search_args[$count]\n" if $opt->{debug};
	}
	# Save search to file
	$pvr->save( $name, @options );
	#$pvr->show( $name );
	return 0;
}



# Delete the named PVR search
sub del {
	my $pvr = shift;
	my $name = shift;
	# validate name
	if ( $name !~ m{[\w\-\+]+} ) {
		main::logger "ERROR: Invalid PVR search name '$name'\n";
		return 1;
	}
	# Delete pvr search file
	if ( -f $vars{pvr_dir}.$name ) {
		unlink $vars{pvr_dir}.$name;
		main::logger "INFO: Deleted PVR search '$name'\n";
	} else {
		main::logger "ERROR: PVR search '$name' does not exist\n";
		return 1;
	}
	return 0;
}



# Display all the PVR searches
sub display_list {
	my $pvr = shift;
	# Load all the PVR searches
	$pvr->load_list();
	# Print out list
	main::logger "All PVR Searches:\n\n";
	for my $name ( sort {lc $a cmp lc $b} keys %{$pvr} ) {
		# Report whether disabled
		if ( $pvr->{$name}->{disable} ) {
			main::logger "(Disabled) PVR Search '$name':\n";
		} else {
			main::logger "PVR Search '$name':\n";
		}
		for ( sort keys %{ $pvr->{$name} } ) {
			main::logger "\t$_ = $pvr->{$name}->{$_}\n";
		}
		main::logger "\n";
	}
	return 0;
}



# Load all the PVR searches into %{$pvr}
sub load_list {
	my $pvr = shift;
	# Make dir if not existing
	mkpath $vars{pvr_dir} if ! -d $vars{pvr_dir};
	# Get list of files in pvr_dir
	# open file with handle DIR
	opendir( DIR, $vars{pvr_dir} );
	if ( ! opendir( DIR, $vars{pvr_dir}) ) {
		main::logger "ERROR: Cannot open directory $vars{pvr_dir}\n";
		return 1;
	}
	# Get contents of directory (ignoring . .. and ~ files)
	my @files = grep ! /(^\.{1,2}$|^.*~$)/, readdir DIR;
	# Close the directory
	closedir DIR;
	# process each file
	for my $file (@files) {
		chomp($file);
		# Re-add the dir
		$file = "$vars{pvr_dir}/$file";
		next if ! -f $file;
		if ( ! open (PVR, "< $file") ) {
			main::logger "WARNING: Cannot read PVR search file $file\n";
			next;
		}
		my @options = <PVR>;
		close PVR;
		# Get search name from filename
		my $name = $file;
		$name =~ s/^.*\/([^\/]+?)$/$1/g;
		for (@options) {
			/^\s*([\w\-_]+?)\s+(.*)\s*$/;
			main::logger "DEBUG: PVR search '$name': option $1 = $2\n" if $opt->{debug};
			$pvr->{$name}->{$1} = $2;
		}
		main::logger "INFO: Loaded PVR search '$name'\n" if $opt->{verbose};
	}
	main::logger "INFO: Loaded PVR search list\n" if $opt->{verbose};
	return 0;
}



# Save the array options specified as a PVR search
sub save {
	my $pvr = shift;
	my $name = shift;
	my @options = @_;
	# Make dir if not existing
	mkpath $vars{pvr_dir} if ! -d $vars{pvr_dir};
	main::logger "INFO: Saving PVR search '$name':\n";
	# Open file
	if ( ! open (PVR, "> $vars{pvr_dir}/${name}") ) { 
		main::logger "ERROR: Cannot save PVR search to $vars{pvr_dir}.$name\n";
		return 1;
	}
	# Write options array to file
	for (@options) {
		print PVR "$_\n";
		main::logger "\t$_\n";
	}
	close PVR;
	return 0;
}


# Uses class globals: %opt, %opt_file, %opt_cmdline
# Returns @search_args
# Clear all exisiting global args and opts then load the options specified in the default options and specified PVR search
sub load_options {
	my $pvr = shift;
	my $name = shift;
	# Clear out existing options hash
	%{$opt} = ();
	# Re-read options from the options files - these will act as defaults
	$opt->copy_set_options_from( $opt_file );

	# Clear search args
	@search_args = ();
	# Set each option from the search
	for ( sort {$a <=> $b} keys %{ $pvr->{$name} } ) {
		# Add to list of search args if this is not an option
		if ( /^search\d+$/ ) {
			main::logger "INFO: $_ = $pvr->{$name}->{$_}\n" if $opt->{verbose};
			push @search_args, $pvr->{$name}{$_};
		# Else populate options, ignore disable option
		} elsif ( $_ ne 'disable' ) {
			main::logger "INFO: Option: $_ = $pvr->{$name}->{$_}\n" if $opt->{verbose};
			$opt->{$_} = $pvr->{$name}->{$_};
		}
	}
	# Allow cmdline args to override those in the PVR search
	# Re-read options from the cmdline
	$opt->copy_set_options_from( $opt_cmdline );
	return @search_args;
}



# Disable a PVR search by adding 'disable 1' option
sub disable {
	my $pvr = shift;
	my $name = shift;
	$pvr->load_list();
	my @options;
	for ( keys %{ $pvr->{$name} }) {
		push @options, "$_ $pvr->{$name}->{$_}";
	}
	# Add the disable option
	push @options, 'disable 1';
	$pvr->save( $name, @options );
	return 0;
}



# Re-enable a PVR search by removing 'disable 1' option
sub enable {
	my $pvr = shift;
	my $name = shift;
	$pvr->load_list();
	my @options;
	for ( keys %{ $pvr->{$name} }) {
		push @options, "$_ $pvr->{$name}->{$_}";
	}
	# Remove the disable option
	@options = grep !/^disable\s/, @options;
	$pvr->save( $name, @options );	
	return 0;
}





############## End OO ##############

